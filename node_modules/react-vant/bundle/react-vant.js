var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("react"), require("react-dom")) : typeof define === "function" && define.amd ? define(["exports", "react", "react-dom"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2["react-vant"] = {}, global2.React, global2.ReactDOM));
})(this, function(exports2, React, ReactDOM) {
  "use strict";
  function _interopDefaultLegacy(e2) {
    return e2 && typeof e2 === "object" && "default" in e2 ? e2 : { "default": e2 };
  }
  function _interopNamespace(e2) {
    if (e2 && e2.__esModule)
      return e2;
    var n2 = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
    if (e2) {
      Object.keys(e2).forEach(function(k2) {
        if (k2 !== "default") {
          var d2 = Object.getOwnPropertyDescriptor(e2, k2);
          Object.defineProperty(n2, k2, d2.get ? d2 : {
            enumerable: true,
            get: function() {
              return e2[k2];
            }
          });
        }
      });
    }
    n2["default"] = e2;
    return Object.freeze(n2);
  }
  var React__default = /* @__PURE__ */ _interopDefaultLegacy(React);
  var React__namespace = /* @__PURE__ */ _interopNamespace(React);
  var ReactDOM__default = /* @__PURE__ */ _interopDefaultLegacy(ReactDOM);
  var ReactDOM__namespace = /* @__PURE__ */ _interopNamespace(ReactDOM);
  var base$1 = "";
  function getTargetElement(target, defaultElement) {
    if (!target) {
      return defaultElement;
    }
    let targetElement;
    if (typeof target === "function") {
      targetElement = target();
    } else if ("current" in target) {
      targetElement = target.current;
    } else {
      targetElement = target;
    }
    return targetElement;
  }
  const defaultEvent = "click";
  function useClickAway(target, onClickAway, eventName = defaultEvent) {
    const onClickAwayRef = React.useRef(onClickAway);
    onClickAwayRef.current = onClickAway;
    React.useEffect(() => {
      const handler = (event) => {
        const targets = Array.isArray(target) ? target : [target];
        if (targets.some((targetItem) => {
          const targetElement = getTargetElement(targetItem);
          return !targetElement || (targetElement == null ? void 0 : targetElement.contains(event.target));
        })) {
          return;
        }
        onClickAwayRef.current(event);
      };
      document.addEventListener(eventName, handler);
      return () => {
        document.removeEventListener(eventName, handler);
      };
    }, [target, eventName]);
  }
  function noop$3() {
  }
  const extend = Object.assign;
  const inBrowser = typeof window !== "undefined";
  function isDef(val) {
    return val !== void 0 && val !== null;
  }
  function isFunction(val) {
    return typeof val === "function";
  }
  function isPromise(val) {
    return isObject$1(val) && isFunction(val.then) && isFunction(val.catch);
  }
  function isObject$1(val) {
    return val !== null && typeof val === "object";
  }
  function pick(obj, keys, ignoreUndefined) {
    return keys.reduce((ret, key) => {
      if (!ignoreUndefined || obj[key] !== void 0) {
        ret[key] = obj[key];
      }
      return ret;
    }, {});
  }
  function once$1(fn) {
    return (...args) => {
      if (!fn)
        return;
      fn(...args);
      fn = null;
    };
  }
  function gen(name, mods) {
    if (!mods) {
      return "";
    }
    if (typeof mods === "string") {
      return ` ${name}--${mods}`;
    }
    if (Array.isArray(mods)) {
      return mods.reduce((ret, item) => ret + gen(name, item), "");
    }
    return Object.keys(mods).reduce((ret, key) => ret + (mods[key] ? gen(name, key) : ""), "");
  }
  function createBEM(name) {
    return (el, mods) => {
      if (el && typeof el !== "string") {
        mods = el;
        el = "";
      }
      el = el ? `${name}__${el}` : name;
      return `${el}${gen(el, mods)}`;
    };
  }
  function createNamespace(name, prefix2) {
    name = `${prefix2 || "rv"}-${name}`;
    return [createBEM(name), name];
  }
  function stopPropagation(event) {
    event.stopPropagation();
  }
  function preventDefault(event, isStopPropagation) {
    if (typeof event.cancelable !== "boolean" || event.cancelable) {
      event.preventDefault();
    }
    if (isStopPropagation) {
      stopPropagation(event);
    }
  }
  const eventToPropRecord = {
    "click": "onClick"
  };
  function withStopPropagation(events, element) {
    const props = __spreadValues({}, element.props);
    for (const key of events) {
      const prop = eventToPropRecord[key];
      props[prop] = function(e2) {
        var _a, _b;
        e2.stopPropagation();
        (_b = (_a = element.props)[prop]) == null ? void 0 : _b.call(_a, e2);
      };
    }
    return React__default["default"].cloneElement(element, props);
  }
  const root = inBrowser ? window : global;
  let prev = Date.now();
  function rafPolyfill(fn) {
    const curr = Date.now();
    const ms = Math.max(0, 16 - (curr - prev));
    const id = setTimeout(fn, ms);
    prev = curr + ms;
    return id;
  }
  function raf$1(fn) {
    const requestAnimationFrame = root.requestAnimationFrame || rafPolyfill;
    return requestAnimationFrame.call(root, fn);
  }
  function cancelRaf(id) {
    const cancelAnimationFrame = root.cancelAnimationFrame || root.clearTimeout;
    cancelAnimationFrame.call(root, id);
  }
  function doubleRaf(fn) {
    raf$1(() => {
      raf$1(fn);
    });
  }
  function isIOS$1() {
    return inBrowser ? /ios|iphone|ipad|ipod/.test(navigator.userAgent.toLowerCase()) : false;
  }
  function isWindow$2(val) {
    return val === window;
  }
  function getScrollTop$1(el) {
    const top2 = "scrollTop" in el ? el.scrollTop : el.pageYOffset;
    return Math.max(top2, 0);
  }
  function getRootScrollTop() {
    return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
  }
  function setRootScrollTop(value) {
    setScrollTop(window, value);
  }
  function getElementTop(el, scroller) {
    if (isWindow$2(el)) {
      return 0;
    }
    const scrollTop = scroller ? getScrollTop$1(scroller) : getRootScrollTop();
    return el.getBoundingClientRect().top + scrollTop;
  }
  function getVisibleHeight(el) {
    if (isWindow$2(el)) {
      return el.innerHeight;
    }
    return el.getBoundingClientRect().height;
  }
  function getVisibleTop(el) {
    if (isWindow$2(el)) {
      return 0;
    }
    return el.getBoundingClientRect().top;
  }
  function setScrollTop(el, value) {
    if ("scrollTop" in el) {
      el.scrollTop = value;
    } else {
      el.scrollTo(el.scrollX, value);
    }
  }
  let rafId;
  function scrollLeftTo(scroller, to2, duration) {
    cancelRaf(rafId);
    let count = 0;
    const from = scroller.scrollLeft;
    const frames = duration === 0 ? 1 : Math.round(duration / 16);
    function animate() {
      scroller.scrollLeft += (to2 - from) / frames;
      if (++count < frames) {
        rafId = raf$1(animate);
      }
    }
    animate();
  }
  function scrollTopTo(scroller, to2, duration, callback) {
    let current = getScrollTop$1(scroller);
    const isDown = current < to2;
    const frames = duration === 0 ? 1 : Math.round(duration / 16);
    const step = (to2 - current) / frames;
    function animate() {
      current += step;
      if (isDown && current > to2 || !isDown && current < to2) {
        current = to2;
      }
      setScrollTop(scroller, current);
      if (isDown && current < to2 || !isDown && current > to2) {
        raf$1(animate);
      } else if (callback) {
        raf$1(callback);
      }
    }
    animate();
  }
  const isIOS = isIOS$1();
  function resetScroll() {
    if (isIOS) {
      setRootScrollTop(getRootScrollTop());
    }
  }
  function isHidden(elementRef) {
    const el = elementRef;
    if (!el) {
      return false;
    }
    const style = window.getComputedStyle(el);
    const hidden = style.display === "none";
    const parentHidden = el.offsetParent === null && style.position !== "fixed";
    return hidden || parentHidden;
  }
  function parseChildList(children) {
    return React__default["default"].Children.toArray(children).map((node) => {
      if (React__default["default"].isValidElement(node)) {
        const key = node.key !== void 0 ? String(node.key) : void 0;
        return __spreadProps(__spreadValues({
          key
        }, node.props), {
          node
        });
      }
      return null;
    }).filter((child) => child);
  }
  function isNumeric(val) {
    return /^\d+(\.\d+)?$/.test(val);
  }
  function isNaN$1(val) {
    if (Number.isNaN) {
      return Number.isNaN(val);
    }
    return val !== val;
  }
  function addUnit$1(value) {
    if (!isDef(value)) {
      return void 0;
    }
    value = String(value);
    return isNumeric(value) ? `${value}px` : value;
  }
  function getSizeStyle(originSize) {
    if (isDef(originSize)) {
      const size = addUnit$1(originSize);
      return {
        width: size,
        height: size
      };
    }
    return {};
  }
  function getZIndexStyle(zIndex) {
    const style = {};
    if (zIndex !== void 0) {
      style.zIndex = +zIndex;
    }
    return style;
  }
  let rootFontSize;
  function getRootFontSize() {
    if (!rootFontSize) {
      const doc = document.documentElement;
      const fontSize = doc.style.fontSize || window.getComputedStyle(doc).fontSize;
      rootFontSize = parseFloat(fontSize);
    }
    return rootFontSize;
  }
  function convertRem(value) {
    value = value.replace(/rem/g, "");
    return +value * getRootFontSize();
  }
  function convertVw(value) {
    value = value.replace(/vw/g, "");
    return +value * window.innerWidth / 100;
  }
  function convertVh(value) {
    value = value.replace(/vh/g, "");
    return +value * window.innerHeight / 100;
  }
  function unitToPx(value) {
    if (typeof value === "number") {
      return value;
    }
    if (inBrowser) {
      if (value.indexOf("rem") !== -1) {
        return convertRem(value);
      }
      if (value.indexOf("vw") !== -1) {
        return convertVw(value);
      }
      if (value.indexOf("vh") !== -1) {
        return convertVh(value);
      }
    }
    return parseFloat(value);
  }
  function kebabCase$1(str) {
    return str.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
  }
  function range$1(num, min, max) {
    return Math.min(Math.max(num, min), max);
  }
  function trimExtraChar(value, char, regExp) {
    const index2 = value.indexOf(char);
    if (index2 === -1) {
      return value;
    }
    if (char === "-" && index2 !== 0) {
      return value.slice(0, index2);
    }
    return value.slice(0, index2 + 1) + value.slice(index2).replace(regExp, "");
  }
  function formatNumber(value, allowDot = true, allowMinus = true) {
    if (allowDot) {
      value = trimExtraChar(value, ".", /\./g);
    } else {
      value = value.split(".")[0];
    }
    if (allowMinus) {
      value = trimExtraChar(value, "-", /-/g);
    } else {
      value = value.replace(/-/, "");
    }
    const regExp = allowDot ? /[^-0-9.]/g : /[^-0-9]/g;
    return value.replace(regExp, "");
  }
  function addNumber(num1, num2) {
    const cardinal = 10 ** 10;
    return Math.round((num1 + num2) * cardinal) / cardinal;
  }
  function padZero(num, targetLength = 2) {
    let str = `${num}`;
    while (str.length < targetLength) {
      str = `0${str}`;
    }
    return str;
  }
  const SECOND = 1e3;
  const MINUTE = 60 * SECOND;
  const HOUR = 60 * MINUTE;
  const DAY = 24 * HOUR;
  function parseTime(time) {
    const days = Math.floor(time / DAY);
    const hours = Math.floor(time % DAY / HOUR);
    const minutes = Math.floor(time % HOUR / MINUTE);
    const seconds = Math.floor(time % MINUTE / SECOND);
    const milliseconds = Math.floor(time % SECOND);
    return {
      total: time,
      days,
      hours,
      minutes,
      seconds,
      milliseconds
    };
  }
  function isSameSecond(time1, time2) {
    return Math.floor(time1 / 1e3) === Math.floor(time2 / 1e3);
  }
  function useCountDown(options) {
    const rafId2 = React.useRef(0);
    const endTime = React.useRef(0);
    const counting = React.useRef(false);
    const [remain, updateRemain] = React.useState(() => options.time);
    const remainRef = React.useRef(0);
    const currentRef = React.useRef({});
    const current = React.useMemo(() => parseTime(remain), [remain]);
    currentRef.current = current;
    remainRef.current = remain;
    const pause = () => {
      counting.current = false;
      cancelRaf(rafId2.current);
    };
    const getCurrentRemain = () => Math.max(endTime.current - Date.now(), 0);
    const setRemain = (value) => {
      var _a, _b;
      remainRef.current = value;
      updateRemain(value);
      (_a = options.onChange) == null ? void 0 : _a.call(options, currentRef.current);
      if (value === 0) {
        pause();
        (_b = options.onFinish) == null ? void 0 : _b.call(options);
      }
    };
    const microTick = () => {
      rafId2.current = raf$1(() => {
        if (counting.current) {
          setRemain(getCurrentRemain());
          if (remainRef.current > 0) {
            microTick();
          }
        }
      });
    };
    const macroTick = () => {
      rafId2.current = raf$1(() => {
        if (counting.current) {
          const remainRemain = getCurrentRemain();
          if (!isSameSecond(remainRemain, remainRef.current) || remainRemain === 0) {
            setRemain(remainRemain);
          }
          if (remainRef.current > 0) {
            macroTick();
          }
        }
      });
    };
    const tick = () => {
      if (!inBrowser) {
        return;
      }
      if (options.millisecond) {
        microTick();
      } else {
        macroTick();
      }
    };
    const start2 = () => {
      if (!counting.current) {
        endTime.current = Date.now() + remainRef.current;
        counting.current = true;
        tick();
      }
    };
    const reset = (totalTime = options.time) => {
      pause();
      remainRef.current = totalTime;
      updateRemain(totalTime);
    };
    React.useEffect(() => {
      if (options.autostart) {
        start2();
      }
    }, []);
    return {
      start: start2,
      pause,
      reset,
      current
    };
  }
  let supportsPassive$1 = false;
  if (inBrowser) {
    try {
      const opts = {};
      Object.defineProperty(opts, "passive", {
        get() {
          supportsPassive$1 = true;
        }
      });
      window.addEventListener("test-passive", null, opts);
    } catch (e2) {
    }
  }
  function useEventListener(type2, listener, options = {}) {
    if (!inBrowser) {
      return;
    }
    const {
      target = window,
      passive: passive2 = false,
      capture = false,
      depends = []
    } = options;
    let attached;
    const add2 = () => {
      const element = getTargetElement(target);
      if (element && !attached) {
        element.addEventListener(type2, listener, supportsPassive$1 ? { capture, passive: passive2 } : capture);
        attached = true;
      }
    };
    const remove = () => {
      const element = getTargetElement(target);
      if (element && attached) {
        element.removeEventListener(type2, listener, capture);
        attached = false;
      }
    };
    React.useEffect(() => {
      add2();
      return () => remove();
    }, [target, ...depends]);
  }
  function isEmpty(val) {
    if (isObject$1(val)) {
      return JSON.stringify(val) === "{}";
    }
    return true;
  }
  function useFormSmart(option = {}) {
    const { value, sync: sync2 } = option;
    const ref = React.useRef(null);
    const [once2, setOnce] = React.useState(false);
    const set2 = React.useCallback((values) => {
      var _a;
      (_a = ref == null ? void 0 : ref.current) == null ? void 0 : _a.setFieldsValue(values);
    }, []);
    const get2 = React.useCallback((name) => {
      var _a;
      return (_a = ref == null ? void 0 : ref.current) == null ? void 0 : _a.getFieldValue(name);
    }, []);
    const submit = React.useCallback(() => {
      var _a;
      (_a = ref == null ? void 0 : ref.current) == null ? void 0 : _a.submit();
    }, []);
    const clear2 = React.useCallback(() => {
      var _a;
      (_a = ref == null ? void 0 : ref.current) == null ? void 0 : _a.resetFields();
    }, []);
    const getAll = React.useCallback(() => {
      var _a;
      return (_a = ref == null ? void 0 : ref.current) == null ? void 0 : _a.getFieldsValue();
    }, []);
    React.useEffect(() => {
      if (!isEmpty(value)) {
        if (sync2) {
          set2(value);
        } else if (!once2) {
          set2(value);
          setOnce(true);
        }
      }
    }, [value]);
    const methods = { set: set2, get: get2, submit, clear: clear2, getAll };
    return [ref, methods];
  }
  function useRefState(initialState) {
    const [state, setState] = React.useState(initialState);
    const ref = React.useRef(state);
    const setRafState = React.useCallback((patch) => {
      setState((prevState) => {
        return ref.current = isFunction(patch) ? patch(prevState) : patch;
      });
    }, [state]);
    return [state, setRafState, ref];
  }
  const useUnmountedRef = () => {
    const unmountedRef = React.useRef(false);
    React.useEffect(() => {
      unmountedRef.current = false;
      return () => {
        unmountedRef.current = true;
      };
    }, []);
    return unmountedRef;
  };
  const useSetState = (initialState = {}) => {
    const unmountedRef = useUnmountedRef();
    const [state, setState, ref] = useRefState(initialState);
    const setMergeState = React.useCallback((patch) => {
      if (unmountedRef.current)
        return;
      setState((prevState) => __spreadValues(__spreadValues({}, prevState), isFunction(patch) ? patch(prevState) : patch));
    }, []);
    return [state, setMergeState, ref];
  };
  const useUpdateEffect = (effect3, deps) => {
    const isMounted = React.useRef(false);
    React.useEffect(() => {
      if (!isMounted.current) {
        isMounted.current = true;
      } else {
        return effect3();
      }
      return void 0;
    }, deps);
  };
  const useMount = (fn) => {
    React.useEffect(() => {
      fn();
    }, []);
  };
  function usePageVisibility() {
    const [visibility, _setVisibility] = React.useState("visible");
    const setVisibility = () => {
      if (inBrowser) {
        _setVisibility(document.hidden ? "hidden" : "visible");
      }
    };
    React.useEffect(() => {
      setVisibility();
    }, []);
    useEventListener("visibilitychange", setVisibility, { depends: [visibility] });
    return visibility;
  }
  function useVisibilityChange(target, onChange) {
    const [state, setState] = React.useState();
    React.useEffect(() => {
      if (!inBrowser || !window.IntersectionObserver) {
        return null;
      }
      const observer = new IntersectionObserver((entries) => {
        onChange == null ? void 0 : onChange(entries[0].intersectionRatio > 0);
        for (const entry of entries) {
          setState(entry.isIntersecting);
        }
      }, { root: document.body });
      const observe = () => {
        if (target.current) {
          observer.observe(target.current);
        }
      };
      const unobserve = () => {
        if (target.current) {
          observer.unobserve(target.current);
        }
      };
      observe();
      return unobserve;
    }, [target.current]);
    return [state];
  }
  function useLatest(value) {
    const ref = React.useRef(value);
    ref.current = value;
    return ref;
  }
  const useUnmount = (fn) => {
    const fnRef = useLatest(fn);
    React.useEffect(() => () => {
      fnRef.current();
    }, []);
  };
  function depsAreSame(oldDeps, deps) {
    if (oldDeps === deps)
      return true;
    for (let i = 0; i < oldDeps.length; i++) {
      if (!Object.is(oldDeps[i], deps[i]))
        return false;
    }
    return true;
  }
  const createEffectWithTarget = (useEffectType) => {
    const useEffectWithTarget2 = (effect3, deps, target) => {
      const hasInitRef = React.useRef(false);
      const lastElementRef = React.useRef([]);
      const lastDepsRef = React.useRef([]);
      const unLoadRef = React.useRef();
      useEffectType(() => {
        var _a;
        const targets = Array.isArray(target) ? target : [target];
        const els = targets.map((item) => getTargetElement(item));
        if (!hasInitRef.current) {
          hasInitRef.current = true;
          lastElementRef.current = els;
          lastDepsRef.current = deps;
          unLoadRef.current = effect3();
          return;
        }
        if (els.length !== lastElementRef.current.length || !depsAreSame(els, lastElementRef.current) || !depsAreSame(deps, lastDepsRef.current)) {
          (_a = unLoadRef.current) == null ? void 0 : _a.call(unLoadRef);
          lastElementRef.current = els;
          lastDepsRef.current = deps;
          unLoadRef.current = effect3();
        }
      });
      useUnmount(() => {
        var _a;
        (_a = unLoadRef.current) == null ? void 0 : _a.call(unLoadRef);
        hasInitRef.current = false;
      });
    };
    return useEffectWithTarget2;
  };
  const useEffectWithTarget = createEffectWithTarget(React.useEffect);
  function useInViewport(target, options) {
    const [state, setState] = React.useState();
    const [ratio, setRatio] = React.useState();
    useEffectWithTarget(() => {
      const el = getTargetElement(target);
      if (!el) {
        return;
      }
      const observer = new IntersectionObserver((entries) => {
        for (const entry of entries) {
          setRatio(entry.intersectionRatio);
          setState(entry.isIntersecting);
        }
      }, __spreadProps(__spreadValues({}, options), {
        root: getTargetElement(options == null ? void 0 : options.root)
      }));
      observer.observe(el);
      return () => {
        observer.disconnect();
      };
    }, [], target);
    return [state, ratio];
  }
  const MIN_DISTANCE = 10;
  function getDirection$1(x2, y2) {
    if (x2 > y2 && x2 > MIN_DISTANCE) {
      return "horizontal";
    }
    if (y2 > x2 && y2 > MIN_DISTANCE) {
      return "vertical";
    }
    return "";
  }
  function useTouch() {
    const startX = React.useRef(0);
    const startY = React.useRef(0);
    const deltaX = React.useRef(0);
    const deltaY = React.useRef(0);
    const offsetX = React.useRef(0);
    const offsetY = React.useRef(0);
    const direction = React.useRef("");
    const isVertical = () => direction.current === "vertical";
    const isHorizontal = () => direction.current === "horizontal";
    const reset = () => {
      deltaX.current = 0;
      deltaY.current = 0;
      offsetX.current = 0;
      offsetY.current = 0;
      direction.current = "";
    };
    const start2 = (event) => {
      reset();
      startX.current = event.touches[0].clientX;
      startY.current = event.touches[0].clientY;
    };
    const move2 = (event) => {
      const touch = event.touches[0];
      deltaX.current = touch.clientX < 0 ? 0 : touch.clientX - startX.current;
      deltaY.current = touch.clientY - startY.current;
      offsetX.current = Math.abs(deltaX.current);
      offsetY.current = Math.abs(deltaY.current);
      if (!direction.current) {
        direction.current = getDirection$1(offsetX.current, offsetY.current);
      }
    };
    return {
      move: move2,
      start: start2,
      reset,
      startX,
      startY,
      deltaX,
      deltaY,
      offsetX,
      offsetY,
      direction,
      isVertical,
      isHorizontal
    };
  }
  const overflowScrollReg = /scroll|auto/i;
  const defaultRoot = inBrowser ? window : void 0;
  function isElement$1(node) {
    const ELEMENT_NODE_TYPE = 1;
    return node.tagName !== "HTML" && node.tagName !== "BODY" && node.nodeType === ELEMENT_NODE_TYPE;
  }
  function getScrollParent$1(el, root2 = defaultRoot) {
    if (root2 === void 0) {
      root2 = window;
    }
    let node = el;
    while (node && node !== root2 && isElement$1(node)) {
      const { overflowY } = window.getComputedStyle(node);
      if (overflowScrollReg.test(overflowY)) {
        if (node.tagName !== "BODY") {
          return node;
        }
        const htmlOverflowY = window.getComputedStyle(node.parentNode).overflowY;
        if (overflowScrollReg.test(htmlOverflowY)) {
          return node;
        }
      }
      node = node.parentNode;
    }
    return root2;
  }
  function useScrollParent(el) {
    const [scrollParent, setScrollParent] = React.useState();
    React.useEffect(() => {
      if (el) {
        const element = getTargetElement(el);
        setScrollParent(getScrollParent$1(element));
      }
    }, []);
    return scrollParent;
  }
  function useWindowSize() {
    const [width, setWidth] = React.useState(inBrowser ? window.innerWidth : 0);
    const [height, setHeight] = React.useState(inBrowser ? window.innerHeight : 0);
    const onResize = () => {
      setWidth(window.innerWidth);
      setHeight(window.innerHeight);
    };
    useEventListener("resize", onResize);
    useEventListener("orientationchange", onResize);
    return { width, height };
  }
  const createUpdateEffect = (hook) => (effect3, deps) => {
    const isMounted = React.useRef(false);
    hook(() => {
      return () => {
        isMounted.current = false;
      };
    }, []);
    hook(() => {
      if (!isMounted.current) {
        isMounted.current = true;
      } else {
        return effect3();
      }
    }, deps);
  };
  const useIsomorphicLayoutEffect = inBrowser ? React__default["default"].useLayoutEffect : React__default["default"].useEffect;
  const useIsomorphicUpdateLayoutEffect = createUpdateEffect(useIsomorphicLayoutEffect);
  const useUpdate = () => {
    const [, setState] = React.useState({});
    return React.useCallback(() => setState({}), []);
  };
  function useMemoizedFn(fn) {
    const fnRef = React.useRef(fn);
    fnRef.current = React.useMemo(() => fn, [fn]);
    const memoizedFn = React.useRef();
    if (!memoizedFn.current) {
      memoizedFn.current = function(...args) {
        return fnRef.current.apply(this, args);
      };
    }
    return memoizedFn.current;
  }
  function usePropsValue(options) {
    const { value, defaultValue, onChange } = options;
    const update2 = useUpdate();
    const stateRef = React.useRef(value !== void 0 ? value : defaultValue);
    if (value !== void 0) {
      stateRef.current = value;
    }
    const setState = useMemoizedFn((v2, forceTrigger) => {
      const nextValue = typeof v2 === "function" ? v2(stateRef.current) : v2;
      if (!forceTrigger && nextValue === stateRef.current)
        return;
      stateRef.current = nextValue;
      update2();
      onChange == null ? void 0 : onChange(nextValue);
    });
    return [stateRef.current, setState];
  }
  var index$14 = {
    useClickAway,
    useCountDown,
    useEventListener,
    useFormSmart,
    useSetState,
    useUpdateEffect,
    useMount,
    usePageVisibility,
    useVisibilityChange,
    useInViewport,
    useTouch,
    useScrollParent,
    useWindowSize,
    useIsomorphicLayoutEffect,
    useUpdate,
    useMemoizedFn,
    usePropsValue
  };
  var index$13 = "";
  function r$1(e2) {
    var t2, f2, n2 = "";
    if (typeof e2 == "string" || typeof e2 == "number")
      n2 += e2;
    else if (typeof e2 == "object")
      if (Array.isArray(e2))
        for (t2 = 0; t2 < e2.length; t2++)
          e2[t2] && (f2 = r$1(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
      else
        for (t2 in e2)
          e2[t2] && (n2 && (n2 += " "), n2 += t2);
    return n2;
  }
  function clsx() {
    for (var e2, t2, f2 = 0, n2 = ""; f2 < arguments.length; )
      (e2 = arguments[f2++]) && (t2 = r$1(e2)) && (n2 && (n2 += " "), n2 += t2);
    return n2;
  }
  var index$12 = "";
  const SpinIcon = ({ bem: bem2 }) => /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, Array(12).fill(null).map((_, index2) => /* @__PURE__ */ React__default["default"].createElement("i", {
    key: index2,
    className: clsx(bem2("line", String(index2 + 1)))
  })));
  const CircularIcon = ({ bem: bem2 }) => /* @__PURE__ */ React__default["default"].createElement("svg", {
    className: clsx(bem2("circular")),
    viewBox: "25 25 50 50"
  }, /* @__PURE__ */ React__default["default"].createElement("circle", {
    cx: "50",
    cy: "50",
    r: "20",
    fill: "none"
  }));
  const BallIcon = ({ bem: bem2 }) => /* @__PURE__ */ React__default["default"].createElement("div", {
    className: clsx(bem2("ball"))
  }, /* @__PURE__ */ React__default["default"].createElement("div", null), /* @__PURE__ */ React__default["default"].createElement("div", null), /* @__PURE__ */ React__default["default"].createElement("div", null));
  const Icon = (bem2) => ({
    spinner: /* @__PURE__ */ React__default["default"].createElement(SpinIcon, {
      bem: bem2
    }),
    circular: /* @__PURE__ */ React__default["default"].createElement(CircularIcon, {
      bem: bem2
    }),
    ball: /* @__PURE__ */ React__default["default"].createElement(BallIcon, {
      bem: bem2
    })
  });
  const [bem$1C] = createNamespace("loading");
  const Loading = (props) => {
    const {
      className,
      type: type2,
      vertical,
      color,
      size,
      textColor,
      children,
      textSize
    } = props;
    const spinnerStyle = React.useMemo(() => __spreadValues({
      color
    }, getSizeStyle(size)), [color, size]);
    const renderText = () => {
      if (children) {
        return /* @__PURE__ */ React__default["default"].createElement("span", {
          className: clsx(bem$1C("text")),
          style: {
            fontSize: addUnit$1(textSize),
            color: textColor != null ? textColor : color
          }
        }, children);
      }
      return null;
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(className, bem$1C([type2, { vertical }])),
      style: props.style
    }, /* @__PURE__ */ React__default["default"].createElement("span", {
      className: clsx(bem$1C("spinner", type2)),
      style: spinnerStyle
    }, Icon(bem$1C)[type2]), renderText());
  };
  Loading.defaultProps = {
    type: "circular"
  };
  const WHITE = "#fff";
  const BORDER = "rv-hairline";
  const BORDER_TOP = `${BORDER}--top`;
  const BORDER_LEFT = `${BORDER}--left`;
  const BORDER_BOTTOM = `${BORDER}--bottom`;
  const BORDER_SURROUND = `${BORDER}--surround`;
  const BORDER_TOP_BOTTOM = `${BORDER}--top-bottom`;
  const BORDER_UNSET_TOP_BOTTOM = `${BORDER}-unset--top-bottom`;
  const SHADOW = "rv-shadow";
  const COMPONENT_TYPE_KEY = "__REACT_VANT_COMPONENT";
  const ButtonContext = React__default["default"].createContext({});
  const [bem$1B] = createNamespace("button");
  const Button$1 = (props) => {
    const { color, loading, className, hairline, loadingText } = props;
    const { parent } = React.useContext(ButtonContext);
    const size = React__default["default"].useMemo(() => props.size || (parent == null ? void 0 : parent.size) || "normal", [parent == null ? void 0 : parent.size, props.size]);
    const type2 = React__default["default"].useMemo(() => props.type || (parent == null ? void 0 : parent.type) || "default", [parent == null ? void 0 : parent.type, props.type]);
    const plain = React__default["default"].useMemo(() => {
      var _a;
      return (_a = props.plain) != null ? _a : parent == null ? void 0 : parent.plain;
    }, [parent == null ? void 0 : parent.plain, props.plain]);
    const block = React__default["default"].useMemo(() => {
      var _a;
      return (_a = props.block) != null ? _a : parent == null ? void 0 : parent.block;
    }, [parent == null ? void 0 : parent.block, props.block]);
    const iconPosition = React__default["default"].useMemo(() => props.iconPosition || (parent == null ? void 0 : parent.iconPosition) || "left", [parent == null ? void 0 : parent.iconPosition, props.iconPosition]);
    const disabled = React__default["default"].useMemo(() => {
      var _a;
      return (_a = props.disabled) != null ? _a : parent == null ? void 0 : parent.disabled;
    }, [parent == null ? void 0 : parent.disabled, props.disabled]);
    const nativeType = React__default["default"].useMemo(() => props.nativeType || (parent == null ? void 0 : parent.nativeType) || "button", [parent == null ? void 0 : parent.nativeType, props.nativeType]);
    const tag = React__default["default"].useMemo(() => props.tag || (parent == null ? void 0 : parent.tag) || "button", [parent == null ? void 0 : parent.tag, props.tag]);
    const TagElement = tag;
    const classes = clsx(className, bem$1B([
      type2,
      size,
      {
        plain,
        loading,
        disabled,
        hairline,
        block,
        round: props.round,
        square: props.square
      }
    ]), { [BORDER_SURROUND]: hairline }, props.shadow && `${SHADOW}--${+props.shadow}`);
    const style = __spreadValues({}, props.style);
    if (color) {
      style.color = plain ? color : WHITE;
      if (!plain) {
        style.background = color;
      }
      if (color.indexOf("gradient") !== -1) {
        style.border = 0;
      } else {
        style.borderColor = color;
      }
    }
    const onClick = (event) => {
      if (!loading && !disabled && props.onClick) {
        props.onClick(event);
      }
    };
    const renderLoadingIcon = () => {
      if (loading) {
        const { loadingSize = "20px", loadingType } = props;
        return /* @__PURE__ */ React__default["default"].createElement(Loading, {
          className: clsx(bem$1B("loading")),
          size: loadingSize,
          type: loadingType,
          color: type2 === "default" ? void 0 : ""
        });
      }
      return null;
    };
    const renderIcon = () => {
      if (props.loading) {
        return renderLoadingIcon();
      }
      if (props.icon) {
        return React__default["default"].cloneElement(props.icon, {
          className: clsx(bem$1B("icon"))
        });
      }
      return null;
    };
    const renderText = () => {
      let text;
      if (loading) {
        text = loadingText;
      } else {
        text = props.children || props.text;
      }
      if (text) {
        return /* @__PURE__ */ React__default["default"].createElement("span", {
          key: "text",
          className: clsx(bem$1B("text"))
        }, text);
      }
      return null;
    };
    const renderContent = () => /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$1B("content"))
    }, iconPosition === "left" && renderIcon(), renderText(), iconPosition === "right" && renderIcon());
    return /* @__PURE__ */ React__default["default"].createElement(TagElement, {
      disabled,
      className: classes,
      style,
      type: nativeType,
      onClick
    }, renderContent());
  };
  const [bem$1A] = createNamespace("button-group");
  const ButtonGroup = (_a) => {
    var _b = _a, {
      className,
      style,
      children,
      onClick
    } = _b, props = __objRest(_b, [
      "className",
      "style",
      "children",
      "onClick"
    ]);
    const internalClick = (e2) => {
      if (props.disabled)
        return;
      onClick == null ? void 0 : onClick(e2);
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      onClick: internalClick,
      style,
      className: clsx(className, bem$1A([
        props.type,
        {
          round: props.round,
          plain: props.plain,
          disabled: props.disabled
        }
      ]), props.shadow && `${SHADOW}--${+props.shadow}`)
    }, /* @__PURE__ */ React__default["default"].createElement(ButtonContext.Provider, {
      value: { parent: props }
    }, children));
  };
  const Button = Object.assign(Button$1, { Group: ButtonGroup });
  var index$11 = "";
  const [bem$1z] = createNamespace("badge");
  const Badge = (props) => {
    const { content, max, dot, showZero, tag = "div" } = props;
    const TagElement = tag;
    const hasContent = () => {
      if (props.content) {
        return true;
      }
      return isDef(content) && content !== "" && (showZero || +content !== 0);
    };
    const renderContent = () => {
      if (!dot && hasContent()) {
        if (isDef(max) && isNumeric(content == null ? void 0 : content.toString()) && +content > max) {
          return `${max}+`;
        }
        return content;
      }
      return null;
    };
    const renderBadge = () => {
      if (hasContent() || props.dot) {
        let style = {
          background: props.color
        };
        if (props.offset) {
          const [x2, y2] = props.offset;
          if (props.children) {
            style.top = addUnit$1(y2);
            style.right = addUnit$1(x2);
          } else {
            style.marginTop = addUnit$1(y2);
            style.marginLeft = addUnit$1(x2);
          }
        }
        if (!props.children) {
          style = __spreadValues(__spreadValues({}, props.style), style);
        }
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx({
            [props.className]: props.className && !props.children
          }, bem$1z({ dot: props.dot, fixed: !!props.children })),
          style
        }, renderContent());
      }
      return null;
    };
    if (props.children) {
      return /* @__PURE__ */ React__default["default"].createElement(TagElement, {
        className: clsx(bem$1z("wrapper"), props.className),
        style: props.style,
        onClick: props.onClick,
        onTouchStart: props.onTouchStart
      }, props.children, renderBadge());
    }
    return renderBadge();
  };
  Badge.defaultProps = {
    tag: "div",
    showZero: true
  };
  var index$10 = "";
  var __rest = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  function kebabCase(str) {
    return str.substring(3).replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
  }
  const IconBase = React__namespace.forwardRef((props, ref) => {
    const { name = "", className, style, spin, rotate, tabIndex, onClick, children } = props, restProps = __rest(props, ["name", "className", "style", "spin", "rotate", "tabIndex", "onClick", "children"]);
    const svgStyle = {};
    if (rotate) {
      svgStyle.msTransform = `rotate(${rotate}deg)`;
      svgStyle.transform = `rotate(${rotate}deg)`;
    }
    const kebabCaseName = name ? kebabCase(name) : void 0;
    let iconTabIndex = tabIndex;
    if (iconTabIndex === void 0 && onClick) {
      iconTabIndex = -1;
    }
    const attrs = Object.assign({ role: "img", "aria-label": kebabCaseName, focusable: "false", "data-icon": kebabCaseName, "aria-hidden": "true", preserveAspectRatio: "xMidYMid meet", ref, tabIndex: iconTabIndex, onClick, className: [
      "rv-icon",
      kebabCaseName ? `rv-icon-${kebabCaseName}` : "",
      spin ? "rv-icon--spin" : "",
      className
    ].join(" ").trim(), style: Object.assign(Object.assign({}, style), svgStyle) }, restProps);
    return React__namespace.cloneElement(children, attrs);
  });
  const SvgIcon$3L = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M472.222 472.442V277.998c0-15.341 12.437-27.778 27.778-27.778h.143c15.262.08 27.57 12.516 27.49 27.777l-1.009 194.445h195.598c15.341 0 27.778 12.437 27.778 27.778s-12.437 27.778-27.778 27.778H526.336l-1.017 195.743c-.076 14.646-11.97 26.48-26.617 26.48-14.624 0-26.48-11.856-26.48-26.48V527.997H277.778c-15.341 0-27.778-12.437-27.778-27.778s12.437-27.778 27.778-27.778h194.444z" }), React__namespace.createElement("path", { d: "M500 888.889c214.777 0 388.889-174.112 388.889-388.889 0-214.777-174.112-388.889-388.889-388.889-214.777 0-388.889 174.112-388.889 388.889 0 214.777 174.112 388.889 388.889 388.889zm0 55.555C254.54 944.444 55.556 745.46 55.556 500S254.54 55.556 500 55.556 944.444 254.54 944.444 500 745.46 944.444 500 944.444z", fillRule: "nonzero" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgAddO" }, props, { ref }), React__namespace.createElement(SvgIcon$3L, null));
  });
  const SvgIcon$3K = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M472.222 472.222H277.778C262.437 472.222 250 484.66 250 500s12.437 27.778 27.778 27.778h194.444v194.444C472.222 737.563 484.66 750 500 750s27.778-12.437 27.778-27.778V527.778h194.444C737.563 527.778 750 515.34 750 500s-12.437-27.778-27.778-27.778H527.778V277.778C527.778 262.437 515.34 250 500 250s-27.778 12.437-27.778 27.778v194.444zm-305.555-361.11h666.666c30.683 0 55.556 24.872 55.556 55.555v666.666c0 30.683-24.873 55.556-55.556 55.556H166.667c-30.683 0-55.556-24.873-55.556-55.556V166.667c0-30.683 24.873-55.556 55.556-55.556z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgAddSquare" }, props, { ref }), React__namespace.createElement(SvgIcon$3K, null));
  });
  const SvgIcon$3J = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M694.667 527.778h-166.89v166.889c0 15.277-12.444 27.777-27.777 27.777s-27.778-12.5-27.778-27.777v-166.89H305.333c-15.277 0-27.777-12.444-27.777-27.777s12.5-27.778 27.777-27.778h166.89V305.333c0-15.277 12.444-27.777 27.777-27.777s27.778 12.5 27.778 27.777v166.89h166.889c15.277 0 27.777 12.444 27.777 27.777s-12.5 27.778-27.777 27.778M500 55.556c-245.444 0-444.444 199-444.444 444.444 0 245.444 199 444.444 444.444 444.444 245.444 0 444.444-199 444.444-444.444 0-245.444-199-444.444-444.444-444.444", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgAdd" }, props, { ref }), React__namespace.createElement(SvgIcon$3J, null));
  });
  const SvgIcon$3I = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M852.486 654.407l-50.595-22.947c-29.361 64.737-77.951 118.86-140.897 155.201C496.783 881.468 286.806 825.206 192 660.994 97.19 496.783 153.454 286.806 317.666 192 481.877 97.19 691.854 153.454 786.66 317.666l48.113-27.778C724.624 99.105 480.67 33.738 289.888 143.886 99.105 254.036 33.738 497.99 143.886 688.772c110.15 190.783 354.103 256.15 544.886 146.002 74.927-43.26 130.51-107.157 163.714-180.367zM688.772 834.774c74.927-43.26 130.51-107.157 163.714-180.367l-50.595-22.947c-29.361 64.737-77.951 118.86-140.897 155.201C496.783 881.468 286.806 825.206 192 660.994 97.19 496.783 153.454 286.806 317.666 192 481.877 97.19 691.854 153.454 786.66 317.666l48.113-27.778C724.624 99.105 480.67 33.738 289.888 143.886 99.105 254.036 33.738 497.99 143.886 688.772c110.15 190.783 354.103 256.15 544.886 146.002zm122.625-502.115c15.341 0 27.778-12.437 27.778-27.778s-12.437-27.778-27.778-27.778-27.778 12.437-27.778 27.778 12.437 27.778 27.778 27.778z", fillRule: "nonzero" }), React__namespace.createElement("path", { d: "M738.7 604.349l175.56 78.164a.25.25 0 00.341-.3l-42.747-140.23a.25.25 0 00-.345-.153l-132.813 62.064a.25.25 0 00.004.455z" }), React__namespace.createElement("path", { d: "M607.39 291.667c13.286 7.67 17.838 24.659 10.167 37.945l-46.341 80.264h60.882c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.778 27.778H520.987v55.555h111.111c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.778 27.778H520.987v111.111c0 15.341-12.436 27.778-27.777 27.778-15.342 0-27.778-12.437-27.778-27.778l-.001-111.111H354.32c-15.342 0-27.778-12.437-27.778-27.778s12.436-27.778 27.778-27.778h111.11v-55.555H354.32c-15.342 0-27.778-12.437-27.778-27.778s12.436-27.778 27.778-27.778h39.24l-46.339-80.264c-7.594-13.153-3.208-29.935 9.772-37.712l.396-.233c13.286-7.671 30.274-3.119 37.945 10.167l62.378 108.042h49.353l62.378-108.042c7.671-13.286 24.66-17.838 37.946-10.167z", fillRule: "nonzero" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgAfterSale" }, props, { ref }), React__namespace.createElement(SvgIcon$3I, null));
  });
  const SvgIcon$3H = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 55.556c245.444 0 444.444 199 444.444 444.444 0 245.444-199 444.444-444.444 444.444-245.444 0-444.444-199-444.444-444.444 0-245.444 199-444.444 444.444-444.444zm27.778 57V250c0 15.333-12.5 27.778-27.778 27.778-15.278 0-27.778-12.445-27.778-27.778V112.556C280 126.222 126.222 279.944 112.5 472.222H250c15.278 0 27.778 12.5 27.778 27.778 0 15.333-12.5 27.778-27.778 27.778H112.5C126.222 720.056 280 873.833 472.222 887.5V750c0-15.278 12.5-27.778 27.778-27.778 15.278 0 27.778 12.5 27.778 27.778v137.5C720 873.833 873.778 720.056 887.5 527.778H750c-15.278 0-27.778-12.445-27.778-27.778 0-15.278 12.5-27.778 27.778-27.778h137.5c-13.722-192.278-167.5-346-359.722-359.666zM500 444.466c30.667 0 55.556 24.834 55.556 55.556 0 30.722-24.89 55.556-55.556 55.556-30.667 0-55.556-24.834-55.556-55.556 0-30.722 24.89-55.555 55.556-55.555z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgAim" }, props, { ref }), React__namespace.createElement(SvgIcon$3H, null));
  });
  const SvgIcon$3G = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M764.447 111.111c68.444 0 124.442 56.114 124.442 124.695v403.696S864 636.383 752.003 598.977c-31.114-10.911-73.112-26.5-119.778-43.644 28-48.316 49.774-104.43 65.33-163.659h-154v-54.556H731.78v-31.173H543.556v-91.961h-76.223c-13.438 0-13.975 12.926-13.997 13.96v79.56H263.557v31.174h189.777v52.994H296.222v31.172h304.89c-10.89 38.969-26.443 74.816-43.554 107.549-98.001-32.733-203.782-59.226-270.67-42.082-42.001 10.908-70.002 29.613-85.556 48.318-73.11 88.843-20.222 224.448 133.779 224.448 91.777 0 180.443-51.435 248.887-135.605 100.615 48.88 296.842 130.696 304.65 133.949l.24.1v4.675c0 68.58-55.998 124.693-124.44 124.693H235.555c-68.445 0-124.445-56.113-124.445-124.693v-528.39c0-68.58 56-124.695 124.445-124.695zm-463.56 422.4c71.56-7.792 138.446 20.264 217.781 59.232-57.555 71.696-127.555 116.9-197.556 116.9-121.335 0-157.113-95.076-96.445-148.076 20.22-17.145 56.001-26.494 76.22-28.055z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgAlipay" }, props, { ref }), React__namespace.createElement(SvgIcon$3G, null));
  });
  const SvgIcon$3F = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M708.333 166.667c-69.035 0-125 55.964-125 125 0 69.035 55.965 125 125 125 69.036 0 125-55.965 125-125 0-69.036-55.964-125-125-125zm0-55.556c99.718 0 180.556 80.838 180.556 180.556 0 99.718-80.838 180.555-180.556 180.555-99.718 0-180.555-80.837-180.555-180.555S608.615 111.11 708.333 111.11zm-541.666 55.556v250h250v-250h-250zm0-55.556h250c30.682 0 55.555 24.873 55.555 55.556v250c0 30.682-24.873 55.555-55.555 55.555h-250c-30.683 0-55.556-24.873-55.556-55.555v-250c0-30.683 24.873-55.556 55.556-55.556zm0 472.222v250h250v-250h-250zm0-55.555h250c30.682 0 55.555 24.873 55.555 55.555v250c0 30.683-24.873 55.556-55.555 55.556h-250c-30.683 0-55.556-24.873-55.556-55.556v-250c0-30.682 24.873-55.555 55.556-55.555zm416.666 55.555v250h250v-250h-250zm0-55.555h250c30.683 0 55.556 24.873 55.556 55.555v250c0 30.683-24.873 55.556-55.556 55.556h-250c-30.682 0-55.555-24.873-55.555-55.556v-250c0-30.682 24.873-55.555 55.555-55.555z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgAppsO" }, props, { ref }), React__namespace.createElement(SvgIcon$3F, null));
  });
  const SvgIcon$3E = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M494.094 733.426a41.472 41.472 0 01-20.023-11.126L140.16 388.388c-16.272-16.271-16.272-42.653 0-58.925 16.271-16.272 42.653-16.272 58.925 0L503.66 634.037 808.186 329.51c16.271-16.272 42.653-16.272 58.925 0s16.272 42.654 0 58.926L533.2 722.347c-10.607 10.607-25.508 14.3-39.106 11.08z", fillRule: "evenodd" }));
  const SvgArrowDown = React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgArrowDown" }, props, { ref }), React__namespace.createElement(SvgIcon$3E, null));
  });
  const SvgIcon$3D = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M296.114 508.035c-3.22-13.597.473-28.499 11.079-39.105l333.912-333.912c16.271-16.272 42.653-16.272 58.925 0s16.272 42.654 0 58.926L395.504 498.47l304.574 304.574c16.272 16.272 16.272 42.654 0 58.926s-42.654 16.272-58.926 0L307.241 528.058a41.472 41.472 0 01-11.127-20.023z", fillRule: "evenodd" }));
  const SvgArrowLeft = React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgArrowLeft" }, props, { ref }), React__namespace.createElement(SvgIcon$3D, null));
  });
  const SvgIcon$3C = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M513.176 285.05a41.472 41.472 0 0120.024 11.127L867.11 630.089c16.272 16.271 16.272 42.653 0 58.925s-42.654 16.272-58.925 0L503.612 384.44 199.085 688.967c-16.272 16.271-42.654 16.271-58.925 0-16.272-16.272-16.272-42.654 0-58.926L474.07 296.129c10.606-10.606 25.508-14.299 39.105-11.078z", fillRule: "evenodd" }));
  const SvgArrowUp = React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgArrowUp" }, props, { ref }), React__namespace.createElement(SvgIcon$3C, null));
  });
  const SvgIcon$3B = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M711.156 508.035a41.472 41.472 0 01-11.126 20.023L366.12 861.97c-16.272 16.272-42.654 16.272-58.926 0s-16.272-42.654 0-58.926L611.767 498.47 307.241 193.944c-16.272-16.272-16.272-42.654 0-58.926 16.271-16.272 42.653-16.272 58.925 0L700.078 468.93c10.606 10.606 14.299 25.508 11.078 39.105z", fillRule: "evenodd" }));
  const SvgArrow = React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgArrow" }, props, { ref }), React__namespace.createElement(SvgIcon$3B, null));
  });
  const SvgIcon$3A = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M777.469 337.249l-65.754 65.753c-16.272 16.272-42.654 16.272-58.925 0-16.272-16.271-16.272-42.653 0-58.925l133.435-133.435c5.747-7.39 13.93-12.794 23.342-15.006 13.74-3.447 28.895.202 39.641 10.948 9.955 9.955 13.82 23.693 11.594 36.586v520.806c0 23.012-18.655 41.667-41.666 41.667-23.012 0-41.667-18.655-41.667-41.667V337.25zm-597.222-89.136h361.11c23.013 0 41.667 18.655 41.667 41.667s-18.654 41.667-41.666 41.667H180.247c-23.012 0-41.667-18.655-41.667-41.667s18.655-41.667 41.667-41.667zm0 222.223h361.11c23.013 0 41.667 18.654 41.667 41.666 0 23.012-18.654 41.667-41.666 41.667H180.247c-23.012 0-41.667-18.655-41.667-41.667s18.655-41.666 41.667-41.666zm0 222.222h361.11c23.013 0 41.667 18.655 41.667 41.666 0 23.012-18.654 41.667-41.666 41.667H180.247c-23.012 0-41.667-18.655-41.667-41.667 0-23.011 18.655-41.666 41.667-41.666z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgAscending" }, props, { ref }), React__namespace.createElement(SvgIcon$3A, null));
  });
  const SvgIcon$3z = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M111.111 500c0-214.777 174.112-388.889 388.889-388.889 214.777 0 388.889 174.112 388.889 388.889v277.778c0 30.682-24.873 55.555-55.556 55.555h-55.555c-30.683 0-55.556-24.873-55.556-55.555V555.556c0-30.683 24.873-55.556 55.556-55.556h55.555c0-184.095-149.238-333.333-333.333-333.333-184.095 0-333.333 149.238-333.333 333.333h55.555c30.683 0 55.556 24.873 55.556 55.556v222.222c0 30.682-24.873 55.555-55.556 55.555h-55.555c-30.683 0-55.556-24.873-55.556-55.555V500z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgAudio" }, props, { ref }), React__namespace.createElement(SvgIcon$3z, null));
  });
  const SvgIcon$3y = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "nonzero" }, React__namespace.createElement("path", { d: "M500 666.667c153.412 0 277.778-124.366 277.778-277.778 0-153.413-124.366-277.778-277.778-277.778-153.412 0-277.778 124.365-277.778 277.778 0 153.412 124.366 277.778 277.778 277.778zm0 55.555c-184.095 0-333.333-149.238-333.333-333.333 0-184.095 149.238-333.333 333.333-333.333 184.095 0 333.333 149.238 333.333 333.333 0 184.095-149.238 333.333-333.333 333.333z" }), React__namespace.createElement("path", { d: "M500 458.333c38.353 0 69.444-31.091 69.444-69.444s-31.09-69.445-69.444-69.445c-38.353 0-69.444 31.092-69.444 69.445 0 38.353 31.09 69.444 69.444 69.444zm0 55.556c-69.036 0-125-55.965-125-125 0-69.036 55.964-125 125-125s125 55.964 125 125c0 69.035-55.964 125-125 125zM388.889 860.577L500 813.511l111.111 47.066V702.358c-36.5 13.446-73.458 20.274-110.733 20.274-37.456 0-74.664-6.894-111.49-20.467v158.412zM333.333 611.45c55.922 37.084 111.603 55.626 167.045 55.626 55.441 0 110.87-18.542 166.289-55.626v291.06c0 15.342-12.437 27.779-27.778 27.779-3.723 0-7.407-.749-10.835-2.2L500 873.844l-128.054 54.243c-14.126 5.984-30.429-.617-36.413-14.743a27.778 27.778 0 01-2.2-10.834V611.45z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgAwardO" }, props, { ref }), React__namespace.createElement(SvgIcon$3y, null));
  });
  const SvgIcon$3x = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M666.667 761.111v162.157c0 15.341-12.437 27.778-27.778 27.778-3.723 0-7.407-.748-10.835-2.2L521.67 903.78a55.556 55.556 0 00-43.338 0l-106.385 45.065c-14.126 5.983-30.429-.617-36.413-14.743a27.778 27.778 0 01-2.2-10.835V761.111c50.515 23.997 107.023 37.424 166.667 37.424 59.644 0 116.152-13.427 166.667-37.424zM500 83.333c184.095 0 333.333 149.239 333.333 333.334S684.095 750 500 750c-184.095 0-333.333-149.238-333.333-333.333 0-184.095 149.238-333.334 333.333-333.334zm0 222.223c-61.365 0-111.111 49.746-111.111 111.11 0 61.366 49.746 111.112 111.111 111.112s111.111-49.746 111.111-111.111S561.365 305.556 500 305.556z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgAward" }, props, { ref }), React__namespace.createElement(SvgIcon$3x, null));
  });
  const SvgIcon$3w = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500.617 247.708c7.533-.345 15.179 2.358 20.931 8.11l275.124 275.124c10.853 10.853 10.853 28.45 0 39.303-10.854 10.853-28.45 10.853-39.304 0L528.292 341.168v506.415c0 15.35-12.443 27.792-27.792 27.792-15.349 0-27.792-12.443-27.792-27.792V341.168L243.632 570.245c-10.854 10.853-28.45 10.853-39.304 0-10.853-10.853-10.853-28.45 0-39.303l275.124-275.124c5.782-5.782 13.478-8.483 21.048-8.105zM778.417 125c15.349 0 27.791 12.443 27.791 27.792 0 15.349-12.442 27.791-27.791 27.791H222.583c-15.349 0-27.791-12.442-27.791-27.791 0-15.35 12.442-27.792 27.791-27.792h555.834z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgBackTop" }, props, { ref }), React__namespace.createElement(SvgIcon$3w, null));
  });
  const SvgIcon$3v = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M258.088 333.333L223.366 888.89H771.76l-34.722-555.556h-478.95zm236.499-166.666c-59.495 0-108.135 49.524-108.135 111.11h-55.555c0-92.047 73.286-166.666 163.69-166.666s163.69 74.62 163.69 166.667h95.433c19.966 0 36.49 15.524 37.735 35.45l36.941 591.05c1.303 20.84-14.536 38.79-35.376 40.093-.786.049-1.572.073-2.359.073H204.475c-20.88 0-37.808-16.927-37.808-37.808 0-.787.024-1.573.073-2.359l36.94-591.049c1.246-19.926 17.77-35.45 37.736-35.45h361.306c0-61.587-48.64-111.111-108.135-111.111z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgBagO" }, props, { ref }), React__namespace.createElement(SvgIcon$3v, null));
  });
  const SvgIcon$3u = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M333.333 277.778c0-92.048 73.287-166.667 163.69-166.667 90.405 0 163.691 74.62 163.691 166.667h95.433c19.966 0 36.49 15.524 37.735 35.45l36.94 591.05c1.303 20.84-14.535 38.79-35.376 40.093-.785.049-1.571.073-2.358.073H206.912c-20.881 0-37.809-16.927-37.809-37.808 0-.787.025-1.573.074-2.359l36.94-591.049c1.246-19.926 17.77-35.45 37.736-35.45h89.48zm55.556 0h216.27c0-61.587-48.64-111.111-108.135-111.111-59.495 0-108.135 49.524-108.135 111.11z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgBag" }, props, { ref }), React__namespace.createElement(SvgIcon$3u, null));
  });
  const SvgIcon$3t = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M222.222 111.111h555.556c30.682 0 55.555 24.873 55.555 55.556v250c0 15.34-12.436 27.777-27.777 27.777-15.342 0-27.778-12.436-27.778-27.777v-250H222.222v666.666h194.445c15.34 0 27.777 12.437 27.777 27.778s-12.436 27.778-27.777 27.778H222.222c-30.682 0-55.555-24.873-55.555-55.556V166.667c0-30.683 24.873-55.556 55.555-55.556z" }), React__namespace.createElement("path", { d: "M722.222 888.889c92.048 0 166.667-74.62 166.667-166.667s-74.62-166.666-166.667-166.666-166.666 74.619-166.666 166.666c0 92.048 74.619 166.667 166.666 166.667zm0 55.555C599.492 944.444 500 844.952 500 722.222S599.492 500 722.222 500s222.222 99.492 222.222 222.222-99.492 222.222-222.222 222.222z", fillRule: "nonzero" }), React__namespace.createElement("path", { d: "M781.746 724.635c13.143 0 23.81-10.667 23.81-23.81 0-13.142-10.667-23.81-23.81-23.81H763.46l25.238-25.237c9.334-9.334 9.334-24.381 0-33.667-9.285-9.333-24.333-9.333-33.666 0l-32.81 32.81-32.81-32.81c-9.333-9.333-24.38-9.333-33.666 0-9.333 9.286-9.333 24.333 0 33.667l25.238 25.238h-18.286c-13.142 0-23.81 10.667-23.81 23.81 0 13.142 10.668 23.809 23.81 23.809h35.715v23.81h-35.715c-13.142 0-23.81 10.666-23.81 23.809s10.668 23.81 23.81 23.81h35.715v23.809c0 13.143 10.666 23.81 23.81 23.81 13.142 0 23.809-10.667 23.809-23.81v-23.81h35.714c13.143 0 23.81-10.666 23.81-23.809s-10.667-23.81-23.81-23.81h-35.714v-23.81h35.714zM305.556 277.778h333.333c15.341 0 27.778 12.436 27.778 27.778 0 15.34-12.437 27.777-27.778 27.777H305.556c-15.342 0-27.778-12.436-27.778-27.777 0-15.342 12.436-27.778 27.778-27.778zM305.556 388.889h222.222c15.341 0 27.778 12.436 27.778 27.778 0 15.34-12.437 27.777-27.778 27.777H305.556c-15.342 0-27.778-12.436-27.778-27.777 0-15.342 12.436-27.778 27.778-27.778zM305.556 500h111.11c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.777 27.778H305.556c-15.342 0-27.778-12.437-27.778-27.778S290.214 500 305.556 500z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgBalanceListO" }, props, { ref }), React__namespace.createElement(SvgIcon$3t, null));
  });
  const SvgIcon$3s = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M722.222 555.578c92.056 0 166.667 74.555 166.667 166.666 0 92.056-74.611 166.667-166.667 166.667-92.055 0-166.666-74.611-166.666-166.667 0-92.11 74.61-166.666 166.666-166.666zm55.556-444.467c30.722 0 55.555 24.833 55.555 55.556v364.166C800.5 511.723 762.89 500 722.223 500 599.5 500 500 599.5 500 722.222c0 66.722 30.056 125.945 76.667 166.667H222.222c-30.722 0-55.555-24.833-55.555-55.556V166.667c0-30.723 24.833-55.556 55.555-55.556zm8.278 519.522c-8.112-8.11-21.278-8.11-29.445 0l-34.389 34.334-34.389-34.334c-8.166-8.11-21.333-8.11-29.444 0-8.167 8.167-8.167 21.334 0 29.445l26.5 26.5h-25.167c-11.5 0-20.833 9.333-20.833 20.833 0 11.5 9.333 20.833 20.833 20.833h41.667v27.778h-41.667c-11.5 0-20.833 9.334-20.833 20.834s9.333 20.833 20.833 20.833h41.667V821.3c0 11.5 9.333 20.833 20.833 20.833 11.5 0 20.834-9.333 20.834-20.833v-23.611h41.666c11.5 0 20.834-9.333 20.834-20.833 0-11.5-9.334-20.834-20.834-20.834h-41.666v-27.778h41.666c11.5 0 20.834-9.333 20.834-20.833 0-11.5-9.334-20.833-20.834-20.833h-25.166l26.5-26.5c8.166-8.111 8.166-21.278 0-29.445zM416.666 500h-111.11c-15.334 0-27.778 12.444-27.778 27.778 0 15.333 12.444 27.778 27.778 27.778h111.11c15.334 0 27.778-12.445 27.778-27.778C444.444 512.444 432 500 416.667 500zm111.112-111.111H305.556c-15.334 0-27.778 12.444-27.778 27.778 0 15.333 12.444 27.777 27.778 27.777h222.222c15.333 0 27.778-12.444 27.778-27.777 0-15.334-12.445-27.778-27.778-27.778zm111.11-111.111H305.557c-15.334 0-27.778 12.444-27.778 27.778 0 15.333 12.444 27.777 27.778 27.777h333.333c15.333 0 27.778-12.444 27.778-27.777 0-15.334-12.445-27.778-27.778-27.778z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgBalanceList" }, props, { ref }), React__namespace.createElement(SvgIcon$3s, null));
  });
  const SvgIcon$3r = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M771.735 831.444c-30.944 36.5-76.055 57.445-123.889 57.445H384.68c-47.834 0-93-20.945-123.89-57.445-30.944-36.5-44.166-84.5-36.332-131.666l23.11-138.834c22-131.888 135-227.61 268.667-227.61 133.723 0 246.723 95.722 268.667 227.61l23.111 138.834c7.889 47.166-5.333 95.166-36.278 131.666zm-289.11-553.666c-55.223 0-103.223-40.334-114.223-95.89-1.056-5.5 1.278-9.277 2.722-11.11 1.556-1.89 4.278-4.111 8.39-4.111h273.444c4.166 0 6.833 2.222 8.444 4.11 1.444 1.834 3.778 5.612 2.722 11.112-11 55.555-59 95.889-114.222 95.889h-67.278zM862.845 690.61l-23.11-138.833C820.79 438.167 744.345 347.11 643.512 304.5c37.667-25.056 65.722-64.389 75.111-111.889 8.222-42.167-23.444-81.5-65.666-81.5H379.513c-42.167 0-73.889 39.333-65.611 81.5 9.389 47.5 37.444 86.833 75.056 111.889-100.723 42.611-177.223 133.667-196.167 247.278L169.68 690.61c-22.111 132.833 80.278 253.833 215 253.833h263.166c134.667 0 237.112-121 215-253.833zM585.702 638.9c15.333 0 27.778-12.444 27.778-27.778 0-15.333-12.445-27.778-27.778-27.778h-21.333l29.444-29.444c10.889-10.889 10.889-28.444 0-39.278-10.833-10.889-28.389-10.889-39.278 0L516.258 552.9l-38.278-38.278c-10.89-10.889-28.445-10.889-39.278 0-10.889 10.834-10.889 28.39 0 39.278l29.444 29.444h-21.333c-15.333 0-27.778 12.445-27.778 27.778 0 15.334 12.445 27.778 27.778 27.778h41.667v27.778h-41.667c-15.333 0-27.778 12.444-27.778 27.778 0 15.333 12.445 27.777 27.778 27.777h41.667v27.778c0 15.333 12.444 27.778 27.778 27.778 15.333 0 27.777-12.445 27.777-27.778v-27.778h41.667c15.333 0 27.778-12.444 27.778-27.777 0-15.334-12.445-27.778-27.778-27.778h-41.667V638.9h41.667z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgBalanceO" }, props, { ref }), React__namespace.createElement(SvgIcon$3r, null));
  });
  const SvgIcon$3q = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M752.278 111.111c12.278 0 23.5 8.222 26.778 20.611l37.5 139.834h22.555c27.5 0 49.778 22.277 49.778 49.777V832.89c0 27.5-22.278 49.778-49.778 49.778H160.89c-27.5 0-49.778-22.278-49.778-49.778V321.333c0-24.889 18.556-44.555 42.389-48.333l153.611-153.611c4.111-4.111 9.389-6.111 14.778-6.111 5.333 0 10.611 2 14.722 6.11.167.223.111.5.222.668.223.166.556.11.723.277l79.61 79.611 327.89-87.888c2.388-.612 4.833-.945 7.222-.945zm81.055 216H166.667v500h666.666v-500zM732.667 172.944l-368.111 98.612h394.5l-26.39-98.612zm-410.778-9.333l-84.611 84.5 133.389-35.667-48.778-48.833zm236.055 277.811a27.9 27.9 0 00-19.666 8.111L500 487.867l-38.278-38.334a27.9 27.9 0 00-19.666-8.11c-7.112 0-14.223 2.721-19.612 8.11-10.888 10.89-10.888 28.445 0 39.334l29.445 29.5h-21.333c-15.334 0-27.778 12.389-27.778 27.777 0 15.278 12.444 27.778 27.778 27.778h41.666V601.7h-41.666c-15.334 0-27.778 12.389-27.778 27.778 0 15.278 12.444 27.778 27.778 27.778h41.666v27.777c0 15.278 12.445 27.778 27.778 27.778 15.333 0 27.778-12.5 27.778-27.778v-27.777h41.666c15.334 0 27.778-12.5 27.778-27.778 0-15.39-12.444-27.778-27.778-27.778h-41.666v-27.778h41.666c15.334 0 27.778-12.5 27.778-27.778 0-15.388-12.444-27.777-27.778-27.777h-21.333l29.5-29.5c10.833-10.89 10.833-28.445 0-39.334a27.9 27.9 0 00-19.667-8.11", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgBalancePay" }, props, { ref }), React__namespace.createElement(SvgIcon$3q, null));
  });
  const SvgIcon$3p = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M166.556 430.334v416.668h111.111V430.334H166.556zm0-55.555h111.111c30.683 0 55.556 24.873 55.556 55.555v416.668c0 30.683-24.873 55.556-55.556 55.556H166.556c-30.683 0-55.556-24.873-55.556-55.556V430.334c0-30.682 24.873-55.555 55.556-55.555zm277.778-55.556v527.78h111.112v-527.78H444.334zm0-55.556h111.112c30.682 0 55.555 24.873 55.555 55.556v527.78c0 30.682-24.873 55.555-55.555 55.555H444.334c-30.682 0-55.555-24.873-55.555-55.556v-527.78c0-30.682 24.873-55.555 55.555-55.555zm277.779-111.111v694.446h111.111V152.556H722.113zm0-55.556h111.111c30.683 0 55.556 24.873 55.556 55.556v694.446c0 30.683-24.873 55.556-55.556 55.556H722.113c-30.683 0-55.556-24.873-55.556-55.556V152.556c0-30.683 24.873-55.556 55.556-55.556z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgBarChartO" }, props, { ref }), React__namespace.createElement(SvgIcon$3p, null));
  });
  const SvgIcon$3o = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M194.444 277.778c-30.682 0-55.555-24.873-55.555-55.556 0-30.682 24.873-55.555 55.555-55.555 30.683 0 55.556 24.873 55.556 55.555 0 30.683-24.873 55.556-55.556 55.556zm152.778-97.222h472.222c23.012 0 41.667 18.654 41.667 41.666 0 23.012-18.655 41.667-41.667 41.667H347.222c-23.012 0-41.666-18.655-41.666-41.667s18.654-41.666 41.666-41.666zm0 277.777h472.222c23.012 0 41.667 18.655 41.667 41.667s-18.655 41.667-41.667 41.667H347.222c-23.012 0-41.666-18.655-41.666-41.667s18.654-41.667 41.666-41.667zm0 277.778h472.222c23.012 0 41.667 18.655 41.667 41.667s-18.655 41.666-41.667 41.666H347.222c-23.012 0-41.666-18.654-41.666-41.666 0-23.012 18.654-41.667 41.666-41.667zM194.444 555.556c-30.682 0-55.555-24.874-55.555-55.556s24.873-55.556 55.555-55.556C225.127 444.444 250 469.318 250 500s-24.873 55.556-55.556 55.556zm0 277.777c-30.682 0-55.555-24.873-55.555-55.555 0-30.683 24.873-55.556 55.555-55.556 30.683 0 55.556 24.873 55.556 55.556 0 30.682-24.873 55.555-55.556 55.555z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgBars" }, props, { ref }), React__namespace.createElement(SvgIcon$3o, null));
  });
  const SvgIcon$3n = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M583.333 861.111c0 46.024-37.31 83.333-83.333 83.333-46.024 0-83.333-37.31-83.333-83.333h166.666zm-83.333-750c15.341 0 27.778 12.437 27.778 27.778l.001 28.919C698.877 181.924 833.333 325.26 833.333 500v277.777h83.334c15.34 0 27.777 12.437 27.777 27.779 0 15.34-12.436 27.777-27.777 27.777H83.333c-15.34 0-27.777-12.436-27.777-27.777 0-15.342 12.436-27.778 27.777-27.778h83.334V500c0-174.74 134.457-318.077 305.555-332.192v-28.92c0-15.34 12.437-27.777 27.778-27.777z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgBell" }, props, { ref }), React__namespace.createElement(SvgIcon$3n, null));
  });
  const SvgIcon$3m = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M388.889 111.111v55.556H611.11V111.11H388.89zm388.889 55.556H666.667c0 30.682-24.873 55.555-55.556 55.555H388.89c-30.683 0-55.556-24.873-55.556-55.555h-111.11v722.222h555.555V166.667zm55.555 0v722.222c0 30.682-24.873 55.555-55.555 55.555H222.222c-30.682 0-55.555-24.873-55.555-55.555V166.667c0-30.683 24.873-55.556 55.555-55.556h111.111c0-30.682 24.873-55.555 55.556-55.555H611.11c30.683 0 55.556 24.873 55.556 55.555h111.11c30.683 0 55.556 24.873 55.556 55.556z", fillRule: "nonzero" }), React__namespace.createElement("path", { d: "M500.494 443.253l38.79-38.79c10.848-10.848 28.436-10.848 39.283 0 10.848 10.848 10.848 28.436 0 39.283l-28.475 28.476h19.352c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.778 27.778h-41.666v27.778h41.666c15.342 0 27.778 12.436 27.778 27.777 0 15.342-12.436 27.778-27.778 27.778h-41.666v27.778c0 15.341-12.437 27.778-27.778 27.778s-27.778-12.437-27.778-27.778V611.11h-41.666c-15.342 0-27.778-12.436-27.778-27.778 0-15.34 12.436-27.777 27.778-27.777h41.666v-27.778h-41.666c-15.342 0-27.778-12.437-27.778-27.778s12.436-27.778 27.778-27.778h20.34l-28.476-28.476c-10.848-10.847-10.848-28.435 0-39.283 10.848-10.848 28.435-10.848 39.283 0l38.79 38.79z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgBillO" }, props, { ref }), React__namespace.createElement(SvgIcon$3m, null));
  });
  const SvgIcon$3l = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M500.494 444.24l.213.213a28.29 28.29 0 00-.42-.007l.207-.206zm0-.987l-38.79-38.79c-10.849-10.848-28.436-10.848-39.284 0-10.848 10.848-10.848 28.436 0 39.283l28.475 28.476h-20.34c-15.34 0-27.777 12.437-27.777 27.778s12.436 27.778 27.778 27.778h41.666v27.778h-41.666c-15.342 0-27.778 12.436-27.778 27.777 0 15.342 12.436 27.778 27.778 27.778h41.666v27.778c0 15.341 12.437 27.778 27.778 27.778s27.778-12.437 27.778-27.778V611.11h41.666c15.342 0 27.778-12.436 27.778-27.778 0-15.34-12.436-27.777-27.778-27.777h-41.666v-27.778h41.666c15.342 0 27.778-12.437 27.778-27.778s-12.436-27.778-27.778-27.778h-19.352l28.475-28.476c10.848-10.847 10.848-28.435 0-39.283-10.847-10.848-28.435-10.848-39.283 0l-38.79 38.79zm27.275 28.262l.707.707h-.698c0-.236-.003-.472-.009-.707zM333.333 111.111v55.556c0 30.682 24.873 55.555 55.556 55.555H611.11c30.683 0 55.556-24.873 55.556-55.555V111.11h111.11c30.683 0 55.556 24.873 55.556 55.556v722.222c0 30.682-24.873 55.555-55.555 55.555H222.222c-30.682 0-55.555-24.873-55.555-55.555V166.667c0-30.683 24.873-55.556 55.555-55.556h111.111z" }), React__namespace.createElement("path", { d: "M416.667 111.111h166.666c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.778 27.778H416.667c-15.342 0-27.778-12.437-27.778-27.778s12.436-27.778 27.778-27.778z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgBill" }, props, { ref }), React__namespace.createElement(SvgIcon$3l, null));
  });
  const SvgIcon$3k = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M166.667 555.556v277.777h666.666V555.556H166.667zm0-55.556h666.666c30.683 0 55.556 24.873 55.556 55.556v277.777c0 30.683-24.873 55.556-55.556 55.556H166.667c-30.683 0-55.556-24.873-55.556-55.556V555.556c0-30.683 24.873-55.556 55.556-55.556z", fillRule: "nonzero" }), React__namespace.createElement("path", { d: "M277.778 388.889V500h444.444V388.889H277.778zm0-55.556h444.444c30.683 0 55.556 24.873 55.556 55.556V500c0 30.682-24.873 55.556-55.556 55.556H277.778c-30.683 0-55.556-24.874-55.556-55.556V388.889c0-30.683 24.873-55.556 55.556-55.556z", fillRule: "nonzero" }), React__namespace.createElement("path", { d: "M500 222.222c15.341 0 27.778 12.437 27.778 27.778v111.111c0 15.341-12.437 27.778-27.778 27.778s-27.778-12.437-27.778-27.778V250c0-15.341 12.437-27.778 27.778-27.778zm29.111-89.797c0 30.176-15.225 54.648-34 54.648s-34-24.472-34-54.648c0-30.176 15.225-54.647 34-54.647s34 24.471 34 54.647zM250 666.667h500c15.341 0 27.778 12.436 27.778 27.777 0 15.342-12.437 27.778-27.778 27.778H250c-15.341 0-27.778-12.436-27.778-27.778 0-15.34 12.437-27.777 27.778-27.777z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgBirthdayCakeO" }, props, { ref }), React__namespace.createElement(SvgIcon$3k, null));
  });
  const SvgIcon$3j = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "nonzero" }, React__namespace.createElement("path", { d: "M222.222 111.111V887.31l207.715-169.132c40.866-33.275 99.485-33.266 140.34.021l207.5 169.064V111.111H222.223zm0-55.555h555.556c30.682 0 55.555 24.873 55.555 55.555v776.152c0 30.683-24.873 55.556-55.555 55.556a55.556 55.556 0 01-35.092-12.486l-207.5-169.064c-20.428-16.644-49.737-16.648-70.17-.01L257.3 930.39c-23.793 19.373-58.786 15.79-78.16-8.002a55.556 55.556 0 01-12.474-35.078V111.11c0-30.682 24.873-55.555 55.555-55.555z" }), React__namespace.createElement("path", { d: "M638.889 361.111c15.341 0 27.778 12.437 27.778 27.778 0 91.127-73.135 165.172-163.91 166.644l-2.757.023c-91.88 0-166.395-74.348-166.666-166.164v-.503c0-15.341 12.436-27.778 27.777-27.778 15.341 0 27.778 12.437 27.778 27.778C388.889 450.254 438.635 500 500 500s111.111-49.746 111.111-111.111l.004-.46c.245-15.129 12.586-27.318 27.774-27.318z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgBookmarkO" }, props, { ref }), React__namespace.createElement(SvgIcon$3j, null));
  });
  const SvgIcon$3i = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M333.333 388.889c0 92.047 74.62 166.667 166.667 166.667s166.667-74.62 166.667-166.667c0-15.341-12.437-27.778-27.778-27.778s-27.778 12.437-27.778 27.778C611.111 450.254 561.365 500 500 500s-111.111-49.746-111.111-111.111c0-15.341-12.437-27.778-27.778-27.778s-27.778 12.437-27.778 27.778zM222.223 55.556h555.555c30.682 0 55.555 24.873 55.555 55.555v776.152c0 30.683-24.873 55.556-55.555 55.556a55.556 55.556 0 01-35.092-12.486l-207.5-169.064c-20.428-16.644-49.737-16.648-70.17-.01L257.3 930.39c-23.793 19.373-58.786 15.79-78.16-8.002a55.556 55.556 0 01-12.474-35.078V111.11c0-30.682 24.873-55.555 55.555-55.555z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgBookmark" }, props, { ref }), React__namespace.createElement(SvgIcon$3i, null));
  });
  const SvgIcon$3h = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M500 888.889c214.777 0 388.889-174.112 388.889-388.889 0-214.777-174.112-388.889-388.889-388.889-214.777 0-388.889 174.112-388.889 388.889 0 214.777 174.112 388.889 388.889 388.889zm0 55.555C254.54 944.444 55.556 745.46 55.556 500S254.54 55.556 500 55.556 944.444 254.54 944.444 500 745.46 944.444 500 944.444z", fillRule: "nonzero" }), React__namespace.createElement("path", { d: "M500.002 333.333c187.471 0 277.776 158.9 277.776 166.667 0 7.776-87.892 166.667-277.776 166.667-189.887 0-277.78-158.89-277.78-166.667 0-7.768 90.305-166.667 277.78-166.667zm0 55.556c-67.851 0-125.167 24.714-172.386 66.478-16.227 14.352-30.182 29.878-41.188 44.895 10.763 14.894 24.442 30.27 40.418 44.494 46.805 41.67 104.243 66.355 173.156 66.355 68.912 0 126.349-24.685 173.152-66.355 15.977-14.224 29.655-29.6 40.418-44.494-11.006-15.017-24.96-30.543-41.187-44.895-47.219-41.764-104.533-66.478-172.383-66.478zM500 444.444c30.682 0 55.556 24.874 55.556 55.556S530.682 555.556 500 555.556 444.444 530.682 444.444 500s24.874-55.556 55.556-55.556z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgBrowsingHistoryO" }, props, { ref }), React__namespace.createElement(SvgIcon$3h, null));
  });
  const SvgIcon$3g = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 55.556c245.46 0 444.444 198.984 444.444 444.444S745.46 944.444 500 944.444 55.556 745.46 55.556 500 254.54 55.556 500 55.556zm.002 277.777c-187.475 0-277.78 158.9-277.78 166.667 0 7.776 87.893 166.667 277.78 166.667 189.884 0 277.776-158.89 277.776-166.667 0-7.768-90.305-166.667-277.776-166.667zm0 55.556c61.362 0 111.11 49.743 111.11 111.11 0 61.365-49.748 111.112-111.11 111.112-61.366 0-111.113-49.747-111.113-111.112 0-61.367 49.747-111.11 111.113-111.11zm0 55.555c-30.687 0-55.558 24.874-55.558 55.554 0 30.686 24.87 55.557 55.558 55.557 30.68 0 55.554-24.87 55.554-55.557 0-30.68-24.874-55.554-55.554-55.554z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgBrowsingHistory" }, props, { ref }), React__namespace.createElement(SvgIcon$3g, null));
  });
  const SvgIcon$3f = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M777.778 55.556c37.037 0 55.555 18.518 55.555 55.555V500c0 55.556-194.444 27.778-222.222 83.333-27.778 55.556 0 194.445 0 222.223 0 27.777 0 138.888-111.111 138.888s-111.111-111.11-111.111-138.888c0-27.778 27.778-166.667 0-222.223C361.11 527.778 166.667 555.556 166.667 500V111.111c0-37.037 18.518-55.555 55.555-55.555h555.556zm0 222.222H222.222v200.19c10.722 2.676 25.81 5.074 52.482 8.63 6.01.8 6.01.8 12.15 1.625 91.504 12.353 128.37 23.555 151.725 70.265 16.202 32.404 20.195 74.58 17.459 129.643-1.017 20.472-2.926 41.387-5.787 66.18-.414 3.59-1.196 10.113-1.98 16.613l-.176 1.46c-.978 8.1-1.915 15.817-2.097 17.373-1.06 9.071-1.554 14.543-1.554 15.799 0 56.04 12.131 83.333 55.556 83.333 29.684 0 41.82-10.195 49.474-34.007 4.727-14.707 6.082-29.189 6.082-49.326 0-1.256-.494-6.728-1.554-15.799-.338-2.895-3.29-27.1-4.253-35.447-2.86-24.792-4.77-45.707-5.787-66.179-2.736-55.063 1.257-97.239 17.459-129.643 23.355-46.71 60.221-57.912 151.725-70.265l5.732-.77.783-.104 5.635-.75c26.671-3.557 41.76-5.955 52.482-8.631v-200.19zm0-166.667H222.222v111.111h555.556v-111.11z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgBrushO" }, props, { ref }), React__namespace.createElement(SvgIcon$3f, null));
  });
  const SvgIcon$3e = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M663.292 652.776V522.659c0-72.412-78.788-147.661-166.666-147.661-87.88 0-166.667 75.25-166.667 147.661v130.117h333.333zm55.556-130.117v185.672H274.403V522.66c0-99.167 99.493-203.217 222.223-203.217 122.73 0 222.222 104.05 222.222 203.217zM496.626 97.22c15.34 0 27.777 12.437 27.777 27.778v55.555c0 15.342-12.436 27.778-27.777 27.778-15.342 0-27.778-12.436-27.778-27.778v-55.555c0-15.341 12.436-27.778 27.778-27.778zm166.666 55.556c13.286 7.67 17.838 24.659 10.168 37.945l-27.778 48.112c-7.67 13.286-24.66 17.838-37.945 10.168-13.286-7.671-17.838-24.66-10.168-37.946l27.778-48.112c7.67-13.286 24.66-17.838 37.945-10.167zm134.123 111.11c10.848 10.849 10.848 28.436 0 39.284l-39.284 39.284c-10.847 10.848-28.435 10.848-39.283 0-10.848-10.848-10.848-28.436 0-39.284l39.283-39.283c10.848-10.848 28.436-10.848 39.284 0zM218.848 874.999c0-15.341 12.436-27.778 27.778-27.778h500c15.34 0 27.777 12.437 27.777 27.778s-12.436 27.778-27.777 27.778h-500c-15.342 0-27.778-12.437-27.778-27.778zm103.668-722.222c13.286-7.671 30.274-3.119 37.945 10.167l27.778 48.112c7.67 13.286 3.118 30.275-10.168 37.946-13.286 7.67-30.274 3.118-37.945-10.168l-27.778-48.112c-7.67-13.286-3.118-30.275 10.168-37.945zm-119.94 111.11c10.848-10.847 28.436-10.847 39.284 0l39.283 39.284c10.848 10.848 10.848 28.436 0 39.284-10.848 10.848-28.435 10.848-39.283 0l-39.284-39.284c-10.848-10.848-10.848-28.435 0-39.283z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgBulbO" }, props, { ref }), React__namespace.createElement(SvgIcon$3e, null));
  });
  const SvgIcon$3d = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "nonzero" }, React__namespace.createElement("path", { d: "M777.778 151.288l-318.58 182.045H222.222v333.334h236.976l318.58 182.045V151.288zm55.555 0v697.424c0 30.683-24.873 55.556-55.555 55.556a55.556 55.556 0 01-27.563-7.32l-305.77-174.726H222.221c-30.682 0-55.555-24.873-55.555-55.555V333.333c0-30.682 24.873-55.555 55.555-55.555h222.222l305.77-174.726c26.64-15.223 60.577-5.967 75.8 20.672a55.556 55.556 0 017.32 27.564z" }), React__namespace.createElement("path", { d: "M378.878 888.889h53.355L398.9 722.222h-53.355l33.333 166.667zM500 277.778v444.444h-44.445l31.155 155.772c6.017 30.086-13.495 59.354-43.582 65.372a55.556 55.556 0 01-10.895 1.078h-53.355c-26.482 0-49.283-18.692-54.477-44.66l-46.623-233.117h166.666v-388.89H500z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgBullhornO" }, props, { ref }), React__namespace.createElement(SvgIcon$3d, null));
  });
  const SvgIcon$3c = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M166.667 222.222v611.111h666.666v-611.11H166.667zm527.777-111.11c15.342 0 27.778 12.436 27.778 27.777v27.778h111.111c30.683 0 55.556 24.873 55.556 55.555v611.111c0 30.683-24.873 55.556-55.556 55.556H166.667c-30.683 0-55.556-24.873-55.556-55.556v-611.11c0-30.683 24.873-55.556 55.556-55.556h111.11v-27.778c0-15.341 12.437-27.778 27.779-27.778 15.34 0 27.777 12.437 27.777 27.778v27.778h333.334v-27.778c0-15.341 12.436-27.778 27.777-27.778zm-83.766 366.035H394.012V589.37c-.556 47.222-8.334 86.11-23.334 116.666l22.223 20c19.444-35.555 29.444-81.944 30-138.889v-83.333H581.79v185c0 6.111-3.334 9.445-10 9.445-10.556 0-21.667-.556-33.612-1.39l7.5 27.778h34.723c20 0 30.277-8.61 30.277-25.555V477.147zm-50.555 134.445H441.512v73.611h118.61v-73.611zm-27.778 24.167v24.444H469.29v-24.444h63.055zm-15.833-126.112h-28.056v17.778h-46.944v23.89h46.944v20.555h-54.444v25H570.4v-25h-53.89v-20.556h45.556v-23.889h-45.555v-17.778zm316.821-176.314H166.667v55.556h666.666v-55.556zm-500-111.11h-55.555V250c0 15.341 12.436 27.778 27.778 27.778 15.34 0 27.777-12.437 27.777-27.778v-27.778zm388.89 0h-55.556V250c0 15.341 12.436 27.778 27.777 27.778 15.342 0 27.778-12.437 27.778-27.778v-27.778z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgCalendarO" }, props, { ref }), React__namespace.createElement(SvgIcon$3c, null));
  });
  const SvgIcon$3b = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M555.278 639.333c0 15.334 12.444 27.778 27.778 27.778h166.666c15.334 0 27.778-12.444 27.778-27.778 0-15.333-12.444-27.777-27.778-27.777H583.056c-15.334 0-27.778 12.444-27.778 27.777zm-499.722-306h888.888v444.445c0 30.722-24.833 55.555-55.555 55.555H111.11c-30.667 0-55.555-24.833-55.555-55.555V333.333zm888.888-111.11v55.555H55.556v-55.556c0-30.666 24.888-55.555 55.555-55.555H888.89c30.722 0 55.555 24.889 55.555 55.555z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgCard" }, props, { ref }), React__namespace.createElement(SvgIcon$3b, null));
  });
  const SvgIcon$3a = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { transform: "translate(55 55)", fillRule: "nonzero" }, React__namespace.createElement("path", { d: "M445 833.889c214.777 0 388.889-174.112 388.889-388.889 0-214.777-174.112-388.889-388.889-388.889C230.223 56.111 56.111 230.223 56.111 445c0 214.777 174.112 388.889 388.889 388.889zm0 55.555C199.54 889.444.556 690.46.556 445S199.54.556 445 .556 889.444 199.54 889.444 445 690.46 889.444 445 889.444z" }), React__namespace.createElement("path", { d: "M223.131 222.79c30.679 0 55.55 24.866 55.556 55.544h413.767c15.34 0 27.777 12.436 27.777 27.777 0 2.889-.45 5.76-1.335 8.51l-53.64 166.667a27.778 27.778 0 01-26.443 19.268H278.687v55.747h360.875c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.778 27.778H278.687c-30.683 0-55.556-24.873-55.556-55.556v-55.748h-.353v-222.21h-27.425c-15.34 0-27.777-12.437-27.777-27.778s12.436-27.778 27.777-27.778h27.778zm431.202 111.099H278.687v111.11l339.885.001 35.76-111.111z" }), React__namespace.createElement("circle", { cx: 278.333, cy: 667.222, r: 27.778 }), React__namespace.createElement("circle", { cx: 611.667, cy: 667.222, r: 27.778 })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgCartCircleO" }, props, { ref }), React__namespace.createElement(SvgIcon$3a, null));
  });
  const SvgIcon$39 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { transform: "translate(55 55)", fillRule: "nonzero" }, React__namespace.createElement("path", { d: "M445 833.889c214.777 0 388.889-174.112 388.889-388.889 0-214.777-174.112-388.889-388.889-388.889C230.223 56.111 56.111 230.223 56.111 445c0 214.777 174.112 388.889 388.889 388.889zm0 55.555C199.54 889.444.556 690.46.556 445S199.54.556 445 .556 889.444 199.54 889.444 445 690.46 889.444 445 889.444z" }), React__namespace.createElement("path", { d: "M222.778 278.333h469.676c15.34 0 27.777 12.437 27.777 27.778 0 2.889-.45 5.76-1.335 8.51l-53.64 166.667a27.778 27.778 0 01-26.443 19.268H222.778V278.333z" }), React__namespace.createElement("circle", { cx: 278.333, cy: 667.222, r: 27.778 }), React__namespace.createElement("circle", { cx: 611.667, cy: 667.222, r: 27.778 }), React__namespace.createElement("path", { d: "M195.353 278.345c-15.34 0-27.777-12.437-27.777-27.778s12.436-27.778 27.777-27.778h27.778c30.683 0 55.556 24.873 55.556 55.556v277.958h360.875c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.778 27.778H278.687c-30.683 0-55.556-24.873-55.556-55.556V278.345h-27.778z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgCartCircle" }, props, { ref }), React__namespace.createElement(SvgIcon$39, null));
  });
  const SvgIcon$38 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { transform: "translate(0 111.111)", fillRule: "evenodd" }, React__namespace.createElement("circle", { cx: 333.333, cy: 722.222, r: 55.556 }), React__namespace.createElement("circle", { cx: 722.222, cy: 722.222, r: 55.556 }), React__namespace.createElement("path", { d: "M226.922 167.013l41.762 364.206c1.609 14.025 13.48 24.613 27.597 24.613h488.921c13.443 0 24.956-9.625 27.339-22.855l60.01-333.263c2.718-15.099-7.318-29.543-22.416-32.261a27.778 27.778 0 00-4.923-.44h-618.29zm-6.37-55.556h624.66c4.952 0 9.895.442 14.768 1.32 45.296 8.156 75.403 51.487 67.247 96.782l-60.01 333.264c-7.147 39.689-41.687 68.565-82.015 68.565h-488.92c-42.351 0-77.967-31.765-82.792-73.84L161.054 80.255c-1.608-14.025-13.48-24.613-27.597-24.613H55.556c-15.342 0-27.778-12.437-27.778-27.778S40.214.086 55.556.086h77.901c42.351 0 77.967 31.765 82.791 73.84l4.304 37.531z", fillRule: "nonzero" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgCartO" }, props, { ref }), React__namespace.createElement(SvgIcon$38, null));
  });
  const SvgIcon$37 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { transform: "translate(0 111.111)", fillRule: "evenodd" }, React__namespace.createElement("circle", { cx: 333.333, cy: 722.222, r: 55.556 }), React__namespace.createElement("circle", { cx: 722.222, cy: 722.222, r: 55.556 }), React__namespace.createElement("path", { d: "M220.552 111.457h624.66c4.952 0 9.895.442 14.768 1.32 45.296 8.156 75.403 51.487 67.247 96.782l-60.01 333.264c-7.147 39.689-41.687 68.565-82.015 68.565h-488.92c-42.351 0-77.967-31.765-82.792-73.84L161.054 80.255c-1.608-14.025-13.48-24.613-27.597-24.613H55.556c-15.342 0-27.778-12.437-27.778-27.778S40.214.086 55.556.086h77.901c42.351 0 77.967 31.765 82.791 73.84l4.304 37.531z", fillRule: "nonzero" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgCart" }, props, { ref }), React__namespace.createElement(SvgIcon$37, null));
  });
  const SvgIcon$36 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M852.486 654.407l-50.595-22.947c-29.361 64.737-77.951 118.86-140.897 155.201C496.783 881.468 286.806 825.206 192 660.994 97.19 496.783 153.454 286.806 317.666 192 481.877 97.19 691.854 153.454 786.66 317.666l48.113-27.778C724.624 99.105 480.67 33.738 289.888 143.886 99.105 254.036 33.738 497.99 143.886 688.772c110.15 190.783 354.103 256.15 544.886 146.002 74.927-43.26 130.51-107.157 163.714-180.367zM688.772 834.774c74.927-43.26 130.51-107.157 163.714-180.367l-50.595-22.947c-29.361 64.737-77.951 118.86-140.897 155.201C496.783 881.468 286.806 825.206 192 660.994 97.19 496.783 153.454 286.806 317.666 192 481.877 97.19 691.854 153.454 786.66 317.666l48.113-27.778C724.624 99.105 480.67 33.738 289.888 143.886 99.105 254.036 33.738 497.99 143.886 688.772c110.15 190.783 354.103 256.15 544.886 146.002zm122.625-502.115c15.341 0 27.778-12.437 27.778-27.778s-12.437-27.778-27.778-27.778-27.778 12.437-27.778 27.778 12.437 27.778 27.778 27.778zm16.244 337.294c15.34 0 27.777-12.437 27.777-27.778s-12.436-27.778-27.777-27.778c-15.342 0-27.778 12.437-27.778 27.778s12.436 27.778 27.778 27.778z", fillRule: "nonzero" }), React__namespace.createElement("path", { d: "M874.77 402.805a.25.25 0 01.353-.025l110.719 96.088a.25.25 0 010 .377l-110.719 96.088a.25.25 0 01-.413-.19v-67.366H750c-15.341 0-27.778-12.436-27.778-27.777 0-15.341 12.437-27.778 27.778-27.778h124.71v-69.253c0-.04.01-.08.027-.114z" }), React__namespace.createElement("path", { d: "M326.543 437.654c0-15.341 12.436-27.778 27.778-27.778h277.777c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.778 27.778H354.321c-15.342 0-27.778-12.437-27.778-27.778z", fillRule: "nonzero" }), React__namespace.createElement("path", { d: "M520.987 437.654v83.333h111.111c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.778 27.778H520.987v111.111c0 15.341-12.436 27.778-27.777 27.778-15.342 0-27.778-12.437-27.778-27.778l-.001-111.111H354.32c-15.342 0-27.778-12.437-27.778-27.778s12.436-27.778 27.778-27.778h111.11v-83.333h55.556zm86.403-145.987c13.286 7.67 17.838 24.659 10.167 37.945l-69.444 120.281L500 422.115l69.444-120.281c7.671-13.286 24.66-17.838 37.946-10.167zm-250 0c13.286-7.671 30.274-3.119 37.945 10.167l69.444 120.281-48.112 27.778-69.445-120.281c-7.67-13.286-3.118-30.275 10.168-37.945z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgCashBackRecord" }, props, { ref }), React__namespace.createElement(SvgIcon$36, null));
  });
  const SvgIcon$35 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M166.667 277.778v555.555h666.666V277.778H166.667zm660.109-55.556l-27.778-55.555H201.002l-27.778 55.555h-62.113l40.2-80.4a55.556 55.556 0 0149.69-30.71h597.997a55.556 55.556 0 0149.69 30.71l40.2 80.4v611.111c0 30.683-24.872 55.556-55.555 55.556H166.667c-30.683 0-55.556-24.873-55.556-55.556v-611.11h715.665z", fillRule: "nonzero" }), React__namespace.createElement("path", { d: "M500.494 443.253l38.79-38.79c10.848-10.848 28.436-10.848 39.283 0 10.848 10.848 10.848 28.436 0 39.283l-28.475 28.476h19.352c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.778 27.778h-41.666v27.778h41.666c15.342 0 27.778 12.436 27.778 27.777 0 15.342-12.436 27.778-27.778 27.778h-41.666v27.778c0 15.341-12.437 27.778-27.778 27.778s-27.778-12.437-27.778-27.778V611.11h-41.666c-15.342 0-27.778-12.436-27.778-27.778 0-15.34 12.436-27.777 27.778-27.777h41.666v-27.778h-41.666c-15.342 0-27.778-12.437-27.778-27.778s12.436-27.778 27.778-27.778h20.34l-28.476-28.476c-10.848-10.847-10.848-28.435 0-39.283 10.848-10.848 28.435-10.848 39.283 0l38.79 38.79z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgCashOnDeliver" }, props, { ref }), React__namespace.createElement(SvgIcon$35, null));
  });
  const SvgIcon$34 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M111.111 166.667v500H888.89v-500H111.11zm416.667 555.555v111.111h166.666c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.778 27.778H305.556c-15.342 0-27.778-12.437-27.778-27.778s12.436-27.778 27.778-27.778h166.666v-111.11h-361.11c-30.683 0-55.556-24.874-55.556-55.556v-500c0-30.683 24.873-55.556 55.555-55.556H888.89c30.682 0 55.555 24.873 55.555 55.556v500c0 30.682-24.873 55.555-55.555 55.555H527.778zm-27.284-397.518l38.79-38.79c10.848-10.848 28.436-10.848 39.283 0 10.848 10.848 10.848 28.436 0 39.283l-28.475 28.476h19.352c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.778 27.778h-41.666v27.777h41.666c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.778 27.778h-41.666v27.778c0 15.341-12.437 27.778-27.778 27.778s-27.778-12.437-27.778-27.778v-27.778h-41.666c-15.342 0-27.778-12.437-27.778-27.778s12.436-27.778 27.778-27.778h41.666V409.23h-41.666c-15.342 0-27.778-12.437-27.778-27.778s12.436-27.778 27.778-27.778h20.34l-28.476-28.476c-10.848-10.847-10.848-28.435 0-39.283 10.848-10.848 28.435-10.848 39.283 0l38.79 38.79z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgCashierO" }, props, { ref }), React__namespace.createElement(SvgIcon$34, null));
  });
  const SvgIcon$33 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M885.464 448.158A392.47 392.47 0 01888.889 500c0 214.777-174.112 388.889-388.889 388.889-214.777 0-388.889-174.112-388.889-388.889 0-214.777 174.112-388.889 388.889-388.889 60.39 0 117.565 13.765 168.559 38.33l-24.11 50.05c-44.65-21.507-93.688-32.824-144.449-32.824-184.095 0-333.333 149.238-333.333 333.333 0 184.095 149.238 333.333 333.333 333.333 184.095 0 333.333-149.238 333.333-333.333 0-14.994-.986-29.85-2.939-44.506l55.07-7.336zM658.147 202.974c-15.342 0-27.778-12.436-27.778-27.778 0-15.341 12.436-27.777 27.778-27.777 15.34 0 27.777 12.436 27.777 27.777 0 15.342-12.436 27.778-27.777 27.778zm199.885 278.687c-15.341 0-27.778-12.436-27.778-27.777 0-15.342 12.437-27.778 27.778-27.778s27.778 12.436 27.778 27.778c0 15.34-12.437 27.777-27.778 27.777zm-518.767-24.009c-6.935-6.924-8.056-17.69-1.944-25.396l14.292-18.016c5.858-7.386 16.816-9.24 24.56-4.07l123.697 82.56c6.525 4.355 17.754 3.788 23.846-1.155l326.858-265.179c7.346-5.96 18.854-5.452 25.294.978l8.05 8.04c7.008 6.996 6.498 18.102-.847 25.436L532.257 611.145c-10.915 10.899-28.835 10.422-40.07-.797L339.264 457.652z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgCertificate" }, props, { ref }), React__namespace.createElement(SvgIcon$33, null));
  });
  const SvgIcon$32 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M727.86 151.64c-14.811 0-26.819-12.007-26.819-26.82 0-14.811 12.008-26.819 26.82-26.819h107.28c14.811 0 26.82 12.008 26.82 26.82V232.1c0 14.811-12.009 26.82-26.82 26.82-14.813 0-26.82-12.009-26.82-26.82v-80.46h-80.46zM191.465 580.759v268.199h107.28V580.758h-107.28zm0-53.64h107.28c29.624 0 53.639 24.016 53.639 53.64v268.199c0 29.624-24.015 53.64-53.64 53.64h-107.28c-29.624 0-53.639-24.016-53.639-53.64V580.758c0-29.624 24.015-53.64 53.64-53.64zm268.198-53.639v375.478h107.28V473.479h-107.28zm0-53.64h107.28c29.624 0 53.64 24.016 53.64 53.64v375.478c0 29.624-24.016 53.64-53.64 53.64h-107.28c-29.624 0-53.64-24.016-53.64-53.64V473.479c0-29.624 24.016-53.64 53.64-53.64zm268.199-53.64v482.758h107.28V366.2H727.86zm107.28-53.64c29.624 0 53.639 24.016 53.639 53.64v482.758c0 29.624-24.015 53.64-53.64 53.64H727.86c-29.624 0-53.639-24.016-53.639-53.64V366.2c0-29.625 24.015-53.64 53.64-53.64h107.28zm20.942-204.492c9.253 11.566 7.378 28.444-4.188 37.697l-279.48 223.584-163.132-52.881-257.774 152.936c-12.739 7.558-29.193 3.358-36.75-9.38-7.559-12.74-3.359-29.194 9.38-36.752l278.623-165.305 158.707 51.446 256.917-205.534c11.566-9.253 28.444-7.378 37.697 4.189z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgChartTrendingO" }, props, { ref }), React__namespace.createElement(SvgIcon$32, null));
  });
  const SvgIcon$31 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M152.319 799.259l109.094-35.232 21.394 12.394C346.44 813.285 421.373 833.333 500 833.333c216.305 0 388.889-151.01 388.889-333.333 0-182.322-172.584-333.333-388.889-333.333S111.111 317.677 111.111 500c0 64.355 21.336 126.044 61.174 179.336l18.843 25.206-38.81 94.717zM500 888.889c-90.56 0-174.793-23.7-245.042-64.397l-142.484 46.015a27.778 27.778 0 01-19.069-.73c-14.195-5.816-20.988-22.04-15.172-36.235l49.555-120.943C82.112 651.497 55.556 578.462 55.556 500c0-214.777 198.984-388.889 444.444-388.889S944.444 285.223 944.444 500c0 214.777-198.984 388.889-444.444 388.889z", fillRule: "nonzero" }), React__namespace.createElement("circle", { cx: 500, cy: 500, r: 55.556 }), React__namespace.createElement("circle", { cx: 277.778, cy: 500, r: 55.556 }), React__namespace.createElement("circle", { cx: 722.222, cy: 500, r: 55.556 })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgChatO" }, props, { ref }), React__namespace.createElement(SvgIcon$31, null));
  });
  const SvgIcon$30 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 111.111c245.46 0 444.444 174.112 444.444 388.889 0 214.777-198.984 388.889-444.444 388.889-90.56 0-174.793-23.7-245.042-64.397l-142.484 46.015a27.778 27.778 0 01-19.069-.73c-14.195-5.816-20.988-22.04-15.172-36.235l49.555-120.943C82.112 651.497 55.556 578.462 55.556 500c0-214.777 198.984-388.889 444.444-388.889zm0 333.333c-30.682 0-55.556 24.874-55.556 55.556s24.874 55.556 55.556 55.556 55.556-24.874 55.556-55.556-24.874-55.556-55.556-55.556zm-222.222 0c-30.683 0-55.556 24.874-55.556 55.556s24.873 55.556 55.556 55.556c30.682 0 55.555-24.874 55.555-55.556s-24.873-55.556-55.555-55.556zm444.444 0c-30.682 0-55.555 24.874-55.555 55.556s24.873 55.556 55.555 55.556c30.683 0 55.556-24.874 55.556-55.556s-24.873-55.556-55.556-55.556z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgChat" }, props, { ref }), React__namespace.createElement(SvgIcon$30, null));
  });
  const SvgIcon$2$ = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M500.445 56c245.46 0 444.445 198.985 444.445 444.445 0 245.46-198.985 444.445-444.445 444.445C254.985 944.89 56 745.905 56 500.445 56 254.985 254.985 56 500.445 56zm266.059 282.106c-5.706-5.318-15.835-5.814-22.457-1.049l-.308.227-294.172 222.751c-5.386 4.079-15.236 4.61-21.148 1.159l-.313-.189-111.327-69.351c-6.867-4.278-16.54-2.83-21.866 3.144l-.24.275-12.861 15.134c-5.423 6.38-4.52 15.259 1.484 21.081l.265.252 137.63 128.264c10.007 9.327 25.908 9.816 35.757.95l.306-.28 315.733-294.249c6.523-6.078 7.056-15.241 1.012-21.13l-.249-.236-7.246-6.753z" })));
  const SvgChecked = React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgChecked" }, props, { ref }), React__namespace.createElement(SvgIcon$2$, null));
  });
  const SvgIcon$2_ = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 881.944c210.942 0 381.944-171.002 381.944-381.944S710.942 118.056 500 118.056 118.056 289.058 118.056 500 289.058 881.944 500 881.944zm0 62.5C254.54 944.444 55.556 745.46 55.556 500S254.54 55.556 500 55.556 944.444 254.54 944.444 500 745.46 944.444 500 944.444z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgCircle" }, props, { ref }), React__namespace.createElement(SvgIcon$2_, null));
  });
  const SvgIcon$2Z = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 55.556c245.46 0 444.444 198.984 444.444 444.444S745.46 944.444 500 944.444 55.556 745.46 55.556 500 254.54 55.556 500 55.556zm176.441 267.887c-10.848-10.848-28.436-10.848-39.284 0L499.665 460.936 362.172 323.443c-10.848-10.848-28.436-10.848-39.284 0-10.848 10.848-10.848 28.436 0 39.284L460.38 500.22 322.888 637.713c-10.848 10.848-10.848 28.436 0 39.284 10.848 10.848 28.436 10.848 39.284 0l137.493-137.493 137.492 137.493c10.848 10.848 28.436 10.848 39.284 0 10.848-10.848 10.848-28.436 0-39.284L538.948 500.22l137.493-137.493c10.848-10.848 10.848-28.436 0-39.284z", fillRule: "evenodd" }));
  const SvgClear = React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgClear" }, props, { ref }), React__namespace.createElement(SvgIcon$2Z, null));
  });
  const SvgIcon$2Y = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 888.889c214.777 0 388.889-174.112 388.889-388.889 0-214.777-174.112-388.889-388.889-388.889-214.777 0-388.889 174.112-388.889 388.889 0 214.777 174.112 388.889 388.889 388.889zm0-833.333c245.46 0 444.444 198.984 444.444 444.444S745.46 944.444 500 944.444 55.556 745.46 55.556 500 254.54 55.556 500 55.556zm-27.778 222.222c-15.341 0-27.778 12.436-27.778 27.778v250c0 15.34 12.437 27.777 27.778 27.777h250c15.341 0 27.778-12.436 27.778-27.777 0-15.342-12.437-27.778-27.778-27.778H500V305.556c0-15.342-12.437-27.778-27.778-27.778z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgClockO" }, props, { ref }), React__namespace.createElement(SvgIcon$2Y, null));
  });
  const SvgIcon$2X = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 55.556c245.46 0 444.444 198.984 444.444 444.444S745.46 944.444 500 944.444 55.556 745.46 55.556 500 254.54 55.556 500 55.556zm-27.778 222.222c-15.341 0-27.778 12.436-27.778 27.778v250c0 15.34 12.437 27.777 27.778 27.777h250c15.341 0 27.778-12.436 27.778-27.777 0-15.342-12.437-27.778-27.778-27.778H500V305.556c0-15.342-12.437-27.778-27.778-27.778z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgClock" }, props, { ref }), React__namespace.createElement(SvgIcon$2X, null));
  });
  const SvgIcon$2W = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M499.665 460.936l137.492-137.493c10.848-10.848 28.436-10.848 39.284 0 10.848 10.848 10.848 28.436 0 39.284L538.948 500.22l137.493 137.493c10.848 10.848 10.848 28.436 0 39.284-10.848 10.848-28.436 10.848-39.284 0L499.665 539.504 362.172 676.997c-10.848 10.848-28.436 10.848-39.284 0-10.848-10.848-10.848-28.436 0-39.284L460.38 500.22 322.888 362.727c-10.848-10.848-10.848-28.436 0-39.284 10.848-10.848 28.436-10.848 39.284 0l137.493 137.493z" }), React__namespace.createElement("path", { d: "M500 888.889c214.777 0 388.889-174.112 388.889-388.889 0-214.777-174.112-388.889-388.889-388.889-214.777 0-388.889 174.112-388.889 388.889 0 214.777 174.112 388.889 388.889 388.889zm0 55.555C254.54 944.444 55.556 745.46 55.556 500S254.54 55.556 500 55.556 944.444 254.54 944.444 500 745.46 944.444 500 944.444z", fillRule: "nonzero" })));
  const SvgClose = React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgClose" }, props, { ref }), React__namespace.createElement(SvgIcon$2W, null));
  });
  const SvgIcon$2V = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M85.26 345.238c-26.768-28.64 15.701-72.148 42.532-43.446 58.156 62.228 138.743 110.914 217.855 138.336 199.438 69.118 391.397-.516 545.582-138.336 29.055-25.968 71.77 17.314 42.523 43.446-19.976 17.858-40.684 34.799-62.038 50.647 17.924 35.233 35.842 70.449 53.77 105.665 17.874 35.118-34.04 66.188-51.945 31.008-19.41-38.196-38.853-76.336-58.271-114.5l6.242 12.267c-35.623 22.484-72.73 41.841-110.976 57.36l43.496 113.343c14.18 36.944-44.013 52.78-57.995 16.334l-42.15-109.817c-41.199 12.182-83.465 19.759-126.398 21.911v-.01c.045.747.069 1.508.069 2.284v129.024c0 39.624-60.145 39.624-60.145 0V531.73c0-.976.036-1.928.107-2.856-40.302-2.814-81.023-10.626-121.84-24.082-.944-.311-1.887-.624-2.831-.94L296.928 623.52c-13.987 36.452-72.166 20.6-57.995-16.336l46.095-120.118a35.842 35.842 0 012.081-4.49c-35.25-15.161-69.874-33.439-102.41-54.713-23.58 31.223-47.154 62.45-70.735 93.657-9.99 13.25-25.63 20.312-41.14 11.03-12.787-7.656-20.832-28.742-10.79-42.03l74.059-98.056c-18.084-14.681-35.135-30.431-50.832-47.226z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgClosedEye" }, props, { ref }), React__namespace.createElement(SvgIcon$2V, null));
  });
  const SvgIcon$2U = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M444.444 166.667v111.11h111.112v-111.11H444.444zm0-55.556h111.112c30.682 0 55.555 24.873 55.555 55.556v111.11c0 30.683-24.873 55.556-55.555 55.556H444.444c-30.682 0-55.555-24.873-55.555-55.555V166.667c0-30.683 24.873-55.556 55.555-55.556zM111.111 722.222v111.111h111.111v-111.11h-111.11zm0-55.555h111.111c30.683 0 55.556 24.873 55.556 55.555v111.111c0 30.683-24.873 55.556-55.556 55.556h-111.11c-30.683 0-55.556-24.873-55.556-55.556v-111.11c0-30.683 24.873-55.556 55.555-55.556zM444.444 722.222v111.111h111.112v-111.11H444.444zm0-55.555h111.112c30.682 0 55.555 24.873 55.555 55.555v111.111c0 30.683-24.873 55.556-55.555 55.556H444.444c-30.682 0-55.555-24.873-55.555-55.556v-111.11c0-30.683 24.873-55.556 55.555-55.556zM777.778 722.222v111.111h111.11v-111.11h-111.11zm0-55.555h111.11c30.683 0 55.556 24.873 55.556 55.555v111.111c0 30.683-24.873 55.556-55.555 55.556H777.778c-30.683 0-55.556-24.873-55.556-55.556v-111.11c0-30.683 24.873-55.556 55.556-55.556z", fillRule: "nonzero" }), React__namespace.createElement("path", { d: "M156.306 666.667c44.138-136.632 167.486-237.657 315.916-248.948V277.778h55.556v139.941c148.43 11.291 271.778 112.316 315.916 248.948h-58.968c-41.236-105.59-139.513-182.616-256.948-193.2v193.2h-55.556v-193.2c-117.435 10.584-215.712 87.61-256.948 193.2h-58.968z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgClusterO" }, props, { ref }), React__namespace.createElement(SvgIcon$2U, null));
  });
  const SvgIcon$2T = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M527.778 333.333v84.386c148.43 11.291 271.778 112.316 315.916 248.948h45.195c30.682 0 55.555 24.873 55.555 55.555v111.111c0 30.683-24.873 55.556-55.555 55.556H777.778c-30.683 0-55.556-24.873-55.556-55.556v-111.11c0-30.683 24.873-55.556 55.556-55.556h6.948c-41.236-105.59-139.513-182.616-256.948-193.2v193.2h27.778c30.682 0 55.555 24.873 55.555 55.555v111.111c0 30.683-24.873 55.556-55.555 55.556H444.444c-30.682 0-55.555-24.873-55.555-55.556v-111.11c0-30.683 24.873-55.556 55.555-55.556h27.778v-193.2c-117.435 10.584-215.712 87.61-256.948 193.2h6.948c30.683 0 55.556 24.873 55.556 55.555v111.111c0 30.683-24.873 55.556-55.556 55.556h-111.11c-30.683 0-55.556-24.873-55.556-55.556v-111.11c0-30.683 24.873-55.556 55.555-55.556h45.195c44.138-136.632 167.486-237.657 315.916-248.948v-84.386h-27.778c-30.682 0-55.555-24.873-55.555-55.555V166.667c0-30.683 24.873-55.556 55.555-55.556h111.112c30.682 0 55.555 24.873 55.555 55.556v111.11c0 30.683-24.873 55.556-55.555 55.556h-27.778z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgCluster" }, props, { ref }), React__namespace.createElement(SvgIcon$2T, null));
  });
  const SvgIcon$2S = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M222.222 111.111h444.445c30.682 0 55.555 24.873 55.555 55.556v666.666c0 30.683-24.873 55.556-55.555 55.556H222.222c-30.682 0-55.555-24.873-55.555-55.556V166.667c0-30.683 24.873-55.556 55.555-55.556zm583.334 0c15.34 0 27.777 12.437 27.777 27.778V861.11c0 15.341-12.436 27.778-27.777 27.778-15.342 0-27.778-12.437-27.778-27.778V138.89c0-15.341 12.436-27.778 27.778-27.778zm-500 166.667c-15.342 0-27.778 12.436-27.778 27.778 0 15.34 12.436 27.777 27.778 27.777h277.777c15.342 0 27.778-12.436 27.778-27.777 0-15.342-12.436-27.778-27.778-27.778H305.556zm0 111.11c-15.342 0-27.778 12.437-27.778 27.779 0 15.34 12.436 27.777 27.778 27.777h277.777c15.342 0 27.778-12.436 27.778-27.777 0-15.342-12.436-27.778-27.778-27.778H305.556zm0 111.112c-15.342 0-27.778 12.437-27.778 27.778s12.436 27.778 27.778 27.778h166.666c15.341 0 27.778-12.437 27.778-27.778S487.563 500 472.222 500H305.556z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgColumn" }, props, { ref }), React__namespace.createElement(SvgIcon$2S, null));
  });
  const SvgIcon$2R = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 55.556c245.46 0 444.444 198.984 444.444 444.444S745.46 944.444 500 944.444 55.556 745.46 55.556 500 254.54 55.556 500 55.556zm0 55.555c-214.777 0-388.889 174.112-388.889 388.889 0 214.777 174.112 388.889 388.889 388.889 214.777 0 388.889-174.112 388.889-388.889 0-214.777-174.112-388.889-388.889-388.889zm218.75 166.667c17.259 0 31.25 13.99 31.25 31.25v331.039c0 17.259-13.991 31.25-31.25 31.25H428.142l-32.35 62.325a31.25 31.25 0 01-13.34 13.34c-15.318 7.95-34.182 1.978-42.133-13.34l-32.35-62.325H281.25c-17.259 0-31.25-13.991-31.25-31.25v-331.04c0-17.258 13.991-31.25 31.25-31.25h437.5zm-24.306 55.555H305.556v282.428h36.17l26.33 50.726 26.329-50.726h300.06V333.333z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgCommentCircleO" }, props, { ref }), React__namespace.createElement(SvgIcon$2R, null));
  });
  const SvgIcon$2Q = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 55.556c245.46 0 444.444 198.984 444.444 444.444S745.46 944.444 500 944.444 55.556 745.46 55.556 500 254.54 55.556 500 55.556zm218.75 222.222h-437.5c-17.259 0-31.25 13.99-31.25 31.25v331.039c0 17.259 13.991 31.25 31.25 31.25h26.72l32.35 62.325c7.95 15.318 26.814 21.29 42.132 13.34a31.25 31.25 0 0013.34-13.34l32.35-62.325H718.75c17.259 0 31.25-13.991 31.25-31.25v-331.04c0-17.258-13.991-31.25-31.25-31.25zm-24.306 55.555v282.428h-300.06l-26.328 50.726-26.33-50.726h-36.17V333.333h388.888z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgCommentCircle" }, props, { ref }), React__namespace.createElement(SvgIcon$2Q, null));
  });
  const SvgIcon$2P = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M500 788.734l81.379-122.068h307.51v-500H111.11v500h307.51L500 788.734zm46.225 30.816a55.556 55.556 0 01-15.408 15.409c-25.53 17.02-60.022 10.12-77.042-15.409l-64.886-97.329H111.11c-30.682 0-55.555-24.873-55.555-55.555v-500c0-30.683 24.873-55.556 55.555-55.556H888.89c30.682 0 55.555 24.873 55.555 55.556v500c0 30.682-24.873 55.555-55.555 55.555H611.11l-64.886 97.33z", fillRule: "nonzero" }), React__namespace.createElement("path", { d: "M305.556 277.777h388.888c15.342 0 27.778 12.436 27.778 27.777 0 15.342-12.436 27.778-27.778 27.778H305.556c-15.342 0-27.778-12.436-27.778-27.778 0-15.34 12.436-27.777 27.778-27.777zM305.556 444.443h388.888c15.342 0 27.778 12.437 27.778 27.778S709.786 500 694.444 500H305.556c-15.342 0-27.778-12.437-27.778-27.778s12.436-27.778 27.778-27.778z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgCommentO" }, props, { ref }), React__namespace.createElement(SvgIcon$2P, null));
  });
  const SvgIcon$2O = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M611.111 722.221l-64.886 97.33a55.556 55.556 0 01-15.408 15.408c-25.53 17.02-60.022 10.12-77.042-15.409l-64.886-97.329H111.11c-30.682 0-55.555-24.873-55.555-55.555v-500c0-30.683 24.873-55.556 55.555-55.556H888.89c30.682 0 55.555 24.873 55.555 55.556v500c0 30.682-24.873 55.555-55.555 55.555H611.11zM305.556 277.777c-15.342 0-27.778 12.436-27.778 27.777 0 15.342 12.436 27.778 27.778 27.778h388.888c15.342 0 27.778-12.436 27.778-27.778 0-15.34-12.436-27.777-27.778-27.777H305.556zm0 166.666c-15.342 0-27.778 12.437-27.778 27.778S290.214 500 305.556 500h388.888c15.342 0 27.778-12.437 27.778-27.778s-12.436-27.778-27.778-27.778H305.556z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgComment" }, props, { ref }), React__namespace.createElement(SvgIcon$2O, null));
  });
  const SvgIcon$2N = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M777.778 111.111c30.682 0 55.555 24.873 55.555 55.556v722.222c0 30.376-24.378 55.057-54.637 55.548l-.918.007H222.222c-30.682 0-55.555-24.873-55.555-55.555V166.667c0-30.683 24.873-55.556 55.555-55.556V888.89h555.556V111.11zm-66.89 279.655l1.608-1.334c.91-.756 2.779-.672 3.376-.062l5.967 6.096c.61.623.557 1.797-.629 3.008l-1.161 1.187c3.48 4.877 2.732 11.643-1.9 16.267L472.58 661.135c-4.321 4.315-10.21 6.082-15.935 5.383-3.013.554-6.37-.443-8.893-3.021l-.888-.905a21.197 21.197 0 01-2.334-2.015L337.485 553.69c-2.045-2.042-3.368-4.561-3.894-7.197a2.995 2.995 0 01-.223-1.65 12.776 12.776 0 012.757-8.93l10.004-12.612c4.1-5.17 11.771-6.468 17.193-2.85l86.587 57.793c4.567 3.049 12.428 2.652 16.692-.808l228.8-185.625c4.38-3.553 10.872-3.823 15.486-1.045zm-322-279.655v55.556H222.223V111.11H388.89zm388.89 0v55.556H611.11V111.11h166.667zm-361.111 0c-15.342 0-27.778 12.437-27.778 27.778s12.436 27.778 27.778 27.778h166.666c15.342 0 27.778-12.437 27.778-27.778s-12.436-27.778-27.778-27.778H416.667zm0-55.555h166.666c46.024 0 83.334 37.31 83.334 83.333 0 46.024-37.31 83.333-83.334 83.333H416.667c-46.024 0-83.334-37.31-83.334-83.333 0-46.024 37.31-83.333 83.334-83.333z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgCompleted" }, props, { ref }), React__namespace.createElement(SvgIcon$2N, null));
  });
  const SvgIcon$2M = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "nonzero" }, React__namespace.createElement("path", { d: "M500 583.333c220.53 0 388.889 83.387 388.889 222.823 0 60.094-48.844 105.795-121.434 105.795h-534.91c-73.024 0-121.434-44.756-121.434-105.795 0-137.673 170.265-222.823 388.889-222.823zm0 55.556c-191.879 0-333.333 70.742-333.333 167.267 0 29.34 22.605 50.24 65.878 50.24h534.91c42.702 0 65.878-21.685 65.878-50.24 0-98.135-139.577-167.267-333.333-167.267zM500 444.444c92.047 0 166.667-74.619 166.667-166.666 0-92.048-74.62-166.667-166.667-166.667s-166.667 74.62-166.667 166.667S407.953 444.444 500 444.444zM500 500c-122.73 0-222.222-99.492-222.222-222.222S377.27 55.556 500 55.556s222.222 99.492 222.222 222.222S622.73 500 500 500z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgContact" }, props, { ref }), React__namespace.createElement(SvgIcon$2M, null));
  });
  const SvgIcon$2L = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "nonzero" }, React__namespace.createElement("path", { d: "M55.556 430.556v-13.89 13.89zm0 138.888v13.89-13.89zm888.888 0v13.89-13.89zm0-138.888v-13.89 13.89zm0 0v13.888c-30.682 0-55.555 24.874-55.555 55.556s24.873 55.556 55.555 55.556v222.222c0 30.682-24.873 55.555-55.555 55.555H111.11c-30.682 0-55.555-24.873-55.555-55.555V555.556c30.682 0 55.555-24.874 55.555-55.556s-24.873-55.556-55.555-55.556V222.222c0-30.682 24.873-55.555 55.555-55.555H888.89c30.682 0 55.555 24.873 55.555 55.555v222.222H888.89V222.222H111.11v222.222H55.556v-13.888 13.888c30.682 0 55.555 24.874 55.555 55.556s-24.873 55.556-55.555 55.556v13.888-13.888h55.555v222.222H888.89V555.556h55.555v13.888-13.888c-30.682 0-55.555-24.874-55.555-55.556s24.873-55.556 55.555-55.556v-13.888zm-583.333-41.667H638.89c15.341 0 27.778 12.436 27.778 27.778 0 15.34-12.437 27.777-27.778 27.777H361.11c-15.341 0-27.778-12.436-27.778-27.777 0-15.342 12.437-27.778 27.778-27.778zm0 166.667H638.89c15.341 0 27.778 12.436 27.778 27.777 0 15.342-12.437 27.778-27.778 27.778H361.11c-15.341 0-27.778-12.436-27.778-27.778 0-15.34 12.437-27.777 27.778-27.777z" }), React__namespace.createElement("path", { d: "M55.556 388.889c61.365 0 111.11 49.746 111.11 111.111s-49.745 111.111-111.11 111.111v-55.555c30.682 0 55.555-24.874 55.555-55.556s-24.873-55.556-55.555-55.556V388.89zm888.888 0v55.555c-30.682 0-55.555 24.874-55.555 55.556s24.873 55.556 55.555 55.556v55.555c-61.365 0-111.11-49.746-111.11-111.111s49.745-111.111 111.11-111.111z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgCouponO" }, props, { ref }), React__namespace.createElement(SvgIcon$2L, null));
  });
  const SvgIcon$2K = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M55.556 388.889V222.222c0-30.682 24.873-55.555 55.555-55.555H888.89c30.682 0 55.555 24.873 55.555 55.555V388.89c-61.365 0-111.11 49.746-111.11 111.111s49.745 111.111 111.11 111.111v166.667c0 30.682-24.873 55.555-55.555 55.555H111.11c-30.682 0-55.555-24.873-55.555-55.555V611.11c61.365 0 111.11-49.746 111.11-111.111s-49.745-111.111-111.11-111.111zm305.555 0c-15.341 0-27.778 12.436-27.778 27.778 0 15.34 12.437 27.777 27.778 27.777H638.89c15.341 0 27.778-12.436 27.778-27.777 0-15.342-12.437-27.778-27.778-27.778H361.11zm0 166.667c-15.341 0-27.778 12.436-27.778 27.777 0 15.342 12.437 27.778 27.778 27.778H638.89c15.341 0 27.778-12.436 27.778-27.778 0-15.34-12.437-27.777-27.778-27.777H361.11z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgCoupon" }, props, { ref }), React__namespace.createElement(SvgIcon$2K, null));
  });
  const SvgIcon$2J = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M888.889 166.667c30.667 0 55.555 24.889 55.555 55.555v555.556c0 30.722-24.888 55.555-55.555 55.555H111.11c-30.667 0-55.555-24.833-55.555-55.555V222.222c0-30.666 24.888-55.555 55.555-55.555zm0 166.666H111.11v444.445H888.89V333.333zm0-111.11H111.11v55.555H888.89v-55.556zM583.044 667.088h166.667c15.333 0 27.778-12.445 27.778-27.778 0-15.333-12.445-27.778-27.778-27.778H583.044c-15.333 0-27.777 12.445-27.777 27.778 0 15.333 12.444 27.778 27.777 27.778", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgCreditPay" }, props, { ref }), React__namespace.createElement(SvgIcon$2J, null));
  });
  const SvgIcon$2I = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M560.149 501.223l255.344 255.344c16.272 16.272 16.272 42.654 0 58.926s-42.654 16.272-58.926 0L501.223 560.149 245.88 815.493c-16.272 16.272-42.654 16.272-58.925 0-16.272-16.272-16.272-42.654 0-58.926l255.344-255.344L186.954 245.88c-16.272-16.272-16.272-42.654 0-58.925 16.271-16.272 42.653-16.272 58.925 0l255.344 255.344 255.344-255.344c16.272-16.272 42.654-16.272 58.926 0 16.272 16.271 16.272 42.653 0 58.925L560.149 501.223z", fillRule: "nonzero" }));
  const SvgCross = React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgCross" }, props, { ref }), React__namespace.createElement(SvgIcon$2I, null));
  });
  const SvgIcon$2H = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M888.889 166.667c30.667 0 55.555 24.833 55.555 55.555v555.556c0 30.722-24.888 55.555-55.555 55.555H111.11c-30.667 0-55.555-24.833-55.555-55.555V222.222c0-30.722 24.888-55.555 55.555-55.555zm0 166.666H111.11v444.445H888.89V333.333zm0-111.11H111.11v55.555H888.89v-55.556zM468.572 697.805c10.834 10.833 28.445 10.833 39.278 0l39.278-39.278c10.833-10.834 10.833-28.445 0-39.278-10.834-10.833-28.445-10.833-39.278 0l-39.278 39.278c-10.833 10.833-10.833 28.444 0 39.278m150.39 0l39.277-39.278c10.833-10.834 10.833-28.445 0-39.278-10.833-10.833-28.445-10.833-39.278 0l-39.278 39.278c-10.833 10.833-10.833 28.444 0 39.278 10.834 10.833 28.445 10.833 39.278 0m111.111 0l39.278-39.278c10.833-10.834 10.833-28.445 0-39.278-10.833-10.833-28.444-10.833-39.278 0l-39.278 39.278c-10.833 10.833-10.833 28.444 0 39.278 10.834 10.833 28.445 10.833 39.278 0", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgDebitPay" }, props, { ref }), React__namespace.createElement(SvgIcon$2H, null));
  });
  const SvgIcon$2G = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M141 434.955c0 .025-.02.045-.045.045h-9.91a.045.045 0 01-.045-.045V425h10v9.955zM142.5 424h-13a.5.5 0 000 1h.5v9.955c0 .577.468 1.045 1.045 1.045h9.91c.577 0 1.045-.468 1.045-1.045V425h.5a.5.5 0 000-1zm-4 9a.5.5 0 00.5-.5v-5a.5.5 0 00-1 0v5a.5.5 0 00.5.5m-5 0a.5.5 0 00.5-.5v-5a.5.5 0 00-1 0v5a.5.5 0 00.5.5m2.5 0a.5.5 0 00.5-.5v-5a.5.5 0 00-1 0v5a.5.5 0 00.5.5m-3.5-10h7a.5.5 0 000-1h-7a.5.5 0 000 1" }), React__namespace.createElement("path", { d: "M777.778 830.839a2.49 2.49 0 01-2.5 2.5H224.722a2.49 2.49 0 01-2.5-2.5V277.783h555.556V830.84zm83.333-608.611H138.89c-15.333 0-27.778 12.444-27.778 27.778 0 15.333 12.445 27.777 27.778 27.777h27.778V830.84c0 32.055 26 58.055 58.055 58.055h550.556c32.055 0 58.055-26 58.055-58.055V277.783h27.778c15.333 0 27.778-12.444 27.778-27.777 0-15.334-12.445-27.778-27.778-27.778zM638.89 722.222c15.333 0 27.778-12.444 27.778-27.778V416.667c0-15.334-12.445-27.778-27.778-27.778-15.333 0-27.778 12.444-27.778 27.778v277.777c0 15.334 12.445 27.778 27.778 27.778m-277.778 0c15.333 0 27.778-12.444 27.778-27.778V416.667c0-15.334-12.445-27.778-27.778-27.778-15.333 0-27.778 12.444-27.778 27.778v277.777c0 15.334 12.445 27.778 27.778 27.778m138.889 0c15.333 0 27.778-12.444 27.778-27.778V416.667c0-15.334-12.445-27.778-27.778-27.778-15.333 0-27.778 12.444-27.778 27.778v277.777c0 15.334 12.445 27.778 27.778 27.778M305.556 166.667h388.888c15.334 0 27.778-12.445 27.778-27.778 0-15.333-12.444-27.778-27.778-27.778H305.556c-15.334 0-27.778 12.445-27.778 27.778 0 15.333 12.444 27.778 27.778 27.778" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgDeleteO" }, props, { ref }), React__namespace.createElement(SvgIcon$2G, null));
  });
  const SvgIcon$2F = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M141 434.955c0 .025-.02.045-.045.045h-9.91a.045.045 0 01-.045-.045V425h10v9.955zM142.5 424h-13a.5.5 0 000 1h.5v9.955c0 .577.468 1.045 1.045 1.045h9.91c.577 0 1.045-.468 1.045-1.045V425h.5a.5.5 0 000-1zm-4 9a.5.5 0 00.5-.5v-5a.5.5 0 00-1 0v5a.5.5 0 00.5.5m-5 0a.5.5 0 00.5-.5v-5a.5.5 0 00-1 0v5a.5.5 0 00.5.5m2.5 0a.5.5 0 00.5-.5v-5a.5.5 0 00-1 0v5a.5.5 0 00.5.5m-3.5-10h7a.5.5 0 000-1h-7a.5.5 0 000 1" }), React__namespace.createElement("path", { d: "M861.002 222.117c15.334 0 27.778 12.444 27.778 27.778 0 15.333-12.444 27.778-27.778 27.778h-27.778V830.73c0 32.055-26 58.056-58.055 58.056H224.61c-32.055 0-58.055-26-58.055-58.056V277.673h-27.778c-15.334 0-27.778-12.445-27.778-27.778 0-15.334 12.444-27.778 27.778-27.778zM638.78 388.779c-15.333 0-27.778 12.444-27.778 27.777v277.779c0 15.333 12.445 27.778 27.778 27.778 15.334 0 27.778-12.445 27.778-27.778V416.556c0-15.333-12.444-27.777-27.778-27.777zm-277.778 0c-15.334 0-27.778 12.444-27.778 27.777v277.779c0 15.333 12.444 27.778 27.778 27.778 15.333 0 27.778-12.445 27.778-27.778V416.556c0-15.333-12.445-27.777-27.778-27.777zm138.889 0c-15.333 0-27.778 12.444-27.778 27.777v277.779c0 15.333 12.445 27.778 27.778 27.778 15.333 0 27.778-12.445 27.778-27.778V416.556c0-15.333-12.445-27.777-27.778-27.777zM305.445 166.556h388.89c15.333 0 27.778-12.445 27.778-27.778 0-15.334-12.445-27.778-27.778-27.778h-388.89c-15.333 0-27.778 12.444-27.778 27.778 0 15.333 12.445 27.778 27.778 27.778" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgDelete" }, props, { ref }), React__namespace.createElement(SvgIcon$2F, null));
  });
  const SvgIcon$2E = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M751.309 662.774l65.753-65.753c16.272-16.272 42.654-16.272 58.926 0 16.272 16.271 16.272 42.653 0 58.925L742.553 789.381c-5.747 7.39-13.93 12.794-23.342 15.006-13.74 3.447-28.896-.202-39.642-10.948-9.954-9.955-13.819-23.693-11.594-36.586V236.047c0-23.012 18.655-41.667 41.667-41.667s41.667 18.655 41.667 41.667v426.727zm-597.832-414.66h361.11c23.013 0 41.667 18.654 41.667 41.666 0 23.012-18.654 41.667-41.666 41.667H153.477c-23.012 0-41.667-18.655-41.667-41.667s18.655-41.667 41.667-41.667zm0 222.222h361.11c23.013 0 41.667 18.654 41.667 41.666 0 23.012-18.654 41.667-41.666 41.667H153.477c-23.012 0-41.667-18.655-41.667-41.667s18.655-41.666 41.667-41.666zm0 222.222h361.11c23.013 0 41.667 18.655 41.667 41.666 0 23.012-18.654 41.667-41.666 41.667H153.477c-23.012 0-41.667-18.655-41.667-41.667 0-23.011 18.655-41.666 41.667-41.666z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgDescending" }, props, { ref }), React__namespace.createElement(SvgIcon$2E, null));
  });
  const SvgIcon$2D = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M611.111 865.889V722.222h143.667L611.11 865.89zm-388.889 23V111.11h555.556v555.556H611.11c-30.722 0-55.555 24.833-55.555 55.555V888.89H222.222zM777.778 55.556H222.222c-30.722 0-55.555 24.833-55.555 55.555V888.89c0 30.722 24.833 55.555 55.555 55.555h365.89a55.505 55.505 0 0039.277-16.277l39.278-39.278 111.11-111.111 39.279-39.278c10.444-10.389 16.277-24.556 16.277-39.278v-588.11c0-30.723-24.833-55.556-55.555-55.556zm-138.89 166.672H361.112c-15.333 0-27.778 12.444-27.778 27.778 0 15.333 12.445 27.777 27.778 27.777H638.89c15.333 0 27.778-12.444 27.778-27.777 0-15.334-12.445-27.778-27.778-27.778m0 111.11H361.11c-15.333 0-27.778 12.445-27.778 27.779 0 15.333 12.445 27.777 27.778 27.777H638.89c15.333 0 27.778-12.444 27.778-27.777 0-15.334-12.445-27.778-27.778-27.778M527.778 444.45H361.11c-15.333 0-27.778 12.444-27.778 27.778 0 15.333 12.445 27.778 27.778 27.778h166.667c15.333 0 27.778-12.445 27.778-27.778 0-15.334-12.445-27.778-27.778-27.778", fillRule: "evenodd" }));
  const SvgDescription = React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgDescription" }, props, { ref }), React__namespace.createElement(SvgIcon$2D, null));
  });
  const SvgIcon$2C = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M777.778 555.556V111.11H222.222v444.445h555.556zm-388.89 111.11h222.223v-55.555H388.89v55.556zm333.334 55.556H277.778V888.89h444.444V722.222zm55.556-666.666c30.722 0 55.555 24.888 55.555 55.555v444.445c0 30.722-24.833 55.555-55.555 55.555H666.667v55.556h55.555c30.722 0 55.556 24.889 55.556 55.555V888.89c0 30.722-24.834 55.555-55.556 55.555H277.778c-30.722 0-55.556-24.833-55.556-55.555V722.222c0-30.666 24.834-55.555 55.556-55.555h55.555V611.11h-111.11c-30.723 0-55.556-24.833-55.556-55.555V111.11c0-30.667 24.833-55.555 55.555-55.555h555.556zM583.333 833.36c-15.34 0-27.777-12.436-27.777-27.778 0-15.34 12.436-27.777 27.777-27.777h55.556c15.341 0 27.778 12.436 27.778 27.777 0 15.342-12.437 27.778-27.778 27.778h-55.556z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgDesktopO" }, props, { ref }), React__namespace.createElement(SvgIcon$2C, null));
  });
  const SvgIcon$2B = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M116.01 405.664l384.027 423.734 383.955-423.653-121.974-183.523H237.926L116.01 405.664zm-50.388 27.132c-11.915-13.124-13.392-31.6-3.688-46.137l133.318-200.596c8.056-12.052 22.516-19.413 38.108-19.396h533.28c15.61 0 30.074 7.392 38.107 19.479l133.322 200.596c9.7 14.533 8.223 33.01-3.692 46.137L534.419 874.19c-8.451 9.319-21.096 14.716-34.439 14.699-13.342-.013-25.97-5.442-34.4-14.782L65.622 432.797zm239.934-99.463h388.888c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.778 27.778H305.556c-15.342 0-27.778-12.437-27.778-27.778s12.436-27.778 27.778-27.778z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgDiamondO" }, props, { ref }), React__namespace.createElement(SvgIcon$2B, null));
  });
  const SvgIcon$2A = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M766.64 166.667c15.61 0 30.074 7.392 38.107 19.479l133.322 200.596c9.7 14.533 8.223 33.01-3.692 46.137L534.419 874.19c-8.451 9.319-21.096 14.716-34.439 14.699-13.342-.013-25.97-5.442-34.4-14.782L65.622 432.797c-11.915-13.125-13.392-31.601-3.688-46.138l133.318-200.596c8.056-12.052 22.516-19.413 38.108-19.396h533.28zm-72.196 166.666H305.556c-15.342 0-27.778 12.437-27.778 27.778s12.436 27.778 27.778 27.778h388.888c15.342 0 27.778-12.437 27.778-27.778s-12.436-27.778-27.778-27.778z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgDiamond" }, props, { ref }), React__namespace.createElement(SvgIcon$2A, null));
  });
  const SvgIcon$2z = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M470.172 865.55l29.854-18.999 29.84 19.023c32.347 20.623 56.512 26.476 73.934 21.807 17.422-4.668 35.423-21.82 53.125-55.852l16.352-31.436 35.399 1.571c38.295 1.7 62.138-5.31 74.91-18.082 12.772-12.773 19.783-36.615 18.083-74.91l-1.572-35.4 31.436-16.351c34.033-17.702 51.184-35.703 55.853-53.125 4.668-17.423-1.185-41.588-21.808-73.935l-19.023-29.839 19-29.854c20.626-32.412 26.485-56.6 21.83-73.972-4.654-17.371-21.822-35.39-55.892-53.146l-31.339-16.333 1.51-35.307c1.644-38.413-5.38-62.302-18.078-75s-36.587-19.722-75-18.079l-35.307 1.51-16.333-31.338c-17.756-34.07-35.775-51.238-53.146-55.893-17.372-4.654-41.56 1.204-73.972 21.831l-29.841 18.991-29.833-19.003c-32.38-20.624-56.557-26.48-73.954-21.819-17.396 4.662-35.406 21.821-53.136 55.873l-16.342 31.387-35.353-1.54c-38.354-1.672-62.22 5.345-74.955 18.08s-19.752 36.6-18.08 74.955l1.54 35.369-31.407 16.337c-34.033 17.702-51.184 35.703-55.853 53.125-4.668 17.422 1.185 41.587 21.808 73.935l19.023 29.838-19 29.854c-20.626 32.413-26.485 56.601-21.83 73.973 4.654 17.37 21.822 35.39 55.892 53.146l31.339 16.333-1.51 35.307c-1.644 38.413 5.38 62.302 18.078 75s36.587 19.722 75 18.079l35.307-1.51 16.333 31.338c17.756 34.07 35.775 51.238 53.146 55.892 17.372 4.655 41.56-1.204 73.972-21.83zM500 912.42c-44.445 28.284-83.838 37.826-118.178 28.624-34.341-9.202-63.686-37.161-88.034-83.879-52.653 2.253-91.539-9.18-116.658-34.3-25.119-25.118-36.552-64.004-34.3-116.657-46.717-24.348-74.677-53.693-83.878-88.034-9.202-34.34.34-73.733 28.624-118.178-28.3-44.39-37.84-83.782-28.624-118.179 9.216-34.396 37.176-63.74 83.878-88.033-2.293-52.612 9.14-91.498 34.3-116.658 25.16-25.16 64.046-36.593 116.658-34.3 24.32-46.71 53.665-74.67 88.034-83.878 34.368-9.21 73.761.332 118.178 28.624 44.445-28.284 83.838-37.826 118.178-28.624 34.341 9.201 63.686 37.16 88.034 83.878 52.653-2.252 91.539 9.181 116.658 34.3 25.119 25.12 36.552 64.005 34.3 116.658 46.717 24.348 74.677 53.693 83.878 88.033 9.202 34.341-.34 73.734-28.624 118.179 28.3 44.39 37.84 83.782 28.624 118.178-9.216 34.397-37.176 63.741-83.878 88.034 2.333 52.571-9.1 91.457-34.3 116.658-25.2 25.2-64.086 36.633-116.658 34.3-24.293 46.702-53.637 74.662-88.034 83.878-34.396 9.216-73.789-.325-118.178-28.624z", fillRule: "nonzero" }), React__namespace.createElement("path", { d: "M612.444 492.889c24.445 0 43.112 8.444 56.445 26.222 11.555 15.111 17.778 35.556 17.778 60.889 0 24.889-6.223 45.333-17.778 60.889-13.333 16.889-32 25.778-56.445 25.778-24.888 0-44-8.89-57.333-25.778-12-16-17.778-36-17.778-60.889 0-25.333 5.778-45.778 17.778-60.889 13.333-17.778 32.445-26.222 57.333-26.222zm-44-149.778h36.445L426.667 672.89h-36L568.444 343.11zM384 349.333c24.444 0 43.111 8.445 56.444 26.223 11.556 15.11 17.778 35.555 17.778 60.888 0 24.89-6.222 45.334-17.778 60.89-13.333 16.888-32 25.777-56.444 25.777-24.889 0-44-8.889-57.333-25.778-12-16-17.778-36-17.778-60.889 0-25.333 5.778-45.777 17.778-60.888C340 357.778 359.11 349.333 384 349.333zm228.444 174.223c-11.555 0-20 5.777-25.333 17.333-4 9.333-5.778 22.222-5.778 39.111 0 16 1.778 28.889 5.778 38.667C592.444 630.222 600.89 636 612.444 636c11.112 0 19.112-6.222 24.445-18.222 3.555-9.334 5.778-21.778 5.778-37.778 0-16.444-2.223-29.333-6.223-38.667-4.888-12-12.888-17.777-24-17.777zM384 380c-11.556 0-20 5.778-25.333 17.333-4 9.334-5.778 22.223-5.778 39.111 0 16 1.778 28.89 5.778 38.667C364 486.667 372.444 492.444 384 492.444c11.111 0 19.111-6.222 24.444-18.222 3.556-9.333 5.778-21.778 5.778-37.778 0-16.444-2.222-29.333-6.222-38.666-4.889-12-12.889-17.778-24-17.778z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgDiscount" }, props, { ref }), React__namespace.createElement(SvgIcon$2z, null));
  });
  const SvgIcon$2y = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M499.663 56c23.532 0 42.608 19.076 42.608 42.608V805.3l211.318-211.318c16.474-16.473 43.08-16.638 59.755-.494l.503.494c16.473 16.473 16.638 43.08.494 59.755l-.494.502L539.835 928.25c-21.965 21.965-57.44 22.184-79.674.66l-.67-.66L185.48 654.238c-16.64-16.64-16.64-43.617 0-60.257 16.473-16.473 43.079-16.638 59.755-.494l.502.494 211.317 211.317V98.608c0-23.532 19.077-42.608 42.61-42.608z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgDown" }, props, { ref }), React__namespace.createElement(SvgIcon$2y, null));
  });
  const SvgIcon$2x = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M888.889 166.667c30.722 0 55.555 24.833 55.555 55.555v555.556c0 30.722-24.833 55.555-55.555 55.555H111.11c-30.667 0-55.555-24.833-55.555-55.555V222.222c0-30.722 24.888-55.555 55.555-55.555zm0 166.666H111.11v444.445H888.89V333.333zm0-111.11H111.11v55.555H888.89v-55.556zM416.667 694.443h166.666c15.334 0 27.778-12.444 27.778-27.777 0-15.334-12.444-27.778-27.778-27.778H444.444v-55.556h138.89c15.333 0 27.777-12.444 27.777-27.777 0-15.334-12.444-27.778-27.778-27.778H444.444v-55.556h138.89c15.333 0 27.777-12.444 27.777-27.778 0-15.333-12.444-27.777-27.778-27.777H416.667c-15.334 0-27.778 12.444-27.778 27.777v222.223c0 15.333 12.444 27.777 27.778 27.777", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgEcardPay" }, props, { ref }), React__namespace.createElement(SvgIcon$2x, null));
  });
  const SvgIcon$2w = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M684.878 119.138l117.884 117.885c10.851 10.851 10.851 28.444 0 39.295l-98.237 98.237-157.18-157.18 98.238-98.237c10.85-10.85 28.444-10.85 39.295 0zm-19.648 58.943l-39.295 39.295 78.59 78.59 39.295-39.295-78.59-78.59zm195.984 655.348c15.346 0 27.786 12.44 27.786 27.785C889 876.56 876.56 889 861.214 889H138.786C123.44 889 111 876.56 111 861.214c0-15.345 12.44-27.785 27.786-27.785h722.428zM508.05 256.67l157.18 157.18L350.87 728.21l-155.605 31.12c-15.047 3.01-29.686-6.748-32.695-21.796a27.786 27.786 0 010-10.899l31.12-155.605 314.36-314.36zm0 78.59L244.883 598.426l-19.647 98.238 98.237-19.648L586.64 413.85l-78.59-78.59z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgEdit" }, props, { ref }), React__namespace.createElement(SvgIcon$2w, null));
  });
  const SvgIcon$2v = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M180.556 416.667c38.353 0 69.444 31.091 69.444 69.444s-31.091 69.445-69.444 69.445c-38.354 0-69.445-31.092-69.445-69.445 0-38.353 31.091-69.444 69.445-69.444zm319.444 0c38.353 0 69.444 31.091 69.444 69.444s-31.09 69.445-69.444 69.445c-38.353 0-69.444-31.092-69.444-69.445 0-38.353 31.09-69.444 69.444-69.444zm319.444 0c38.354 0 69.445 31.091 69.445 69.444s-31.091 69.445-69.445 69.445c-38.353 0-69.444-31.092-69.444-69.445 0-38.353 31.091-69.444 69.444-69.444z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgEllipsis" }, props, { ref }), React__namespace.createElement(SvgIcon$2v, null));
  });
  const SvgIcon$2u = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M152.667 611.001c23.012 0 41.667 18.655 41.667 41.667l-.001 152.777 152.779.001c23.012 0 41.667 18.655 41.667 41.667s-18.655 41.667-41.667 41.667h-180.54C135.88 888.78 111 863.9 111 833.209v-180.54C111 629.655 129.655 611 152.667 611zm694.446 0c23.012 0 41.667 18.655 41.667 41.667v180.54c0 30.692-24.88 55.572-55.571 55.572h-180.54c-23.013 0-41.668-18.655-41.668-41.667s18.655-41.667 41.667-41.667l152.777.001.001-152.779c0-23.012 18.655-41.667 41.667-41.667zM347.112 111c23.012 0 41.667 18.655 41.667 41.667s-18.655 41.667-41.667 41.667H194.334v152.778c0 23.012-18.655 41.667-41.667 41.667S111 370.124 111 347.112v-180.54C111 135.88 135.88 111 166.571 111h180.54zm486.097 0c30.69 0 55.571 24.88 55.571 55.571v180.54c0 23.013-18.655 41.668-41.667 41.668s-41.667-18.655-41.667-41.667V194.334H652.668c-23.012 0-41.667-18.655-41.667-41.667S629.656 111 652.668 111h180.54z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgEnlarge" }, props, { ref }), React__namespace.createElement(SvgIcon$2u, null));
  });
  const SvgIcon$2t = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M111.111 222.222v555.556H888.89V222.222H111.11zm0-55.555H888.89c30.682 0 55.555 24.873 55.555 55.555v555.556c0 30.682-24.873 55.555-55.555 55.555H111.11c-30.682 0-55.555-24.873-55.555-55.555V222.222c0-30.682 24.873-55.555 55.555-55.555zm-45.104 77.267l34.653-43.424 382.962 305.611c10.155 8.104 24.57 8.087 34.705-.042l380.96-305.527 34.759 43.34-380.961 305.527c-30.405 24.385-73.652 24.437-104.116.126L66.007 243.934z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgEnvelopO" }, props, { ref }), React__namespace.createElement(SvgIcon$2t, null));
  });
  const SvgIcon$2s = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M825.755 697.333H305.222c-15.341 0-27.778 12.437-27.778 27.778s12.437 27.778 27.778 27.778h516.613l-85.328 85.328c-10.848 10.848-10.848 28.436 0 39.284 10.848 10.848 28.436 10.848 39.284 0l130.78-130.78c13.017-13.017 13.017-34.123 0-47.14l-133.001-133c-10.848-10.849-28.436-10.849-39.284 0-10.848 10.847-10.848 28.435 0 39.283l91.47 91.47zM173.578 252.889h520.533c15.341 0 27.778 12.436 27.778 27.778 0 15.34-12.437 27.777-27.778 27.777H177.498l85.329 85.329c10.847 10.848 10.847 28.436 0 39.284-10.848 10.847-28.436 10.847-39.284 0l-130.78-130.78c-13.017-13.018-13.017-34.123 0-47.14l133-133.001c10.848-10.848 28.436-10.848 39.284 0 10.848 10.848 10.848 28.436 0 39.284l-91.469 91.469z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgExchange" }, props, { ref }), React__namespace.createElement(SvgIcon$2s, null));
  });
  const SvgIcon$2r = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M166.667 166.667v666.666h666.666V166.667H166.667zm0-55.556h666.666c30.683 0 55.556 24.873 55.556 55.556v666.666c0 30.683-24.873 55.556-55.556 55.556H166.667c-30.683 0-55.556-24.873-55.556-55.556V166.667c0-30.683 24.873-55.556 55.556-55.556z", fillRule: "nonzero" }), React__namespace.createElement("path", { d: "M583.333 222.222H750c15.341 0 27.778 12.437 27.778 27.778S765.34 277.778 750 277.778H583.333c-15.34 0-27.777-12.437-27.777-27.778s12.436-27.778 27.777-27.778z" }), React__namespace.createElement("path", { d: "M750 222.222c15.341 0 27.778 12.437 27.778 27.778v166.667c0 15.34-12.437 27.777-27.778 27.777s-27.778-12.436-27.778-27.777V250c0-15.341 12.437-27.778 27.778-27.778z" }), React__namespace.createElement("path", { d: "M602.975 436.309c-10.848 10.847-28.436 10.847-39.284 0-10.847-10.848-10.847-28.436 0-39.284l166.667-166.667c10.848-10.848 28.436-10.848 39.284 0 10.848 10.848 10.848 28.436 0 39.284L602.975 436.309z", fillRule: "nonzero" }), React__namespace.createElement("g", null, React__namespace.createElement("path", { d: "M416.667 777.778H250c-15.341 0-27.778-12.437-27.778-27.778S234.66 722.222 250 722.222h166.667c15.34 0 27.777 12.437 27.777 27.778s-12.436 27.778-27.777 27.778z" }), React__namespace.createElement("path", { d: "M250 777.778c-15.341 0-27.778-12.437-27.778-27.778V583.333c0-15.34 12.437-27.777 27.778-27.777s27.778 12.436 27.778 27.777V750c0 15.341-12.437 27.778-27.778 27.778z" }), React__namespace.createElement("path", { d: "M397.025 563.691c10.848-10.847 28.436-10.847 39.284 0 10.847 10.848 10.847 28.436 0 39.284L269.642 769.642c-10.848 10.848-28.436 10.848-39.284 0-10.848-10.848-10.848-28.436 0-39.284l166.667-166.667z", fillRule: "nonzero" }))));
  const SvgExpandO = React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgExpandO" }, props, { ref }), React__namespace.createElement(SvgIcon$2r, null));
  });
  const SvgIcon$2q = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M777.778 416.667c0 15.333-12.445 27.777-27.778 27.777-15.333 0-27.778-12.444-27.778-27.777v-99.611L594.833 444.444c-10.833 10.834-28.444 10.834-39.277 0-10.834-10.833-10.834-28.444 0-39.277l127.388-127.39h-99.61c-15.334 0-27.778-12.444-27.778-27.777s12.444-27.778 27.777-27.778H750c15.333 0 27.778 12.445 27.778 27.778v166.667zM444.444 594.833l-127.388 127.39h99.61c15.334 0 27.778 12.444 27.778 27.777S432 777.778 416.667 777.778H250c-15.333 0-27.778-12.445-27.778-27.778V583.333c0-15.333 12.445-27.777 27.778-27.777 15.333 0 27.778 12.444 27.778 27.777v99.611l127.389-127.388c10.833-10.834 28.444-10.834 39.277 0 10.834 10.833 10.834 28.444 0 39.277zm388.89-483.722H166.666c-30.723 0-55.556 24.833-55.556 55.556v666.666c0 30.723 24.833 55.556 55.556 55.556h666.666c30.723 0 55.556-24.833 55.556-55.556V166.667c0-30.723-24.833-55.556-55.556-55.556z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgExpand" }, props, { ref }), React__namespace.createElement(SvgIcon$2q, null));
  });
  const SvgIcon$2p = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M789.018 367.497C708.123 293.956 609.223 250 500 250c-109.223 0-208.123 43.956-289.018 117.497-56.716 51.56-98.894 117.15-99.854 132.007.134-2.084 1.057.722 3.4 5.63 4.46 9.334 11.517 21.04 20.65 33.934 21.377 30.18 51.159 62.929 85.304 92.62C305.41 705.539 403.067 750 500 750c96.933 0 194.591-44.462 279.518-118.311 34.145-29.692 63.927-62.441 85.304-92.62 9.133-12.894 16.19-24.601 20.65-33.935 2.166-4.537 3.118-7.278 3.355-6.123-1.817-15.761-43.698-80.505-99.809-131.514zM500 194.444c277.778 0 444.444 250 444.444 305.556C944.444 555.556 750 805.556 500 805.556c-250 0-444.444-250-444.444-305.556 0-55.556 166.666-305.556 444.444-305.556zm0 138.89c-92.047 0-166.667 74.619-166.667 166.666S407.953 666.667 500 666.667 666.667 592.047 666.667 500 592.047 333.333 500 333.333zm0 55.555c61.365 0 111.111 49.746 111.111 111.111S561.365 611.111 500 611.111 388.889 561.365 388.889 500 438.635 388.889 500 388.889z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgEyeO" }, props, { ref }), React__namespace.createElement(SvgIcon$2p, null));
  });
  const SvgIcon$2o = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500.004 166.667c-299.961 0-444.448 291.314-444.448 305.555 0 14.257 140.628 305.556 444.448 305.556 303.814 0 444.44-291.3 444.44-305.556 0-14.241-144.487-305.555-444.44-305.555zm0 472.222c-92.05 0-166.67-74.62-166.67-166.669 0-92.05 74.62-166.664 166.67-166.664 92.042 0 166.663 74.615 166.663 166.664 0 92.048-74.621 166.669-166.663 166.669zm0-250c-46.032 0-83.337 37.31-83.337 83.33 0 46.03 37.305 83.335 83.337 83.335 46.019 0 83.33-37.305 83.33-83.335 0-46.02-37.311-83.33-83.33-83.33z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgEye" }, props, { ref }), React__namespace.createElement(SvgIcon$2o, null));
  });
  const SvgIcon$2n = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M444.455 125.97c-.183-8.206 5.676-14.859 14.278-14.859h82.534c8.069 0 14.47 6.24 14.278 14.86l-11.753 525.836c-.183 8.207-7.153 14.86-14.685 14.86h-58.214c-7.927 0-14.492-6.24-14.685-14.86L444.455 125.97zM500 833.334c-30.682 0-55.556-24.873-55.556-55.555 0-30.683 24.874-55.556 55.556-55.556s55.556 24.873 55.556 55.556c0 30.682-24.874 55.555-55.556 55.555z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgFail" }, props, { ref }), React__namespace.createElement(SvgIcon$2n, null));
  });
  const SvgIcon$2m = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M777.778 111.111c30.682 0 55.555 24.873 55.555 55.556v722.222c0 30.682-24.873 55.555-55.555 55.555H222.222c-30.682 0-55.555-24.873-55.555-55.555V166.667c0-30.683 24.873-55.556 55.555-55.556H388.89v55.556H222.222v722.222h555.556V166.667H611.11V111.11h166.667zm-361.111 0c-15.342 0-27.778 12.437-27.778 27.778s12.436 27.778 27.778 27.778h166.666c15.342 0 27.778-12.437 27.778-27.778s-12.436-27.778-27.778-27.778H416.667zM541.044 500l61.567 61.566c11.334 11.334 11.334 29.71 0 41.045-11.334 11.334-29.71 11.334-41.045 0L500 541.044l-62.447 62.447c-10.848 10.848-28.435 10.848-39.283 0l-1.76-1.76c-10.849-10.849-10.849-28.437 0-39.284L458.955 500l-61.567-61.566c-11.334-11.334-11.334-29.71 0-41.045 11.334-11.334 29.71-11.334 41.045 0L500 458.956l62.447-62.447c10.847-10.848 28.435-10.848 39.283 0l1.76 1.76c10.849 10.849 10.849 28.436 0 39.284L541.045 500zM416.667 55.556h166.666c46.024 0 83.334 37.31 83.334 83.333 0 46.024-37.31 83.333-83.334 83.333H416.667c-46.024 0-83.334-37.31-83.334-83.333 0-46.024 37.31-83.333 83.334-83.333z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgFailure" }, props, { ref }), React__namespace.createElement(SvgIcon$2m, null));
  });
  const SvgIcon$2l = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M527.778 528.587l249.726-361.92H222.496l249.726 361.92V812.99l55.556 33.334V528.587zm-111.111 17.307L164.748 180.797a44.444 44.444 0 01-7.863-25.241c0-24.546 19.899-44.445 44.445-44.445h597.34c9.017 0 17.82 2.743 25.241 7.863 20.204 13.94 25.28 41.62 11.34 61.823L583.334 545.894v398.55l-166.666-100v-298.55z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgFilterO" }, props, { ref }), React__namespace.createElement(SvgIcon$2l, null));
  });
  const SvgIcon$2k = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M861.111 642.558c0-66.735-25.532-130.506-68.479-189.014a459.093 459.093 0 00-46.903-54.382c-19.993 26.262-39.005 44.825-53.328 55.8-20.667 15.838-49.808-2.908-43.965-28.281 28.491-123.725-12.844-215.837-100.727-283.896-24.55-19.013-50.981-34.581-77.4-46.876a462.71 462.71 0 00-2.338-1.08c-15.773 103.573-63.72 161.394-172.462 246.18l-2.73 2.129C175.722 434.402 138.89 487.37 138.89 611.11c0 119.592 79.99 216.337 215.203 278.865-43.746-70.704-57.172-138.59-43.4-202.671 12.043-56.036 43.86-105.003 88.944-147.105 19.999-18.677 41.334-34.773 62.688-48.33 12.934-8.21 23.173-13.836 29.403-16.86 25.638-12.443 51.151 17.18 35.045 40.69-.301.44-1.561 2.819-3.067 6.96-14.856 40.84-.39 96.402 73.867 167.554 56.44 57.67 65.688 128.57 30.058 208.351 157.309-75.226 233.481-161 233.481-256.007zM717.898 342.264c8.942-13.706 27.734-16.75 40.546-6.568 5.35 4.252 14.16 11.967 25.282 22.91a514.143 514.143 0 0153.692 62.064c49.383 67.278 79.249 141.871 79.249 221.888 0 131.126-106.267 239.707-312.352 327.444l-10.88 2.22h-23.922c-22.395 0-35.584-25.14-22.855-43.566 58.75-85.042 60.977-148.732 11.846-198.953-64.362-61.654-92.915-119.757-95.313-170.663a360.515 360.515 0 00-25.637 21.763c-37.446 34.97-63.175 74.566-72.547 118.174-14.442 67.202 10.16 142.307 85.711 226.973 15.975 17.902 3.268 46.272-20.726 46.272h-13.325l-8.784-1.425C209.636 904.715 83.333 778.71 83.333 611.11c0-144.79 46.07-211.041 175.287-311.786l2.729-2.127c109.914-85.7 147.051-135.246 155.4-243.773 1.368-17.786 18.907-29.69 35.942-24.395 8.643 2.687 22.946 8.08 41.06 16.51 29.958 13.944 59.905 31.582 87.974 53.32 81.648 63.231 130.492 146.697 131.229 250.786 1.66-2.416 3.309-4.877 4.944-7.382z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgFireO" }, props, { ref }), React__namespace.createElement(SvgIcon$2k, null));
  });
  const SvgIcon$2j = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M444.444 55.556s296.718 92.243 231.061 377.358c0 0 32.828-25.157 65.657-75.472 0 0 147.727 117.4 147.727 285.116 0 117.4-98.485 218.029-295.455 301.886h-23.921c65.656-95.038 68.392-173.305 8.207-234.8C446.407 583.857 503.856 500 503.856 500S364.859 567.46 337.85 693.14c-14.5 67.468 3.273 151.712 92.142 251.304h-13.325C250 888.89 111.11 778.826 111.11 611.111c0-313.405 310.68-261.07 333.333-555.555z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgFire" }, props, { ref }), React__namespace.createElement(SvgIcon$2j, null));
  });
  const SvgIcon$2i = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M698.394 376.237c-38.342-10.104-68.934-26.99-105.894-54.64-7.005-5.24-13.757-10.465-26.564-20.438-41.789-32.385-65.875-46.556-101.391-56.29-38.868-10.654-79.545-14.963-122.281-12.877l-73.558 274.521c46.43-1.4 90.66 3.051 132.6 13.472 43.07 10.701 74.73 29.312 114.792 61.935 4.837 3.94 9.706 7.983 18.813 15.572 41.073 34.104 64.078 47.857 101.506 56.541 30.656 7.113 53.331 8.304 68.723 5.44l72.698-271.314c-26.523-.988-53.034-4.963-79.444-11.922zm-447.07 196.016l-69.14 252.476c-4.727 17.262-22.554 27.424-39.816 22.697-17.263-4.727-27.425-22.554-22.697-39.816l61.946-226.208-.083.016 98.124-366.202c7.29-27.205 31.314-46.588 59.445-47.962 49.495-2.416 97.02 2.619 142.575 15.105 108.989 29.873 145.918 108.194 233.232 131.202 49.97 13.168 99.923 13.369 149.857.6L759.883 705.595c-30.597 21.983-76.635 25.842-138.115 11.577-115.819-26.873-143.627-111.31-236.091-134.284-41.684-10.357-86.469-13.902-134.353-10.634z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgFlagO" }, props, { ref }), React__namespace.createElement(SvgIcon$2i, null));
  });
  const SvgIcon$2h = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M289.86 437.776c7.303 77.307 69.954 137.702 147.476 142.166l57.433 3.307 71.826-3.79c79.64-4.2 143.518-67.368 148.608-146.957 5.037-78.759 7.704-138.816 8.058-179.248-23.564 12.498-34.332 17.553-49.16 21.962-34.186 10.167-68.026 5.319-90.45-26.608-1.67-2.376-14.163-20.38-18.346-26.316-8.004-11.358-15.119-21.11-22.176-30.284-13.795-17.932-26.308-32.202-37.242-42.196-7.406-6.77-12.159-9.805-11.16-10.665.288 1.815-11.506 11.764-25.34 29.468-16.582 21.22-33.538 49.43-44.206 71.894-18.298 38.53-55.179 47.882-91.898 38.099-15.969-4.254-26.487-9.16-54.175-23.519-.499 36.852 2.92 99.778 10.753 182.687zm238.987 199.308V887.35h-55.555V637.66l-39.15-2.255c-104.917-6.041-189.707-87.778-199.59-192.404-13.004-137.651-14.744-218.999-5.222-244.044 19.732-51.894 125.398 60.398 145.667 17.72 20.268-42.68 74.824-132.261 119.638-133.335 44.813-1.073 107.106 94.365 134.477 133.334 27.371 38.97 143.015-89.638 148.727-8.818 2.59 36.65.192 112.713-7.194 228.19-6.89 107.714-93.34 193.204-201.123 198.89l-40.675 2.146zm-108.912 223.88l-52.511 18.137c-37.515-108.613-78.153-158.295-117.339-156.825-10.456-.005-24.077 7.617-38.24 21.311-5.413 5.235-10.465 10.914-15.092 16.735-2.51 3.158-7.373 9.78-7.708 10.18l-42.618-35.639c-17.592 21.038 14.428-19.25 26.8-31.214 23.539-22.76 48.88-36.94 75.814-36.909 71.053-2.702 126.137 64.64 170.894 194.224zm81.127-.141c15.341 0 27.778 12.436 27.778 27.778 0 15.34-12.437 27.777-27.778 27.777s-27.778-12.436-27.778-27.777c0-15.342 12.437-27.778 27.778-27.778zM394.567 844.98c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.778 27.778c-15.34 0-27.777-12.437-27.777-27.778s12.436-27.778 27.777-27.778zm362.038-178.24c26.933-.031 52.274 14.148 75.813 36.91 11.455 11.076 39.755 46.435 29.922 34.917a27.642 27.642 0 014.661 15.406c0 15.342-12.436 27.778-27.778 27.778-9.218 0-17.387-4.49-22.44-11.402l-.183.153c-.334-.4-5.198-7.022-7.708-10.18-4.627-5.821-9.678-11.5-15.092-16.735-14.163-13.694-27.783-21.316-38.24-21.311-39.186-1.47-79.824 48.212-117.338 156.825l-.013-.004c-3.331 11.606-14.025 20.099-26.703 20.099-15.34 0-27.777-12.437-27.777-27.778a27.7 27.7 0 012.027-10.438l-.046-.016c44.758-129.584 99.842-196.926 170.895-194.224zm-589.938 59.478c15.34 0 27.777 12.436 27.777 27.778 0 15.34-12.436 27.777-27.777 27.777-15.342 0-27.778-12.436-27.778-27.777 0-15.342 12.436-27.778 27.778-27.778z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgFlowerO" }, props, { ref }), React__namespace.createElement(SvgIcon$2h, null));
  });
  const SvgIcon$2g = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M833.224 111c30.683 0 55.556 24.873 55.556 55.556v666.668c0 30.683-24.873 55.556-55.556 55.556H166.556c-30.683 0-55.556-24.873-55.556-55.556V166.556C111 135.873 135.873 111 166.556 111h666.668zm0 55.556H166.556v666.668h666.668V166.556zM694.335 277.667c15.341 0 27.778 12.437 27.778 27.778s-12.437 27.778-27.778 27.778H527.668v361.112c0 15.341-12.437 27.778-27.778 27.778s-27.778-12.437-27.778-27.778V333.223H305.445c-15.341 0-27.778-12.437-27.778-27.778s12.437-27.778 27.778-27.778h388.89z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgFontO" }, props, { ref }), React__namespace.createElement(SvgIcon$2g, null));
  });
  const SvgIcon$2f = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M833.224 111c30.683 0 55.556 24.873 55.556 55.556v666.668c0 30.683-24.873 55.556-55.556 55.556H166.556c-30.683 0-55.556-24.873-55.556-55.556V166.556C111 135.873 135.873 111 166.556 111h666.668zM694.335 277.667h-388.89c-15.341 0-27.778 12.437-27.778 27.778 0 13.637 9.827 24.978 22.785 27.33l4.993.448h166.667v361.112c0 15.341 12.437 27.778 27.778 27.778 13.637 0 24.978-9.827 27.33-22.785l.448-4.993V333.223h166.667c15.341 0 27.778-12.437 27.778-27.778 0-13.637-9.827-24.978-22.785-27.33l-4.993-.448z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgFont" }, props, { ref }), React__namespace.createElement(SvgIcon$2f, null));
  });
  const SvgIcon$2e = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 55.556c245.46 0 444.444 198.984 444.444 444.444S745.46 944.444 500 944.444 55.556 745.46 55.556 500 254.54 55.556 500 55.556zm0 55.555c-214.777 0-388.889 174.112-388.889 388.889 0 214.777 174.112 388.889 388.889 388.889 214.777 0 388.889-174.112 388.889-388.889 0-214.777-174.112-388.889-388.889-388.889zM393.991 289.008c13.808 0 25 11.193 25 25v59.724h59.6c39.96 0 72.523 31.065 72.523 69.158v167.265c0 38.074-32.569 69.132-72.523 69.132h-160.51c-39.934 0-72.523-31.065-72.523-69.132V442.89c0-38.087 32.582-69.158 72.522-69.158h50.91l.001-59.724c0-13.669 10.97-24.776 24.587-24.996zm299.8 84.724c36.866 0 66.3 31.229 66.3 68.8v80.45c0 13.807-11.193 25-25 25h-44.95c-13.807 0-25-11.193-25-25s11.193-25 25-25h19.95v-55.45c0-10.597-7.732-18.8-16.3-18.8h-48.575c-8.577 0-16.325 8.213-16.325 18.8v182.775c0 13.807-11.193 25-25 25s-25-11.193-25-25V442.532c0-37.57 29.46-68.8 66.325-68.8zm-324.8 173.796h-67.878v62.627c0 6.774 7.137 13.577 16.967 13.577h50.91v-76.204zm126.567 0H418.99v76.204h59.6c9.845 0 16.967-6.79 16.967-13.577v-62.627zM368.99 429.287h-50.91c-9.833 0-16.967 6.804-16.967 13.603l-.001 54.638h67.878v-68.241zm109.6 0h-59.6v68.24h76.567V442.89c0-6.811-7.12-13.603-16.967-13.603z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgFreePostage" }, props, { ref }), React__namespace.createElement(SvgIcon$2e, null));
  });
  const SvgIcon$2d = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M315.677 417.786v55.959c-115.486 15.418-204.566 114.317-204.566 234.022l.009-.988c.035.574.053 1.154.053 1.737 0 15.341-12.436 27.778-27.778 27.778-15.34 0-27.777-12.437-27.777-27.778 0-.25.003-.5.01-.75h-.072c0-150.424 113.874-274.252 260.12-289.98zM313.629 195.7l.46.004c15.129.245 27.318 12.586 27.318 27.774 0 15.341-12.437 27.778-27.778 27.778-46.024 0-83.333 37.31-83.333 83.333 0 46.024 37.31 83.334 83.333 83.334v55.555c-76.706 0-138.889-62.182-138.889-138.889 0-76.706 62.183-138.889 138.89-138.889zm239.603 275.432c184.095 0 333.333 149.239 333.333 333.334H831.01c0-153.413-124.366-277.778-277.778-277.778l-4.594.037c-151.293 2.453-273.184 125.862-273.184 277.74H219.9c0-184.094 149.238-333.333 333.333-333.333zm-239.603-53.21c15.341 0 27.778 12.437 27.778 27.778 0 15.342-12.437 27.778-27.778 27.778s-27.778-12.436-27.778-27.778c0-15.34 12.437-27.777 27.778-27.777zm-65.953 358.766c15.342 0 27.778 12.436 27.778 27.778 0 15.34-12.436 27.777-27.778 27.777-15.34 0-27.777-12.436-27.777-27.777 0-15.342 12.436-27.778 27.777-27.778zm611.111 0c15.342 0 27.778 12.436 27.778 27.778 0 15.34-12.436 27.777-27.778 27.777-15.34 0-27.777-12.436-27.777-27.777 0-15.342 12.436-27.778 27.777-27.778zM554.724 444.444c76.706 0 138.889-62.182 138.889-138.888 0-76.707-62.183-138.89-138.889-138.89-76.706 0-138.889 62.183-138.889 138.89 0 76.706 62.183 138.888 138.889 138.888zm0 55.556c-107.389 0-194.444-87.056-194.444-194.444 0-107.39 87.055-194.445 194.444-194.445 107.389 0 194.444 87.056 194.444 194.445C749.168 412.944 662.113 500 554.724 500z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgFriendsO" }, props, { ref }), React__namespace.createElement(SvgIcon$2d, null));
  });
  const SvgIcon$2c = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M612.603 111.111c107.389 0 194.445 87.056 194.445 194.445 0 77.966-45.888 145.215-112.13 176.212v-.013c143.529 37.168 249.526 167.56 249.526 322.71l-.003-.46.003.46c0 15.34-12.436 27.777-27.777 27.777H305.556l-.46-.003c-15.13-.246-27.318-12.587-27.318-27.774l.044-5.513c2.488-153.41 108.613-281.628 251.414-317.691l.002.012c-65.676-31.214-111.08-98.164-111.08-175.717 0-107.39 87.056-194.445 194.445-194.445zm-222.47 64.633c9.076 0 17.978.746 26.648 2.181-25.387 36.116-40.289 80.133-40.289 127.63 0 65.807 28.871 126.407 76.44 167.758-120.969 52.685-205.463 168.814-215.761 303.372l-102.912.002-.383-.003c-12.607-.205-22.765-10.489-22.765-23.145l.037-4.594c2.073-127.843 90.511-234.691 209.513-264.743l.001.01c-54.73-26.01-92.567-81.802-92.567-146.43 0-89.491 72.547-162.038 162.037-162.038z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgFriends" }, props, { ref }), React__namespace.createElement(SvgIcon$2c, null));
  });
  const SvgIcon$2b = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M817.895 111.111c11.38 0 21.61 6.942 25.814 17.518L942.7 377.676a27.778 27.778 0 01-5.01 28.668L519.905 878.468c-10.167 11.489-27.722 12.56-39.21 2.394-.87-.77-1.691-1.593-2.458-2.465L63.294 406.237a27.778 27.778 0 01-5.016-28.423l97.052-249.012a27.778 27.778 0 0125.882-17.69h636.683zM627.191 416.666h-265.6l137.494 340.032 128.106-340.032zm227.18 0H686.558l-124.418 330.24 292.23-330.24zm-552.707 0H146.42L433.972 743.87 301.664 416.666zm60.282-250H200.2l-75.786 194.445h180.925l56.608-194.445zm194.6 0H419.808l-56.607 194.445H626.49l-69.943-194.445zm242.499 0H615.587l69.942 194.445h190.803l-77.287-194.444z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgGemO" }, props, { ref }), React__namespace.createElement(SvgIcon$2b, null));
  });
  const SvgIcon$2a = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M630.638 416.666l-131.53 474.682-140.614-474.682h272.144zm297.916 0l-349.801 395.3 109.534-395.3h240.267zm-628.002 0L416.53 808.18 72.46 416.666h228.092zm77.575-305.555l-72.788 250H64.789l97.312-249.681a.5.5 0 01.466-.319h215.56zm163.57 0l85.482 250H363.202l72.788-250h105.707zm294.71 0a.5.5 0 01.464.315l99.245 249.685H685.892l-85.482-250h235.997z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgGem" }, props, { ref }), React__namespace.createElement(SvgIcon$2a, null));
  });
  const SvgIcon$29 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "nonzero" }, React__namespace.createElement("path", { d: "M111.111 222.222v555.556H888.89V222.222H111.11zm0-55.555H888.89c30.682 0 55.555 24.873 55.555 55.555v555.556c0 30.682-24.873 55.555-55.555 55.555H111.11c-30.682 0-55.555-24.873-55.555-55.555V222.222c0-30.682 24.873-55.555 55.555-55.555z" }), React__namespace.createElement("path", { d: "M583.579 534.542l71.7 35.85c13.722 6.862 19.284 23.547 12.423 37.269-6.86 13.721-23.546 19.283-37.267 12.422l-102.657-51.328v264.578h-55.556V568.755l-102.657 51.328c-13.721 6.861-30.407 1.3-37.267-12.422-6.861-13.722-1.3-30.407 12.422-37.268l71.94-35.97c-32.652-6.872-58.478-17.21-72.136-30.08-41.277-38.9-41.277-103.851-.591-144.537 19.603-19.603 45.748-30.44 73.47-30.44 19.673 0 38.544 5.453 54.82 15.594V222.222h55.555v123.244c16.456-10.465 35.626-16.1 55.623-16.1 27.722 0 53.868 10.837 73.47 30.44 40.687 40.686 40.687 105.637-.59 144.536-13.737 12.946-39.783 23.329-72.702 30.2zM451.588 399.09c-9.19-9.19-21.198-14.168-34.185-14.168-12.983 0-24.999 4.98-34.186 14.168-18.794 18.794-18.794 47.668-.591 64.823 9.059 8.537 44.212 18.186 87.947 22.325-3.51-43.209-11.421-79.649-18.985-87.148zm97.628 0c-7.563 7.5-15.474 43.94-18.984 87.148 43.735-4.139 78.888-13.788 87.946-22.325 18.203-17.155 18.203-46.03-.59-64.823-9.188-9.188-21.204-14.168-34.187-14.168-12.987 0-24.994 4.978-34.185 14.168z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgGiftCardO" }, props, { ref }), React__namespace.createElement(SvgIcon$29, null));
  });
  const SvgIcon$28 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M583.579 534.542c32.919-6.871 58.965-17.254 72.702-30.2 41.277-38.9 41.277-103.85.59-144.536-19.602-19.603-45.748-30.44-73.47-30.44-19.997 0-39.167 5.635-55.623 16.1v-178.8h-55.556V344.96c-16.275-10.14-35.146-15.595-54.819-15.595-27.722 0-53.867 10.838-73.47 30.44-40.686 40.687-40.686 105.638.59 144.537 13.659 12.871 39.485 23.21 72.136 30.081l-71.939 35.97c-13.721 6.86-19.283 23.546-12.422 37.268 6.86 13.721 23.546 19.283 37.267 12.422l102.657-51.328v264.578h55.556V568.755l102.657 51.328c13.721 6.861 30.407 1.3 37.267-12.422 6.861-13.722 1.3-30.407-12.422-37.268l-71.701-35.85zM111.11 166.667H888.89c30.682 0 55.555 24.873 55.555 55.555v555.556c0 30.682-24.873 55.555-55.555 55.555H111.11c-30.682 0-55.555-24.873-55.555-55.555V222.222c0-30.682 24.873-55.555 55.555-55.555zm438.105 232.422c9.19-9.19 21.198-14.168 34.185-14.168 12.983 0 24.999 4.98 34.187 14.168 18.793 18.794 18.793 47.668.59 64.823-9.058 8.537-44.211 18.186-87.946 22.325 3.51-43.209 11.42-79.649 18.984-87.148zm-97.628 0c7.564 7.5 15.474 43.94 18.985 87.148-43.735-4.139-78.888-13.788-87.947-22.325-18.203-17.155-18.203-46.03.59-64.823 9.188-9.188 21.204-14.168 34.187-14.168 12.987 0 24.994 4.978 34.185 14.168z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgGiftCard" }, props, { ref }), React__namespace.createElement(SvgIcon$28, null));
  });
  const SvgIcon$27 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M222.222 888.889c-30.682 0-55.555-24.873-55.555-55.556V500c-30.683 0-55.556-24.873-55.556-55.556V277.778c0-30.683 24.873-55.556 55.556-55.556h86.112c12.869-63.396 68.917-111.11 136.11-111.11 45.435 0 85.774 21.816 111.114 55.545 25.334-33.73 65.673-55.546 111.108-55.546 67.193 0 123.241 47.715 136.11 111.11l86.112.001c30.376 0 55.058 24.378 55.548 54.637l.008.919v166.666c0 30.376-24.378 55.058-54.637 55.549l-.919.007v333.333c0 30.376-24.378 55.058-54.637 55.548l-.918.008H222.222zm333.333-611.112h-111.11v555.556h111.11V277.777zM388.89 500H222.222v333.333H388.89V500zm388.889 0H611.11v333.333h166.667V500zm-388.89-222.222H166.668v166.666h222.222V277.778zm444.445 0H611.111v166.666h222.222V277.778zM611.111 166.667c-36.284 0-67.151 23.189-78.591 55.555h157.183c-11.44-32.366-42.308-55.555-78.592-55.555zm-222.222 0c-36.284 0-67.152 23.189-78.592 55.555H467.48c-11.44-32.366-42.307-55.555-78.591-55.555z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgGiftO" }, props, { ref }), React__namespace.createElement(SvgIcon$27, null));
  });
  const SvgIcon$26 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M467.48 222.222c-11.44-32.366-42.307-55.555-78.591-55.555-36.284 0-67.152 23.189-78.592 55.555H467.48zm-214.702 0c12.869-63.395 68.918-111.11 136.11-111.11 45.434 0 85.772 21.814 111.112 55.541 25.34-33.727 65.678-55.542 111.111-55.542 67.193 0 123.242 47.716 136.11 111.111h86.112c30.683 0 55.556 24.873 55.556 55.556v166.666c0 30.683-24.873 55.556-55.556 55.556v333.333c0 30.683-24.873 55.556-55.555 55.556H222.222c-30.682 0-55.555-24.873-55.555-55.556V500c-30.683 0-55.556-24.873-55.556-55.556V277.778c0-30.683 24.873-55.556 55.556-55.556h86.111zm279.742 0h157.183c-11.44-32.366-42.308-55.555-78.592-55.555s-67.151 23.189-78.591 55.555zm-88.076 0V888.89h111.112V222.222H444.444z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgGift" }, props, { ref }), React__namespace.createElement(SvgIcon$26, null));
  });
  const SvgIcon$25 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M444.05 416.667l-79.964-79.964c-10.848-10.848-10.848-28.435 0-39.283 10.848-10.848 28.436-10.848 39.284 0l97.617 97.617 97.617-97.617c10.848-10.848 28.436-10.848 39.284 0 10.848 10.848 10.848 28.435 0 39.283l-79.964 79.964h80.965c15.341 0 27.778 12.436 27.778 27.777 0 15.342-12.437 27.778-27.778 27.778H527.778v83.334h111.11c15.342 0 27.779 12.436 27.779 27.777 0 15.342-12.437 27.778-27.778 27.778H527.778v111.111C527.778 737.563 515.34 750 500 750s-27.778-12.437-27.778-27.778v-111.11h-111.11c-15.342 0-27.779-12.437-27.779-27.779 0-15.34 12.437-27.777 27.778-27.777h111.111v-83.334h-111.11c-15.342 0-27.779-12.436-27.779-27.778 0-15.34 12.437-27.777 27.778-27.777h82.939zM500 888.889c214.777 0 388.889-174.112 388.889-388.889 0-214.777-174.112-388.889-388.889-388.889-214.777 0-388.889 174.112-388.889 388.889 0 214.777 174.112 388.889 388.889 388.889zm0 55.555C254.54 944.444 55.556 745.46 55.556 500S254.54 55.556 500 55.556 944.444 254.54 944.444 500 745.46 944.444 500 944.444z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgGoldCoinO" }, props, { ref }), React__namespace.createElement(SvgIcon$25, null));
  });
  const SvgIcon$24 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 944.444C254.54 944.444 55.556 745.46 55.556 500S254.54 55.556 500 55.556 944.444 254.54 944.444 500 745.46 944.444 500 944.444zm-55.95-527.777H361.11c-15.341 0-27.778 12.436-27.778 27.777 0 15.342 12.437 27.778 27.778 27.778h111.111v83.334h-111.11c-15.342 0-27.779 12.436-27.779 27.777 0 15.342 12.437 27.778 27.778 27.778h111.111v111.111C472.222 737.563 484.66 750 500 750s27.778-12.437 27.778-27.778v-111.11h111.11c15.342 0 27.779-12.437 27.779-27.779 0-15.34-12.437-27.777-27.778-27.777H527.778v-83.334h111.11c15.342 0 27.779-12.436 27.779-27.778 0-15.34-12.437-27.777-27.778-27.777h-80.965l79.964-79.964c10.848-10.848 10.848-28.435 0-39.283-10.848-10.848-28.436-10.848-39.284 0l-97.617 97.617-97.617-97.617c-10.848-10.848-28.436-10.848-39.284 0-10.848 10.848-10.848 28.435 0 39.283l79.964 79.964z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgGoldCoin" }, props, { ref }), React__namespace.createElement(SvgIcon$24, null));
  });
  const SvgIcon$23 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M333.223 388.913c16.865-6.098 29.055-11.298 36.57-15.6 21.001-12.024 38.814-28.398 53.438-49.122 22.191-31.447 26.324-45.937 50.41-133.953 1.582-5.784 4.766-13.686 9.55-23.706 22.138-37.106 53.653-55.617 94.544-55.532 39.504 0 71.104 18.51 94.8 55.532 5.906 10.22 10.087 21.634 12.542 34.245 2.456 12.61 2.456 27.09 0 43.44l-43.731 152.608c-.774 2.422-.774 4.191 0 5.309.834 1.204 2.051 1.806 3.652 1.806h132.855l-.147.309h17.324c51.562 0 93.75 40.625 93.75 92.187 0 7.813-1.563 15.625-3.125 23.438l-46.757 298.593c-9.375 40.625-46.875 70.313-90.625 70.313H166.556c-30.683 0-55.556-24.873-55.556-55.556v-388.89c0-30.682 24.873-55.555 55.556-55.555h166.667v.134zm0 61.369v382.942h414.41c14.063 0 26.563-9.375 29.688-23.437 37.269-199.005 55.903-302.934 55.903-311.788 0-17.188-14.062-31.25-31.25-31.25h-53.921l-.274.578H646.59c-22.307 0-40.007-7.664-53.1-22.993-19.639-22.992-18.442-43.203-11.299-68.864 16.27-58.445 30.048-109.04 41.338-151.787-.327-29.99-14.106-46.885-41.338-50.685-27.231-3.8-45.234 11.196-54.009 44.989l-23.293 80.71c-26.646 71.927-78.748 120.472-156.305 145.637l-15.362 5.948zM166.556 833.224h111.111v-388.89H166.556v388.89z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgGoodJobO" }, props, { ref }), React__namespace.createElement(SvgIcon$23, null));
  });
  const SvgIcon$22 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M333.223 888.78V388.913c16.865-6.098 29.055-11.298 36.57-15.6 21.001-12.024 38.814-28.398 53.438-49.122 22.191-31.447 26.324-45.937 50.41-133.953 1.582-5.784 4.766-13.686 9.55-23.706 22.138-37.106 53.653-55.617 94.544-55.532 39.504 0 71.104 18.51 94.8 55.532 5.906 10.22 10.087 21.634 12.542 34.245 2.456 12.61 2.456 27.09 0 43.44l-43.731 152.608c-.774 2.422-.774 4.191 0 5.309.834 1.204 2.051 1.806 3.652 1.806h132.855l-.147.309h17.324c51.562 0 93.75 40.625 93.75 92.187 0 7.813-1.563 15.625-3.125 23.438l-46.757 298.593c-9.375 40.625-46.875 70.313-90.625 70.313h-415.05zm-55.556 0H166.556c-30.683 0-55.556-24.873-55.556-55.556v-388.89c0-30.682 24.873-55.555 55.556-55.555h111.111V888.78z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgGoodJob" }, props, { ref }), React__namespace.createElement(SvgIcon$22, null));
  });
  const SvgIcon$21 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "nonzero" }, React__namespace.createElement("path", { d: "M718.526 833.225l-3.465.108c1.156 0 2.312-.036 3.465-.108zm0 0c-1.153.072-2.309.108-3.465.108l3.465-.108zM749.98 500l-10.72-225.688c-1.83-29.28-26.111-52.09-55.448-52.09H253.472c-29.337 0-53.617 22.81-55.447 52.09l-31.25 500a55.556 55.556 0 00-.108 3.466c0 30.682 24.873 55.555 55.555 55.555H500v-55.555H222.222l31.25-500h430.339l10.675 224.858L749.979 500zm0 0l-10.72-225.688c-1.83-29.28-26.111-52.09-55.448-52.09H253.472c-29.337 0-53.617 22.81-55.447 52.09l-31.25 500a55.556 55.556 0 00-.108 3.466c0 30.682 24.873 55.555 55.555 55.555H500v-55.555H222.222l31.25-500h430.339l10.675 224.858L749.979 500z" }), React__namespace.createElement("path", { d: "M780.176 583.333c60.331 0 108.713 51.362 108.713 113.716-.042 2.533-.043 2.63-.133 4.178l.016.988.003.215c0 10.965-2.292 22.106-6.514 33.416l-.092.264-.186.528c-1.598 4.493-3.689 9.214-8.669 18.003 1.358-1.91 1.405-1.977 1.584-2.3l.018-.034-.001.002c.01-.022.147-.273.889-1.632l-.623 1.192c.124-.199.124-.199-.435.93-1.306 2.59-2.598 4.987-3.458 6.24a201.646 201.646 0 01-6.382 10.427c-12.522 19.168-29.597 38.916-50.17 59.053-14.38 14.077-29.668 27.564-45.158 40.234a697.775 697.775 0 01-7.262 5.84l-.68.541c-8.514 6.758-17.338 13.572-13.821 10.761-7.402 5.865-16.474 9.036-25.826 9.036-9.072 0-17.881-2.931-25.32-8.615l-.462-.357.117.093c3.048 2.433-4.37-3.274-12.222-9.466l-1.026-.81a749.72 749.72 0 01-8.64-6.914c-15.459-12.612-30.702-26.037-45.043-40.066-21.208-20.746-38.687-41.104-51.294-60.89-5.743-9.013-10.44-17.866-14.048-26.72l-.25-.637-.051-.136-.097-.259c-5.165-13.031-7.883-25.638-7.883-37.75-.158-2.117-.214-3.482-.214-5.355 0-62.376 48.365-113.716 108.712-113.716 20.736 0 40.776 6.301 57.948 17.725 17.15-11.424 37.201-17.725 57.96-17.725zm0 55.556c-13.857 0-27.34 6.173-37.37 17.22l-20.513 22.593-20.57-22.543c-10.12-11.088-23.627-17.27-37.455-17.27-28.899 0-53.157 25.75-53.157 58.16 0 .104.052 2.363.156 6.779.03-.316.031-.339.053-1.202.006 4.383 1.254 10.17 3.964 16.999.256.67.346.904.397 1.042 2.206 5.344 5.31 11.171 9.27 17.386 9.995 15.685 24.868 33.007 43.291 51.03 13.038 12.754 27.063 25.105 41.314 36.732 3.4 2.774 8.18 6.555 12.402 9.86 4.223-3.317 9.017-7.12 12.446-9.924 14.296-11.694 28.38-24.118 41.47-36.932 17.929-17.55 32.513-34.417 42.521-49.737a161.58 161.58 0 003.154-5.03l.528-.88c.54-.902 1.112-1.875 1.739-2.95.266-.412.413-.684 1.237-2.243.507-1.084.507-1.084.993-2.014l.922-1.688a61.703 61.703 0 003.01-7.206c2.196-5.894 3.178-10.51 3.239-14.268l.003-.373v.041l.001.046.001.01v-.265l-.016-2.77c.05-.87.05-.87.084-1.42.024-.448.034-.62.038-.756l.003-.098.002-.169c0-32.39-24.275-58.16-53.157-58.16zM500 777.778c15.341 0 27.778 12.436 27.778 27.778 0 15.34-12.437 27.777-27.778 27.777s-27.778-12.436-27.778-27.777c0-15.342 12.437-27.778 27.778-27.778zm222.222-305.556C737.563 472.222 750 484.66 750 500s-12.437 27.778-27.778 27.778S694.444 515.34 694.444 500s12.437-27.778 27.778-27.778zm-250-416.666c94.924 0 171.875 76.95 171.875 171.875h-55.555c0-64.242-52.078-116.32-116.32-116.32-64.241 0-116.32 52.078-116.32 116.32h-55.555c0-94.924 76.951-171.875 171.875-171.875z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgGoodsCollectO" }, props, { ref }), React__namespace.createElement(SvgIcon$21, null));
  });
  const SvgIcon$20 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M804.373 666.667c44.598 0 80.935 38.556 80.935 85.938 0 1.571-.113 2.891-.164 3.872.025.415.05.943.05 1.508 0 7.443-1.654 15.388-4.988 24.339-1.2 3.47-2.729 7.052-4.674 10.886-.084.11-.24.37-.467.78-.278.503-.505 1.006-.745 1.508-.834 1.597-1.743 3.445-2.968 5.343-32.17 56.446-113.13 116.072-116.59 118.838-2.539 2.011-5.545 3.03-8.576 3.03-3.019 0-5.974-.956-8.5-2.942-4.042-3.219-98.997-72.852-123.664-133.383-.126-.314-.24-.654-.378-1.006-3.903-9.83-5.899-19.033-5.899-27.418 0-.415.025-.78.063-1.182a32.004 32.004 0 01-.278-4.173c0-47.407 36.325-85.938 80.935-85.938 22.002 0 42.842 9.743 57.973 26.324 15.056-16.581 35.896-26.324 57.935-26.324zm-330.523-500c-52.783 0-97.355 35.157-111.576 83.332h223.152c-14.22-48.175-58.793-83.332-111.576-83.332zm87.989 638.781l.009.021-.044-.112.035.091-.047-.118.01.027c.237.637.237.637.672 1.743 4.33 10.628 9.8 20.939 16.396 31.289 10.692 16.781 24.26 33.585 40.227 50.5H222.222c-30.682 0-55.555-24.873-55.555-55.556 0-1.156.036-2.311.108-3.465L199.76 302.09c1.83-29.28 26.11-52.09 55.447-52.09h49.93c15.208-78.245 83.496-137.53 165.87-138.866l2.842-.023c83.641 0 153.328 59.746 168.713 138.888l67.29.001c29.336 0 53.617 22.81 55.447 52.09l19.407 310.512c-13.348 2.036-26.245 6.12-38.299 12.036-17.895-8.78-37.63-13.527-57.943-13.527-76.07 0-136.49 64.135-136.49 141.494 0 2.297.058 4.075.217 6.128.108 15.28 3.409 30.699 9.42 46.137l.162.411-.025-.066a35.23 35.23 0 01-.09-.243l-.003-.01c.02.05.112.287.299.776l.03.082-.03-.078-.002-.005-.031-.078-.035-.09-.048-.12z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgGoodsCollect" }, props, { ref }), React__namespace.createElement(SvgIcon$20, null));
  });
  const SvgIcon$1$ = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M166 140.971C166 110.06 191.32 85 221.693 85h555.28c30.76 0 55.694 24.94 55.694 55.971v721.391c0 30.912-25.32 55.971-55.693 55.971H221.693c-30.758 0-55.693-24.94-55.693-55.971v-721.39zm138.889 55.14c-15.341 0-27.778 12.437-27.778 27.778v277.778c0 15.34 12.437 27.777 27.778 27.777h388.889c15.341 0 27.778-12.436 27.778-27.777V223.889c0-15.341-12.437-27.778-27.778-27.778h-388.89zm0 444.445c-15.341 0-27.778 12.436-27.778 27.777 0 15.342 12.437 27.778 27.778 27.778h388.889c15.341 0 27.778-12.436 27.778-27.778 0-15.34-12.437-27.777-27.778-27.777h-388.89zm0 111.11c-15.341 0-27.778 12.437-27.778 27.778 0 15.342 12.437 27.778 27.778 27.778H527.11c15.341 0 27.778-12.436 27.778-27.778 0-15.34-12.437-27.777-27.778-27.777H304.89z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgGraphic" }, props, { ref }), React__namespace.createElement(SvgIcon$1$, null));
  });
  const SvgIcon$1_ = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M99.603 442.736l-4.21 2.285c-19.465 12.73-15.267 44.05 8.77 50.065l294.77 73.701 73.764 294.833c6.417 25.64 41.625 28.707 52.351 4.56L835.772 168.7c10.328-23.25-13.438-47.016-36.688-36.688L99.604 442.736zm657.575-242.297L501.76 762.934l-55.33-231.801-1.612-4.759c-3.377-7.572-10.085-13.231-18.352-15.204l-231.823-55.354 562.534-255.377z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgGuideO" }, props, { ref }), React__namespace.createElement(SvgIcon$1_, null));
  });
  const SvgIcon$1Z = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "nonzero" }, React__namespace.createElement("path", { d: "M111.111 444.444c-9.984-11.647-8.635-29.184 3.013-39.168l349.72-299.76c20.806-17.833 51.506-17.833 72.311 0l349.721 299.76c11.648 9.984 12.997 27.52 3.013 39.168s-27.52 12.997-39.168 3.013L500 147.697l-349.72 299.76c-11.649 9.984-29.185 8.635-39.169-3.013z" }), React__namespace.createElement("path", { d: "M222.222 637.132v140.646h555.556V637.132L500 405.65 222.222 637.132zm-55.555 0a55.556 55.556 0 0119.99-42.679l277.777-231.481c20.603-17.17 50.53-17.17 71.132 0l277.778 231.481a55.556 55.556 0 0119.99 42.679v140.646c0 30.682-24.874 55.555-55.556 55.555H222.222c-30.682 0-55.555-24.873-55.555-55.555V637.132z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgHomeO" }, props, { ref }), React__namespace.createElement(SvgIcon$1Z, null));
  });
  const SvgIcon$1Y = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 111.314L386.156 225.157H225.157v161L111.314 500l113.843 113.844v160.999h161L500 888.686l113.844-113.843h160.999v-161L888.686 500 774.843 386.156V225.157h-161L500 111.314zm-136.855 58.288l97.571-97.572c21.696-21.696 56.872-21.696 78.568 0l97.571 97.572h137.988c30.682 0 55.555 24.873 55.555 55.555v137.988l97.572 97.571c21.696 21.696 21.696 56.872 0 78.568l-97.572 97.571v137.988c0 30.682-24.873 55.555-55.555 55.555H636.855l-97.571 97.572c-21.696 21.696-56.872 21.696-78.568 0l-97.571-97.572H225.157c-30.682 0-55.555-24.873-55.555-55.555V636.855L72.03 539.284c-21.696-21.696-21.696-56.872 0-78.568l97.572-97.571V225.157c0-30.682 24.873-55.555 55.555-55.555h137.988zM277.98 419.415h43.476v56.399h47.505v-56.399h43.668v161.17H368.96V515.39h-47.505v65.194H277.98v-161.17zm158.066 80.695c0-26.312 6.398-46.797 19.194-61.456 12.796-14.658 30.615-21.987 53.456-21.987 23.417 0 41.46 7.2 54.128 21.603 12.668 14.402 19.002 34.575 19.002 60.52 0 18.837-2.767 34.283-8.301 46.34-5.534 12.056-13.532 21.438-23.993 28.144-10.46 6.706-23.497 10.06-39.108 10.06-15.868 0-29-2.896-39.397-8.686-10.397-5.79-18.826-14.951-25.288-27.484-6.462-12.533-9.693-28.218-9.693-47.054zm43.475.22c0 16.27 2.639 27.96 7.917 35.07 5.279 7.11 12.46 10.664 21.546 10.664 9.341 0 16.571-3.481 21.69-10.444 5.118-6.963 7.677-19.459 7.677-37.489 0-15.172-2.67-26.257-8.013-33.256-5.343-7-12.589-10.5-21.738-10.5-8.765 0-15.803 3.555-21.114 10.665-5.31 7.109-7.965 18.872-7.965 35.29zm110.751-80.915h132.153v39.798h-44.339v121.372h-43.475V459.213h-44.339v-39.798z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgHotO" }, props, { ref }), React__namespace.createElement(SvgIcon$1Y, null));
  });
  const SvgIcon$1X = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M722.222 0c30.683 0 55.556 24.873 55.556 55.556v888.888c0 30.683-24.873 55.556-55.556 55.556H277.778c-30.683 0-55.556-24.873-55.556-55.556V55.556C222.222 24.873 247.095 0 277.778 0h444.444zm0 55.556H277.778v888.888h444.444V55.556zm-181.92 630v54.333c-.667 9.667-2 19-3.998 27.667h105.25v33h-118.24c-1.332 2-2.33 3.666-3.33 5.333 41.633 12 79.936 26.333 114.575 42.667l-19.65 30.333c-37.637-20.667-75.94-37-115.242-49.333-23.98 20.666-63.283 36.666-117.906 48l-18.651-29.667c55.289-11 92.259-24.333 111.577-40.333l6.994-7H360.445v-33h75.94c-19.652-11.667-39.636-20.667-59.953-27.334l16.32-24.333c24.647 8 47.296 18 67.946 29.333l-14.655 22.334H501c2.665-9 4.663-18.334 5.662-27.667v-54.333h33.64zm-22.316-116v22.666h93.258v31.334h-93.258v22.333h116.573v21.667c-4.996 22.666-11.657 45-19.984 67l-32.64-9.334c6.66-13.666 12.323-29.666 17.319-47.666H364.109v-31.667h119.904v-22.333h-95.257v-31.334h95.257v-22.666h33.973zM420.73 681.222c24.98 6.667 47.962 15.334 68.945 25.334l-17.32 26.333c-21.982-11.667-44.63-21-67.945-27.667l16.32-24zm-35.305-325.444l28.977 14c-11.658 25.666-25.313 47.666-40.634 66l-28.644-21c15.321-16.334 28.977-36 40.301-59zm215.827-5.667c19.984 24.667 34.972 46 45.63 64.333l-28.976 20.334c-10.992-20-25.98-42.334-44.964-67l28.31-17.667zm-132.227 15.333c6.661 18.667 12.323 39 17.652 60.667l-34.972 8.333c-3.997-23.666-9.326-44.333-15.32-62.333l32.64-6.667zm68.945-4.666c9.325 20 17.652 41.333 24.98 64.666l-34.64 8.334c-5.995-25-13.655-47-22.98-66l32.64-7zm6.661-236.334v40h67.946v68c0 35 1.998 59 6.66 72.334 2 6 3.665 9 4.997 9 1.665 0 3.33-5 4.663-14.334 1-9 1.665-19 1.665-29.666l26.312 13c-1.665 29.333-5.329 48.333-10.99 57-3.998 5.666-8.66 8.666-14.656 8.666-12.656-.333-22.981-5.333-30.975-14.666-14.322-16-21.65-50-21.65-101.334v-34h-33.972c-.666 22.667-3.33 43.667-7.994 62.334 13.656 10.666 26.646 22 39.302 34.666l-19.65 30c-10.659-11.333-21.317-21.666-31.975-30.666-10.991 23-26.312 42-45.63 57l-25.646-23c19.317-14.334 33.64-33 43.298-56-9.326-7-18.651-13-27.977-18.334l18.318-27.333c6.662 4 13.323 8 19.651 12 2.332-12.667 3.664-26.333 4.33-40.667h-33.973v-34h33.973v-40h33.973zm-113.909.334v38h36.637v34h-36.637v40l33.973-10v33.333c-11.324 3.333-22.649 6.333-33.973 9.333v45.334c0 22.666-10.658 34-31.974 34h-31.975l-7.993-33.334c9.659 1.334 18.984 2.334 27.644 2.334 5.995 0 9.326-4 9.326-11.667v-28.333c-14.655 3-28.977 6-43.632 8.666l-8.326-32.333a649.573 649.573 0 0051.958-9v-48.333h-43.299v-34h43.3v-38h34.971z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgHotSaleO" }, props, { ref }), React__namespace.createElement(SvgIcon$1X, null));
  });
  const SvgIcon$1W = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M722.222 0c30.683 0 55.556 24.873 55.556 55.556v888.888c0 30.683-24.873 55.556-55.556 55.556H277.778c-30.683 0-55.556-24.873-55.556-55.556V55.556C222.222 24.873 247.095 0 277.778 0h444.444zm-181.92 685.556h-33.64v54.333c-1 9.333-2.998 18.667-5.663 27.667h-54.956l14.655-22.334c-20.65-11.333-43.299-21.333-67.946-29.333l-16.32 24.333c20.317 6.667 40.301 15.667 59.952 27.334h-75.939v33h121.236l-6.994 7c-19.318 16-56.288 29.333-111.577 40.333l18.651 29.667c54.623-11.334 93.925-27.334 117.906-48 39.302 12.333 77.605 28.666 115.241 49.333l19.651-30.333c-34.639-16.334-72.942-30.667-114.575-42.667 1-1.667 1.998-3.333 3.33-5.333h118.24v-33h-105.25c1.999-8.667 3.331-18 3.997-27.667v-54.333zm-22.316-116h-33.973v22.666h-95.257v31.334h95.257v22.333H364.109v31.667h235.145c-4.996 18-10.658 34-17.32 47.666l32.641 9.334c8.327-22 14.988-44.334 19.984-67v-21.667H517.986v-22.333h93.258v-31.334h-93.258v-22.666zM420.73 681.222l-16.32 24c23.314 6.667 45.963 16 67.945 27.667l17.32-26.333c-20.983-10-43.965-18.667-68.945-25.334zm-35.305-325.444c-11.324 23-24.98 42.666-40.301 59l28.644 21c15.32-18.334 28.976-40.334 40.634-66zm215.827-5.667l-28.31 17.667c18.984 24.666 33.972 47 44.964 67l28.976-20.334c-10.658-18.333-25.646-39.666-45.63-64.333zm-132.227 15.333l-32.64 6.667c5.994 18 11.323 38.667 15.32 62.333l34.972-8.333c-5.329-21.667-10.99-42-17.652-60.667zm68.945-4.666l-32.64 7c9.325 19 16.985 41 22.98 66l34.64-8.334c-7.328-23.333-15.655-44.666-24.98-64.666zm6.661-236.334h-33.973v40h-33.973v34h33.973c-.666 14.334-1.998 28-4.33 40.667-6.328-4-12.99-8-19.65-12l-18.32 27.333c9.327 5.334 18.652 11.334 27.978 18.334-9.659 23-23.98 41.666-43.298 56l25.646 23c19.318-15 34.639-34 45.63-57 10.658 9 21.316 19.333 31.974 30.666l19.651-30c-12.656-12.666-25.646-24-39.302-34.666 4.663-18.667 7.328-39.667 7.994-62.334h33.973v34c0 51.334 7.327 85.334 21.65 101.334 7.993 9.333 18.318 14.333 30.974 14.666 5.996 0 10.658-3 14.655-8.666 5.662-8.667 9.326-27.667 10.991-57l-26.312-13c0 10.666-.666 20.666-1.665 29.666-1.332 9.334-2.998 14.334-4.663 14.334-1.332 0-2.998-3-4.996-9-4.663-13.334-6.661-37.334-6.661-72.334v-68H544.63v-40zm-113.909.334H395.75v38h-43.299v34h43.3v48.333a649.573 649.573 0 01-51.96 9l8.327 32.333c14.655-2.666 28.977-5.666 43.632-8.666v28.333c0 7.667-3.33 11.667-9.326 11.667-8.66 0-17.985-1-27.644-2.334l7.993 33.334h31.975c21.316 0 31.974-11.334 31.974-34v-45.334c11.324-3 22.649-6 33.973-9.333v-33.333l-33.973 10v-40h36.637v-34h-36.637v-38z", fillRule: "evenodd", opacity: 0.9 }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgHotSale" }, props, { ref }), React__namespace.createElement(SvgIcon$1W, null));
  });
  const SvgIcon$1V = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M363.145 169.602l97.571-97.572c21.696-21.696 56.872-21.696 78.568 0l97.571 97.572h137.988c30.682 0 55.555 24.873 55.555 55.555v137.988l97.572 97.571c21.696 21.696 21.696 56.872 0 78.568l-97.572 97.571v137.988c0 30.682-24.873 55.555-55.555 55.555H636.855l-97.571 97.572c-21.696 21.696-56.872 21.696-78.568 0l-97.571-97.572H225.157c-30.682 0-55.555-24.873-55.555-55.555V636.855L72.03 539.284c-21.696-21.696-21.696-56.872 0-78.568l97.572-97.571V225.157c0-30.682 24.873-55.555 55.555-55.555h137.988zM250 419.415v161.17h48.91V515.39h53.444v65.194h49.125v-161.17h-49.125v56.399H298.91v-56.399H250zm177.823 80.695c0 18.836 3.635 34.52 10.905 47.054 7.27 12.533 16.753 21.694 28.45 27.484 11.696 5.79 26.47 8.685 44.32 8.685 17.563 0 32.229-3.353 43.998-10.059 11.768-6.706 20.765-16.088 26.992-28.144 6.226-12.057 9.339-27.503 9.339-46.34 0-25.945-7.126-46.118-21.378-60.52-14.252-14.402-34.55-21.603-60.894-21.603-25.696 0-45.742 7.329-60.138 21.987-14.396 14.659-21.594 35.144-21.594 61.456zm48.91.22c0-16.418 2.987-28.181 8.961-35.29 5.974-7.11 13.892-10.664 23.753-10.664 10.293 0 18.445 3.5 24.455 10.499 6.01 7 9.015 18.084 9.015 33.256 0 18.03-2.879 30.526-8.637 37.49-5.758 6.962-13.892 10.443-24.4 10.443-10.222 0-18.301-3.554-24.24-10.664-5.938-7.11-8.907-18.8-8.907-35.07zm124.595-80.915v39.798h49.881v121.372h48.91V459.213H750v-39.798H601.328z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgHot" }, props, { ref }), React__namespace.createElement(SvgIcon$1V, null));
  });
  const SvgIcon$1U = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M166.556 388.779v444.445h166.667V388.78H166.556zm0-55.556h166.667c30.682 0 55.556 24.873 55.556 55.556v444.445c0 30.683-24.874 55.556-55.556 55.556H166.556c-30.683 0-55.556-24.873-55.556-55.556V388.78c0-30.683 24.873-55.556 55.556-55.556zM611 277.667c15.342 0 27.778 12.437 27.778 27.778v55.556c0 15.341-12.436 27.778-27.778 27.778-15.34 0-27.777-12.437-27.777-27.778v-55.556c0-15.341 12.436-27.778 27.777-27.778zm0 222.223c15.342 0 27.778 12.437 27.778 27.778v55.556c0 15.34-12.436 27.777-27.778 27.777-15.34 0-27.777-12.436-27.777-27.777v-55.556c0-15.341 12.436-27.778 27.777-27.778zm111.112-111.111c15.341 0 27.778 12.436 27.778 27.777v55.556c0 15.341-12.437 27.778-27.778 27.778s-27.778-12.437-27.778-27.778v-55.556c0-15.34 12.437-27.777 27.778-27.777zm0 222.222c15.341 0 27.778 12.437 27.778 27.778v55.556c0 15.341-12.437 27.778-27.778 27.778s-27.778-12.437-27.778-27.778v-55.556c0-15.341 12.437-27.778 27.778-27.778zM499.89 166.556v666.668h333.334V166.556H499.89zm0-55.556h333.334c30.683 0 55.556 24.873 55.556 55.556v666.668c0 30.683-24.873 55.556-55.556 55.556H499.89c-30.683 0-55.556-24.873-55.556-55.556V166.556c0-30.683 24.873-55.556 55.556-55.556z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgHotelO" }, props, { ref }), React__namespace.createElement(SvgIcon$1U, null));
  });
  const SvgIcon$1T = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M888.889 166.667c30.667 0 55.555 24.889 55.555 55.555v555.556c0 30.722-24.888 55.555-55.555 55.555H111.11c-30.667 0-55.555-24.833-55.555-55.555V222.222c0-30.666 24.888-55.555 55.555-55.555zm0 166.666H111.11v444.445H888.89V333.333zM694.444 611.111c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.778 27.778H305.556c-15.342 0-27.778-12.437-27.778-27.778s12.436-27.778 27.778-27.778h388.888zM888.89 222.222H111.11v55.556H888.89v-55.556z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgIdcard" }, props, { ref }), React__namespace.createElement(SvgIcon$1T, null));
  });
  const SvgIcon$1S = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { transform: "translate(55 55)", fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M445 833.889c214.777 0 388.889-174.112 388.889-388.889 0-214.777-174.112-388.889-388.889-388.889C230.223 56.111 56.111 230.223 56.111 445c0 214.777 174.112 388.889 388.889 388.889zm0 55.555C199.54 889.444.556 690.46.556 445S199.54.556 445 .556 889.444 199.54 889.444 445 690.46 889.444 445 889.444z", fillRule: "nonzero" }), React__namespace.createElement("path", { d: "M472.778 639.444h27.778c15.34 0 27.777 12.437 27.777 27.778S515.897 695 500.556 695H389.444c-15.34 0-27.777-12.437-27.777-27.778s12.436-27.778 27.777-27.778h27.778v-250h-13.889c-15.34 0-27.777-12.436-27.777-27.777 0-15.342 12.436-27.778 27.777-27.778H445c15.341 0 27.778 12.436 27.778 27.778v277.777z" }), React__namespace.createElement("circle", { cx: 445, cy: 236.667, r: 41.667 })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgInfoO" }, props, { ref }), React__namespace.createElement(SvgIcon$1S, null));
  });
  const SvgIcon$1R = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 55.556c245.46 0 444.444 198.984 444.444 444.444S745.46 944.444 500 944.444 55.556 745.46 55.556 500 254.54 55.556 500 55.556zm27.778 333.333h-97.222v55.555h41.666v250h-55.555V750h166.666v-55.556h-55.555V388.89zM500 250c-23.012 0-41.667 18.655-41.667 41.667s18.655 41.666 41.667 41.666 41.667-18.654 41.667-41.666C541.667 268.655 523.012 250 500 250z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgInfo" }, props, { ref }), React__namespace.createElement(SvgIcon$1R, null));
  });
  const SvgIcon$1Q = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M389.05 304.794c0 6.5 1.611 13.667 4.722 21.334.111.278.222.555.334.722 19.722 47.056 95.666 101.111 98.888 103.611 2 1.556 4.39 2.278 6.778 2.278 2.445 0 4.89-.778 6.89-2.333 2.777-2.112 67.555-48.445 93.277-92.278.944-1.5 1.722-2.945 2.389-4.167.222-.389.389-.778.61-1.167l.112-.166c.056-.167.111-.334.222-.445 1.556-3 2.778-5.722 3.778-8.444 2.667-6.945 3.944-13.167 3.944-18.889v-1.222c0-.722.112-1.778.112-2.945 0-36.833-29.056-66.722-64.778-66.722-17.556 0-34.278 7.5-46.334 20.389-12.11-12.889-28.777-20.389-46.333-20.389-35.667 0-64.778 29.889-64.778 66.722 0 1.223.111 2.334.223 3.167 0 .333-.056.611-.056.944" }), React__namespace.createElement("path", { d: "M722.222 412.978L520.167 534.2A38.997 38.997 0 01500 539.811a38.997 38.997 0 01-20.167-5.611L277.778 412.978V166.644h444.444v246.334zm111.111-135.222h-55.555V166.644c0-30.666-24.834-55.555-55.556-55.555H277.778c-30.722 0-55.556 24.889-55.556 55.555v111.112h-55.555c-30.723 0-55.556 24.888-55.556 55.555v500c0 30.722 24.833 55.556 55.556 55.556h666.666c30.723 0 55.556-24.834 55.556-55.556v-500c0-30.667-24.833-55.555-55.556-55.555z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgInvitation" }, props, { ref }), React__namespace.createElement(SvgIcon$1Q, null));
  });
  const SvgIcon$1P = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M777.778 854.554V111.11H222.222v743.443L500 715.664l277.778 138.89zM222.222 55.556h555.556c30.682 0 55.555 24.873 55.555 55.555v743.443c0 30.682-24.873 55.555-55.555 55.555a55.556 55.556 0 01-24.845-5.865L500 777.778 247.067 904.244c-27.443 13.722-60.814 2.598-74.535-24.845a55.556 55.556 0 01-5.865-24.845V111.11c0-30.682 24.873-55.555 55.555-55.555zm138.89 222.222h277.777c15.341 0 27.778 12.436 27.778 27.778 0 15.34-12.437 27.777-27.778 27.777H361.11c-15.341 0-27.778-12.436-27.778-27.777 0-15.342 12.437-27.778 27.778-27.778zm0 166.666h277.777c15.341 0 27.778 12.437 27.778 27.778S654.23 500 638.889 500H361.11c-15.341 0-27.778-12.437-27.778-27.778s12.437-27.778 27.778-27.778z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgLabelO" }, props, { ref }), React__namespace.createElement(SvgIcon$1P, null));
  });
  const SvgIcon$1O = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M638.633 333.333H360.856c-15.334 0-27.778-12.444-27.778-27.777 0-15.334 12.444-27.778 27.778-27.778h277.777c15.334 0 27.778 12.444 27.778 27.778 0 15.333-12.444 27.777-27.778 27.777m0 166.667H360.856c-15.334 0-27.778-12.444-27.778-27.778 0-15.333 12.444-27.778 27.778-27.778h277.777c15.334 0 27.778 12.445 27.778 27.778 0 15.334-12.444 27.778-27.778 27.778m138.89-444.444H221.966c-30.723 0-55.556 24.833-55.556 55.555v805.5c0 20.667 21.778 34.111 40.222 24.833l268.278-134.11c15.611-7.778 34.056-7.778 49.667 0l268.278 134.11c18.444 9.278 40.222-4.166 40.222-24.833v-805.5c0-30.722-24.834-55.555-55.556-55.555", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgLabel" }, props, { ref }), React__namespace.createElement(SvgIcon$1O, null));
  });
  const SvgIcon$1N = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M407.368 765.883l92.751 98.897 333.22-353.217c76.417-81.004 74.567-208.092-4.178-286.836-77.465-77.465-203.06-77.465-280.524 0l-49.045 49.045-49.034-49.034c-77.416-77.416-202.932-77.416-280.347 0-78.63 78.63-80.383 205.562-3.955 286.334l241.112 254.81zm82.473-580.429l9.75 9.75 9.763-9.761c99.16-99.16 259.93-99.16 359.09 0 99.996 99.995 102.346 261.379 5.305 364.243L540.53 902.903a55.555 55.555 0 01-2.407 2.4c-22.38 20.99-57.538 19.862-78.527-2.519l-92.581-98.717-241.112-254.811c-97.106-102.624-94.88-263.899 5.024-363.802 99.111-99.111 259.803-99.111 358.914 0z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgLikeO" }, props, { ref }), React__namespace.createElement(SvgIcon$1N, null));
  });
  const SvgIcon$1M = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M368.059 804.105L126.947 549.294c-97.106-102.624-94.88-263.899 5.024-363.802 99.112-99.111 259.803-99.111 358.915 0l9.75 9.75 9.762-9.76c99.16-99.161 259.93-99.161 359.09 0 99.996 99.994 102.346 261.378 5.306 364.243l-333.22 353.217a55.555 55.555 0 01-2.406 2.4c-22.38 20.989-57.538 19.86-78.527-2.52l-92.582-98.717z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgLike" }, props, { ref }), React__namespace.createElement(SvgIcon$1M, null));
  });
  const SvgIcon$1L = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M428.173 294.05h140.863L716.06 147.025c10.848-10.848 28.436-10.848 39.284 0 10.848 10.848 10.848 28.436 0 39.284l-107.741 107.74h185.73c30.683 0 55.556 24.874 55.556 55.556V794.05c0 30.682-24.873 55.555-55.556 55.555H166.667c-30.683 0-55.556-24.873-55.556-55.555V349.605c0-30.682 24.873-55.555 55.556-55.555h182.938l-107.74-107.741c-10.849-10.848-10.849-28.436 0-39.284 10.847-10.848 28.435-10.848 39.283 0L428.173 294.05zm146.59 303.168a27.778 27.778 0 004.339-4.338c9.584-11.98 7.641-29.46-4.338-39.043l-112.967-90.374a27.778 27.778 0 00-17.353-6.087c-15.34 0-27.777 12.437-27.777 27.778v180.747a27.778 27.778 0 006.087 17.353c9.583 11.98 27.064 13.921 39.043 4.338l112.967-90.374z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgLive" }, props, { ref }), React__namespace.createElement(SvgIcon$1L, null));
  });
  const SvgIcon$1K = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M500.335 55C684.431 55 833.67 200.948 833.67 380.983c0 164.257-97.838 346.605-293.515 547.044-.331.34-.667.674-1.007 1.005-21.988 21.399-57.16 20.921-78.559-1.067C264.863 726.848 167 544.52 167 380.983 167 200.948 316.24 55 500.335 55zm0 55.556c-153.687 0-277.78 121.355-277.78 270.427 0 146.484 91.26 316.508 277.846 508.235 186.503-191.041 277.713-361.035 277.713-508.235 0-149.072-124.092-270.427-277.779-270.427zm0 444.447c-76.707 0-138.89-62.183-138.89-138.89s62.183-138.89 138.89-138.89 138.89 62.183 138.89 138.89-62.183 138.89-138.89 138.89zm0-55.556c46.024 0 83.334-37.31 83.334-83.334s-37.31-83.334-83.334-83.334-83.334 37.31-83.334 83.334 37.31 83.334 83.334 83.334z", fillRule: "nonzero" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgLocationO" }, props, { ref }), React__namespace.createElement(SvgIcon$1K, null));
  });
  const SvgIcon$1J = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 56.056c91.91 0 175.12 36.431 235.353 95.335 60.228 58.9 97.48 140.268 97.48 230.146 0 164.16-97.82 346.382-293.371 546.692-.328.336-.66.668-.998.996-10.895 10.603-25.056 15.786-39.144 15.595-14.089-.192-28.104-5.758-38.707-16.653-195.6-200.987-293.446-383.189-293.446-546.63 0-89.878 37.252-171.247 97.48-230.146C324.88 92.487 408.09 56.056 500 56.056zm0 221.222c-30.82 0-58.723 12.492-78.921 32.69-20.198 20.198-32.69 48.1-32.69 78.92 0 30.821 12.492 58.724 32.69 78.922 20.198 20.198 48.1 32.69 78.921 32.69 30.82 0 58.723-12.492 78.921-32.69 20.198-20.198 32.69-48.1 32.69-78.921 0-30.82-12.492-58.723-32.69-78.921-20.198-20.198-48.1-32.69-78.921-32.69z", stroke: "#323233", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgLocation" }, props, { ref }), React__namespace.createElement(SvgIcon$1J, null));
  });
  const SvgIcon$1I = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M277.778 444.444v-111.11c0-122.73 99.492-222.223 222.222-222.223s222.222 99.492 222.222 222.222v111.111h69.445c23.012 0 41.666 18.655 41.666 41.667v361.111c0 23.012-18.654 41.667-41.666 41.667H208.333c-23.012 0-41.666-18.655-41.666-41.667v-361.11c0-23.013 18.654-41.668 41.666-41.668h69.445zm83.333 0H638.89v-111.11c0-76.707-62.183-138.89-138.889-138.89-76.706 0-138.889 62.183-138.889 138.89v111.11z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgLock" }, props, { ref }), React__namespace.createElement(SvgIcon$1I, null));
  });
  const SvgIcon$1H = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "nonzero" }, React__namespace.createElement("path", { d: "M631.133 111.111c52.964 0 98.566 37.385 108.953 89.32l37.692 188.458 128.68 42.893c22.685 7.562 37.986 28.792 37.986 52.705v293.29c0 30.683-24.873 55.556-55.555 55.556H666.667v-55.555h222.222V484.487l-159.265-53.089-44.014-220.071c-5.194-25.968-27.995-44.66-54.477-44.66H166.667V111.11h464.466zM444.444 500c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.778 27.778H111.111c-15.341 0-27.778-12.437-27.778-27.778S95.77 500 111.111 500h333.333zm0-166.667c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.778 27.778H111.111c-15.341 0-27.778-12.437-27.778-27.778s12.437-27.778 27.778-27.778h333.333zm-278.237-166.67c-15.13-.245-27.318-12.586-27.318-27.774 0-15.341 12.436-27.778 27.778-27.778h464.466c52.964 0 98.566 37.385 108.953 89.32l37.692 188.458 128.68 42.893c22.685 7.562 37.986 28.792 37.986 52.705v293.29c0 30.683-24.873 55.556-55.555 55.556H666.667v-55.555h222.222V484.487l-159.265-53.089-44.014-220.071c-5.194-25.968-27.995-44.66-54.477-44.66H166.667z" }), React__namespace.createElement("path", { d: "M611.111 861.111c30.683 0 55.556-24.873 55.556-55.555 0-30.683-24.873-55.556-55.556-55.556-30.682 0-55.555 24.873-55.555 55.556 0 30.682 24.873 55.555 55.555 55.555zm0 55.556C549.746 916.667 500 866.92 500 805.556s49.746-111.112 111.111-111.112 111.111 49.747 111.111 111.112c0 61.365-49.746 111.11-111.11 111.11zM222.222 861.111c30.683 0 55.556-24.873 55.556-55.555 0-30.683-24.873-55.556-55.556-55.556-30.682 0-55.555 24.873-55.555 55.556 0 30.682 24.873 55.555 55.555 55.555zm0 55.556c-61.365 0-111.11-49.746-111.11-111.111s49.745-111.112 111.11-111.112 111.111 49.747 111.111 111.112c0 61.365-49.746 111.11-111.11 111.11z" }), React__namespace.createElement("path", { d: "M277.778 833.333v-55.555h277.778v55.555z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgLogistics" }, props, { ref }), React__namespace.createElement(SvgIcon$1H, null));
  });
  const SvgIcon$1G = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M166.667 696.66v192.229h666.666v-192.23L654.09 611.112H345.91L166.667 696.66zm-23.93-50.138l179.245-85.549a55.556 55.556 0 0123.93-5.417h308.177c8.28 0 16.456 1.85 23.93 5.417l179.244 85.549a55.556 55.556 0 0131.626 50.138v192.229c0 30.682-24.873 55.555-55.556 55.555H166.667c-30.683 0-55.556-24.873-55.556-55.555v-192.23a55.556 55.556 0 0131.626-50.137zM500 444.444c92.047 0 166.667-74.619 166.667-166.666 0-92.048-74.62-166.667-166.667-166.667s-166.667 74.62-166.667 166.667S407.953 444.444 500 444.444zM500 500c-122.73 0-222.222-99.492-222.222-222.222S377.27 55.556 500 55.556s222.222 99.492 222.222 222.222S622.73 500 500 500zm83.333 222.222h111.111c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.778 27.778h-111.11c-15.342 0-27.778-12.437-27.778-27.778s12.436-27.778 27.777-27.778z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgManagerO" }, props, { ref }), React__namespace.createElement(SvgIcon$1G, null));
  });
  const SvgIcon$1F = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M142.737 646.522l179.245-85.549a55.556 55.556 0 0123.93-5.417h308.177c8.28 0 16.456 1.85 23.93 5.417l179.244 85.549a55.556 55.556 0 0131.626 50.138v192.229c0 30.682-24.873 55.555-55.556 55.555H166.667c-30.683 0-55.556-24.873-55.556-55.555v-192.23a55.556 55.556 0 0131.626-50.137zM555.556 750c0 15.341 12.436 27.778 27.777 27.778h111.111c15.342 0 27.778-12.437 27.778-27.778s-12.436-27.778-27.778-27.778h-111.11c-15.342 0-27.778 12.437-27.778 27.778zM500 500c-122.73 0-222.222-99.492-222.222-222.222S377.27 55.556 500 55.556s222.222 99.492 222.222 222.222S622.73 500 500 500z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgManager" }, props, { ref }), React__namespace.createElement(SvgIcon$1F, null));
  });
  const SvgIcon$1E = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M747.14 611.111a55.556 55.556 0 0146.162 24.645l148.8 222.223c17.072 25.494 10.243 60.001-15.252 77.072a55.556 55.556 0 01-30.91 9.393H103.434c-30.683 0-55.556-24.873-55.556-55.555a55.556 55.556 0 019.239-30.678l147.189-222.222a55.556 55.556 0 0146.317-24.878l95.176.007C420.123 696.521 500.37 750 500 750c-.369 0 79.877-53.479 154.2-138.882l92.94-.007zm-24.918 222.222v55.556H277.778v-55.556h444.444zM500 111.111c122.73 0 222.222 99.492 222.222 222.222C722.222 518.52 500 685.185 500 685.185S277.778 518.52 277.778 333.333c0-122.73 99.492-222.222 222.222-222.222zM500 250c-46.024 0-83.333 37.31-83.333 83.333 0 46.024 37.31 83.334 83.333 83.334 46.024 0 83.333-37.31 83.333-83.334C583.333 287.31 546.023 250 500 250z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgMapMarked" }, props, { ref }), React__namespace.createElement(SvgIcon$1E, null));
  });
  const SvgIcon$1D = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "nonzero" }, React__namespace.createElement("path", { d: "M446.42 282.061a335.726 335.726 0 0153.58-4.283c14.599 0 28.978.938 43.081 2.758 4.186.507 8.344 1.089 12.475 1.747V111.111h55.555v185.177a311.039 311.039 0 0139 16.77l72.111-107.715V111.11H277.778v94.379l71.4 107.782a320.583 320.583 0 0139.71-16.923V111.111h55.556v171.261c.658-.105 1.316-.209 1.975-.31zm250.89 60.359c82.49 60.678 136.023 158.433 136.023 268.691 0 184.095-149.238 333.333-333.333 333.333-184.095 0-333.333-149.238-333.333-333.333 0-110.005 53.287-207.565 135.457-268.273L231.463 236.17a55.556 55.556 0 01-9.24-30.681v-94.379c0-30.682 24.872-55.555 55.555-55.555h444.444c30.683 0 55.556 24.873 55.556 55.555v94.232a55.556 55.556 0 01-9.39 30.906l-71.079 106.17zm-30.945 46.222l-.166.247a277.576 277.576 0 00-16.932-12.084c-33.698-21.512-72.347-35.955-113.856-41.236-11.42-1.34-23.11-2.01-35.07-2.01-15.129 0-29.86 1.072-44.192 3.216C323.572 357.8 222.222 472.62 222.222 611.111c0 153.413 124.366 277.778 277.778 277.778 153.412 0 277.778-124.365 277.778-277.778 0-91.014-43.772-171.805-111.413-222.469z" }), React__namespace.createElement("path", { d: "M500 532.544l-78.567 78.567L500 689.68l78.567-78.568L500 532.544zm39.284-39.284l78.567 78.567c21.696 21.696 21.696 56.872 0 78.568l-78.567 78.567c-21.696 21.696-56.872 21.696-78.568 0l-78.567-78.567c-21.696-21.696-21.696-56.872 0-78.568l78.567-78.567c21.696-21.696 56.872-21.696 78.568 0z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgMedalO" }, props, { ref }), React__namespace.createElement(SvgIcon$1D, null));
  });
  const SvgIcon$1C = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500.006 277.778c184.055 0 333.333 149.222 333.333 333.333 0 184.056-149.278 333.333-333.333 333.333-184.112 0-333.334-149.277-333.334-333.333 0-184.111 149.222-333.333 333.334-333.333zm39.277 215.5c-21.722-21.722-56.889-21.722-78.555 0l-78.556 78.555c-21.722 21.723-21.722 56.834 0 78.556l78.556 78.555c21.666 21.723 56.833 21.723 78.555 0l78.556-78.555c21.722-21.722 21.722-56.833 0-78.556zM666.667 55.56c30.722 0 55.555 24.833 55.555 55.556v111.11l-43.666 43.667c-37.778-19.61-79.278-32.944-123-39.277v-115.5H444.444v115.5c-43.722 6.333-85.222 19.666-123 39.277l-43.666-43.666V111.117c0-30.723 24.833-55.556 55.555-55.556z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgMedal" }, props, { ref }), React__namespace.createElement(SvgIcon$1C, null));
  });
  const SvgIcon$1B = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M537.5 537.5h-400c-20.71 0-37.5-16.79-37.5-37.5s16.79-37.5 37.5-37.5h725c20.71 0 37.5 16.79 37.5 37.5s-16.79 37.5-37.5 37.5h-325z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgMinus" }, props, { ref }), React__namespace.createElement(SvgIcon$1B, null));
  });
  const SvgIcon$1A = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M500 881.944c210.942 0 381.944-171.002 381.944-381.944S710.942 118.056 500 118.056 118.056 289.058 118.056 500 289.058 881.944 500 881.944zm0 62.5C254.54 944.444 55.556 745.46 55.556 500S254.54 55.556 500 55.556 944.444 254.54 944.444 500 745.46 944.444 500 944.444z", fillRule: "nonzero" }), React__namespace.createElement("circle", { cx: 500, cy: 500, r: 55.556 }), React__namespace.createElement("circle", { cx: 277.778, cy: 500, r: 55.556 }), React__namespace.createElement("circle", { cx: 722.222, cy: 500, r: 55.556 })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgMoreO" }, props, { ref }), React__namespace.createElement(SvgIcon$1A, null));
  });
  const SvgIcon$1z = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 55.556c245.46 0 444.444 198.984 444.444 444.444S745.46 944.444 500 944.444 55.556 745.46 55.556 500 254.54 55.556 500 55.556zm0 388.888c-30.682 0-55.556 24.874-55.556 55.556s24.874 55.556 55.556 55.556 55.556-24.874 55.556-55.556-24.874-55.556-55.556-55.556zm-222.222 0c-30.683 0-55.556 24.874-55.556 55.556s24.873 55.556 55.556 55.556c30.682 0 55.555-24.874 55.555-55.556s-24.873-55.556-55.555-55.556zm444.444 0c-30.682 0-55.555 24.874-55.555 55.556s24.873 55.556 55.555 55.556c30.683 0 55.556-24.874 55.556-55.556s-24.873-55.556-55.556-55.556z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgMore" }, props, { ref }), React__namespace.createElement(SvgIcon$1z, null));
  });
  const SvgIcon$1y = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 888.889c-214.389 0-388.889-174.5-388.889-388.889S285.611 111.111 500 111.111 888.889 285.611 888.889 500 714.389 888.889 500 888.889m0-833.333c-245.444 0-444.444 199-444.444 444.444 0 245.444 199 444.444 444.444 444.444 245.444 0 444.444-199 444.444-444.444 0-245.444-199-444.444-444.444-444.444m-48.611 666.666h-69.445c-26.777 0-48.61-21.833-48.61-48.61 0-26.779 21.833-48.612 48.61-48.612h69.445C478.167 625 500 646.833 500 673.611s-21.833 48.611-48.611 48.611M657.889 293l-113.722-65.611c-4.278-3-9.167-5.167-14.834-5.167H526.222c-13.444 0-24 10.222-25.61 23.111-.056.667-.279 1.167-.334 1.834-.056.444-.278.833-.278 1.277v333.612c-14.611-7.778-30.944-12.612-48.611-12.612h-69.445c-57.5 0-104.166 46.667-104.166 104.167s46.666 104.167 104.166 104.167h69.445c57.5 0 104.167-46.667 104.167-104.167 0-2.389-.556-4.611-.723-6.944h.723V298.11l74.555 43.056a27.663 27.663 0 0013.833 3.722c9.612 0 18.945-5 24.056-13.889 7.722-13.278 3.167-30.278-10.111-38", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgMusicO" }, props, { ref }), React__namespace.createElement(SvgIcon$1y, null));
  });
  const SvgIcon$1x = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 55.556c245.46 0 444.444 198.984 444.444 444.444S745.46 944.444 500 944.444 55.556 745.46 55.556 500 254.54 55.556 500 55.556zm29.333 166.666h-3.11c-13.445 0-24 10.222-25.612 23.111-.055.667-.278 1.167-.333 1.834-.056.444-.278.833-.278 1.277v333.612c-14.611-7.778-30.944-12.612-48.611-12.612h-69.445c-57.5 0-104.166 46.667-104.166 104.167s46.666 104.167 104.166 104.167h69.445c57.5 0 104.167-46.667 104.167-104.167 0-1.194-.14-2.347-.3-3.493l-.193-1.374a31.94 31.94 0 01-.23-2.077h.723V298.11l74.555 43.056a27.663 27.663 0 0013.833 3.722c9.612 0 18.945-5 24.056-13.889 7.722-13.278 3.167-30.278-10.111-38l-113.722-65.611c-4.278-3-9.167-5.167-14.834-5.167zM451.39 625C478.167 625 500 646.833 500 673.611s-21.833 48.611-48.611 48.611h-69.445c-26.777 0-48.61-21.833-48.61-48.61 0-26.779 21.833-48.612 48.61-48.612h69.445z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgMusic" }, props, { ref }), React__namespace.createElement(SvgIcon$1x, null));
  });
  const SvgIcon$1w = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M722.222 222.222C875.635 222.222 1000 346.588 1000 500c0 153.412-124.365 277.778-277.778 277.778H0V222.222h722.222zm0 55.556H55.556v444.444h666.666c122.73 0 222.222-99.492 222.222-222.222s-99.492-222.222-222.222-222.222zM291.667 396.444l28.333 10a238.98 238.98 0 01-13.667 33.334h34v29h-61.666v30h56v28.666h-56v89.334c0 20-11 30-33 30h-17.334l-7-29.334c5 1.334 9.667 2 14 2 8 0 12-3.333 12-10v-82H188v-28.666h59.333v-30h-64.666v-29H218c-4.333-11.667-9.333-22.667-15-32.667l27.667-10.333c5.333 12 10.666 26.333 15.333 43h31.667c5.333-14 10-28.334 14-43.334zm172.666-56l15.334 28c-28.667 10-60.334 16-95 18.334v54h103v30.333h-32v174.667h-31V471.11h-40v33.667C383 563.444 370 610.11 345.667 645.11l-22.334-24c19-28 29.334-66.667 30.667-116.333v-144c41-.667 77.667-7.667 110.333-20.334zm186.334 150v150H620v-16h-61.667v16h-31v-150h123.334zm155.333 0v150h-31.667v-16H710v16h-31v-150h127zm-598 51.667l28.667 6c-8 33.667-19 63-33.667 88l-26-16.667c14.667-24 25-50 31-77.333zm104.333-2.333C321 561.11 328 580.444 333 597.778l-26.667 10c-5.333-20.667-12-41-20-61l26-7zM620 520.444h-61.667v74.334H620v-74.334zm154.333 0H710v74.334h64.333v-74.334zm-13-171.333v116.333H572V349.111h189.333zm-31.666 30h-126v56.333h126v-56.333zm-465.334-45c4 9 8.334 19 12.334 30h61.666v29.333H186v-29.333h59.333c-4-8.667-8.666-17-13.666-24.667l32.666-5.333z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgNewArrivalO" }, props, { ref }), React__namespace.createElement(SvgIcon$1w, null));
  });
  const SvgIcon$1v = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M722.222 222.222C875.635 222.222 1000 346.588 1000 500c0 153.412-124.365 277.778-277.778 277.778H0V222.222h722.222zM290.786 414.325a382.615 382.615 0 01-13.016 40.291H248.4c-4.672-15.545-9.345-28.87-14.35-40.29l-30.705 11.103c5.34 8.883 10.012 18.718 14.017 29.187H183.32v30.139h63.412v25.697H188.66v30.138h58.072v75.188c0 6.028-4.005 9.2-11.348 9.2-4.005 0-8.677-.951-13.683-2.22l7.676 30.456h17.355c23.028 0 34.71-9.835 34.71-29.504v-83.12h54.733v-30.138h-54.734v-25.697h60.408v-30.139h-32.373c4.338-9.2 8.343-19.035 12.348-29.821zm174.549-53.932c-32.707 12.056-69.42 18.4-110.804 19.035v137.686c-1.335 46.636-11.68 83.12-30.37 109.45l25.03 25.064c24.364-33.629 37.38-78.36 39.049-134.514v-30.139h36.044v165.287h34.376V486.975h30.705v-31.407H388.24v-49.174c34.376-1.903 65.748-7.296 94.116-16.18zm187.899 142.128H527.412v144.665h34.042v-14.91h58.072v14.91h33.708V502.521zm155.86 0H679.265v144.665h34.042v-14.91h61.076v14.91h34.71V502.521zM207.35 552.963c-5.674 25.697-15.686 50.125-30.038 72.967l29.036 17.45c14.018-23.795 24.698-51.712 32.374-84.072zm108.133-1.903l-28.702 7.296c7.342 18.718 13.684 38.07 18.69 57.74l29.37-10.787c-4.673-16.497-11.348-34.58-19.358-54.25zm304.043-17.449v67.891h-58.072v-67.891h58.072zm154.858 0v67.891h-61.076v-67.891h61.076zM764.37 368.324H572.467v113.258h191.904V368.324zm-35.043 31.09v51.078H607.51v-51.077h121.817zM267.424 355l-36.045 5.71c4.673 6.663 9.011 13.96 13.016 21.89h-57.738v30.456h153.19v-30.455h-60.742c-4.005-10.152-7.676-19.353-11.681-27.601z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgNewArrival" }, props, { ref }), React__namespace.createElement(SvgIcon$1v, null));
  });
  const SvgIcon$1u = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M222.222 55.556v576.388c0 48.087 48.219 90.278 111.111 90.278h333.334c62.892 0 111.11-42.191 111.11-90.278V55.556H222.223zM166.667 0h666.666v631.944c0 80.542-74.619 145.834-166.666 145.834H333.333c-92.047 0-166.666-65.292-166.666-145.834V0zm145.126 472.222h-34.015V305.556h28.639l59.82 96.904h.782v-96.904h34.015v166.666h-28.346l-60.113-97.828h-.782v97.828zm207.218-34.188v34.188h-96.669V305.556h96.67v34.188h-60.798v33.148h57.18v31.185h-57.18v33.957h60.797zm108.008-69.877l-23.752 104.065h-33.82l-36.85-166.666h37.046l19.06 112.612h.782l23.557-112.612h28.736l23.557 112.612h.782l19.06-112.612h37.045l-36.85 166.666h-33.82l-23.751-104.065h-.782z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgNewO" }, props, { ref }), React__namespace.createElement(SvgIcon$1u, null));
  });
  const SvgIcon$1t = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M833.333 0v631.944c0 80.542-74.619 145.834-166.666 145.834H333.333c-92.047 0-166.666-65.292-166.666-145.834V0h666.666zM306.417 305.556h-28.64v166.666h34.016v-97.828h.782l60.113 97.828h28.346V305.556h-34.015v96.904h-.782l-59.82-96.904zm212.594 0h-96.669v166.666h96.67v-34.188h-60.798v-33.957h57.18v-31.185h-57.18v-33.148h60.797v-34.188zm50.632 0h-37.045l36.85 166.666h33.82l23.751-104.065h.782l23.752 104.065h33.82l36.85-166.666h-37.046l-19.06 112.612h-.782l-23.557-112.612h-28.736l-23.557 112.612h-.782l-19.06-112.612z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgNew" }, props, { ref }), React__namespace.createElement(SvgIcon$1t, null));
  });
  const SvgIcon$1s = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M777.778 833.333h55.555V666.667h-55.555v166.666zm55.555-222.222c30.723 0 55.556 24.833 55.556 55.556v166.666c0 30.723-24.833 55.556-55.556 55.556H166.667c-30.723 0-55.556-24.833-55.556-55.556V166.667c0-30.723 24.833-55.556 55.556-55.556h555.555c30.722 0 55.556 24.833 55.556 55.556V611.11h55.555zM166.667 833.333h555.555V166.667H166.667v666.666zm111.11-222.222H388.89V444.444H277.778v166.667zM250 666.667c-15.341 0-27.778-12.437-27.778-27.778V416.667c0-15.342 12.437-27.778 27.778-27.778h166.667c15.34 0 27.777 12.436 27.777 27.778v222.222c0 15.341-12.436 27.778-27.777 27.778H250zm0-333.334c-15.341 0-27.778-12.436-27.778-27.777 0-15.342 12.437-27.778 27.778-27.778h388.889c15.341 0 27.778 12.436 27.778 27.778 0 15.34-12.437 27.777-27.778 27.777H250zm277.778 111.111c-15.341 0-27.778-12.436-27.778-27.777 0-15.342 12.437-27.778 27.778-27.778h111.11c15.342 0 27.779 12.436 27.779 27.778 0 15.34-12.437 27.777-27.778 27.777H527.778zm0 111.112c-15.341 0-27.778-12.437-27.778-27.778S512.437 500 527.778 500h111.11c15.342 0 27.779 12.437 27.779 27.778s-12.437 27.778-27.778 27.778H527.778zm.028 111.11c-15.357 0-27.806-12.448-27.806-27.805 0-15.356 12.449-27.805 27.806-27.805H638.86c15.357 0 27.806 12.449 27.806 27.805 0 15.357-12.45 27.806-27.806 27.806H527.806z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgNewspaperO" }, props, { ref }), React__namespace.createElement(SvgIcon$1s, null));
  });
  const SvgIcon$1r = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M833.333 833.333v-611.11h-111.11V250c0 15.341-12.437 27.778-27.779 27.778-15.34 0-27.777-12.437-27.777-27.778v-27.778H333.333V250c0 15.341-12.436 27.778-27.777 27.778-15.342 0-27.778-12.437-27.778-27.778v-27.778H166.667v611.111h666.666zm-111.11-666.666h111.11c30.723 0 55.556 24.833 55.556 55.555v611.111c0 30.723-24.833 55.556-55.556 55.556H166.667c-30.723 0-55.556-24.833-55.556-55.556v-611.11c0-30.723 24.833-55.556 55.556-55.556h111.11v-27.778c0-15.341 12.437-27.778 27.779-27.778 15.34 0 27.777 12.437 27.777 27.778v27.778h333.334v-27.778c0-15.341 12.436-27.778 27.777-27.778 15.342 0 27.778 12.437 27.778 27.778v27.778zM305.555 611.11c-15.342 0-27.778-12.436-27.778-27.778 0-15.34 12.436-27.777 27.778-27.777h388.888c15.342 0 27.778 12.436 27.778 27.777 0 15.342-12.436 27.778-27.778 27.778H305.556zm0-111.111c-15.342 0-27.778-12.437-27.778-27.778s12.436-27.778 27.778-27.778h388.888c15.342 0 27.778 12.437 27.778 27.778S709.786 500 694.444 500H305.556zm0 222.222c-15.342 0-27.778-12.436-27.778-27.778 0-15.34 12.436-27.777 27.778-27.777h166.666c15.341 0 27.778 12.436 27.778 27.777 0 15.342-12.437 27.778-27.778 27.778H305.556z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgNotesO" }, props, { ref }), React__namespace.createElement(SvgIcon$1r, null));
  });
  const SvgIcon$1q = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M778.114 56c30.683 0 55.556 24.873 55.556 55.556v777.781c0 30.683-24.873 55.556-55.556 55.556H222.556c-30.683 0-55.556-24.873-55.556-55.556V111.557C167 80.873 191.873 56 222.556 56h555.558zm0 55.556H222.556v777.781h555.558V111.557zM528.113 667.114c15.341 0 27.778 12.437 27.778 27.778s-12.437 27.778-27.778 27.778H361.445c-15.34 0-27.777-12.437-27.777-27.778s12.436-27.778 27.777-27.778h166.668zm111.112-166.667c15.34 0 27.778 12.436 27.778 27.778 0 15.34-12.437 27.778-27.778 27.778h-277.78c-15.34 0-27.777-12.437-27.777-27.778 0-15.342 12.436-27.778 27.777-27.778h277.78zm0-166.668c15.34 0 27.778 12.437 27.778 27.778s-12.437 27.778-27.778 27.778h-277.78c-15.34 0-27.777-12.437-27.777-27.778s12.436-27.778 27.777-27.778h277.78z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgOrdersO" }, props, { ref }), React__namespace.createElement(SvgIcon$1q, null));
  });
  const SvgIcon$1p = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M888.889 166.667c30.667 0 55.555 24.889 55.555 55.555v555.556c0 30.666-24.888 55.555-55.555 55.555H111.11c-30.667 0-55.555-24.889-55.555-55.555V222.222c0-30.666 24.888-55.555 55.555-55.555zm0 55.555H111.11v555.556H888.89V222.222zM333.044 537.04c23 0 41.667-18.667 41.667-41.667s-18.667-41.666-41.667-41.666-41.666 18.666-41.666 41.666c0 23 18.666 41.667 41.666 41.667m166.667 0c23 0 41.667-18.667 41.667-41.667s-18.667-41.666-41.667-41.666-41.667 18.666-41.667 41.666c0 23 18.667 41.667 41.667 41.667m166.667 0c23 0 41.666-18.667 41.666-41.667s-18.666-41.666-41.666-41.666c-23 0-41.667 18.666-41.667 41.666 0 23 18.667 41.667 41.667 41.667", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgOtherPay" }, props, { ref }), React__namespace.createElement(SvgIcon$1p, null));
  });
  const SvgIcon$1o = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M111.111 333.333v444.445H888.89V333.333H111.11zm666.667-166.666c30.682 0 55.555 24.873 55.555 55.555v55.556h55.556c30.682 0 55.555 24.873 55.555 55.555v444.445c0 30.682-24.873 55.555-55.555 55.555H111.11c-30.682 0-55.555-24.873-55.555-55.555v-500l722.222-.001v-111.11zm166.666 222.222v55.555H666.667c-61.365 0-111.111 49.747-111.111 111.112 0 61.365 49.746 111.11 111.11 111.11h277.778v55.556H666.667C574.619 722.222 500 647.603 500 555.556c0-92.048 74.62-166.667 166.667-166.667h277.777zm-263.888 125c23.011 0 41.666 18.655 41.666 41.667 0 23.011-18.655 41.666-41.666 41.666-23.012 0-41.667-18.655-41.667-41.666 0-23.012 18.655-41.667 41.667-41.667zM582.53 69.253l.858.007c18.874.314 37.118 10.242 47.243 27.78l40.199 69.626h106.947v55.556h-74.872l32.066 55.54 19.878 34.43-65.68-2.651-106.65-184.723-292.068 168.625-103.849-4.193 19.972-11.532 96.154-55.514h-163.84v.018c-15.341 0-27.778 12.437-27.778 27.778s12.437 27.778 27.778 27.778v55.555c-17.76 0-34.22-5.555-47.742-15.022l-35.608-.002v-69.444h.026l.002-.243c.724-44.644 36.554-80.754 81.088-81.926l.001-.047h262.297L554.74 76.705c8.77-5.062 18.344-7.463 27.79-7.452z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPaid" }, props, { ref }), React__namespace.createElement(SvgIcon$1o, null));
  });
  const SvgIcon$1n = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "nonzero" }, React__namespace.createElement("path", { d: "M766.059 337.827l7.246 7.013c6.306 6.103 5.847 15.79-.763 22.188L456.809 672.594c-9.823 9.507-25.951 9.09-36.063-.696l-137.63-133.197c-6.24-6.04-7.25-15.432-1.749-22.153l12.862-15.716c5.272-6.443 15.135-8.06 22.105-3.551l111.327 72.018c5.872 3.8 15.979 3.305 21.461-1.007l294.172-231.317c6.612-5.2 16.97-4.757 22.765.852z" }), React__namespace.createElement("path", { d: "M500 888.889c214.777 0 388.889-174.112 388.889-388.889 0-214.777-174.112-388.889-388.889-388.889-214.777 0-388.889 174.112-388.889 388.889 0 214.777 174.112 388.889 388.889 388.889zm0 55.555C254.54 944.444 55.556 745.46 55.556 500S254.54 55.556 500 55.556 944.444 254.54 944.444 500 745.46 944.444 500 944.444z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPassed" }, props, { ref }), React__namespace.createElement(SvgIcon$1n, null));
  });
  const SvgIcon$1m = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M409.722 333.333c19.177 0 34.722 15.546 34.722 34.723v263.888c0 19.177-15.545 34.723-34.722 34.723-19.176 0-34.722-15.546-34.722-34.723V368.056c0-19.177 15.546-34.723 34.722-34.723zm180.556 0c19.176 0 34.722 15.546 34.722 34.723v263.888c0 19.177-15.546 34.723-34.722 34.723-19.177 0-34.722-15.546-34.722-34.723V368.056c0-19.177 15.545-34.723 34.722-34.723zM500 888.89c214.777 0 388.889-174.112 388.889-388.889 0-214.777-174.112-388.889-388.889-388.889-214.777 0-388.889 174.112-388.889 388.889 0 214.777 174.112 388.889 388.889 388.889zm0 55.555C254.54 944.444 55.556 745.46 55.556 500S254.54 55.556 500 55.556 944.444 254.54 944.444 500 745.46 944.444 500 944.444z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPauseCircleO" }, props, { ref }), React__namespace.createElement(SvgIcon$1m, null));
  });
  const SvgIcon$1l = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 944.444C254.54 944.444 55.556 745.46 55.556 500S254.54 55.556 500 55.556 944.444 254.54 944.444 500 745.46 944.444 500 944.444zm-90.278-611.11c-19.176 0-34.722 15.545-34.722 34.722v263.888c0 19.177 15.546 34.723 34.722 34.723 19.177 0 34.722-15.546 34.722-34.723V368.056c0-19.177-15.545-34.723-34.722-34.723zm180.556 0c-19.177 0-34.722 15.545-34.722 34.722v263.888c0 19.177 15.545 34.723 34.722 34.723 19.176 0 34.722-15.546 34.722-34.723V368.056c0-19.177-15.546-34.723-34.722-34.723z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPauseCircle" }, props, { ref }), React__namespace.createElement(SvgIcon$1l, null));
  });
  const SvgIcon$1k = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M333.333 138.889c46.024 0 83.334 37.31 83.334 83.333v555.556c0 46.024-37.31 83.333-83.334 83.333-46.023 0-83.333-37.31-83.333-83.333V222.222c0-46.024 37.31-83.333 83.333-83.333zm333.334 0c46.023 0 83.333 37.31 83.333 83.333v555.556c0 46.024-37.31 83.333-83.333 83.333-46.024 0-83.334-37.31-83.334-83.333V222.222c0-46.024 37.31-83.333 83.334-83.333z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPause" }, props, { ref }), React__namespace.createElement(SvgIcon$1k, null));
  });
  const SvgIcon$1j = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M888.889 333.333v444.445H111.11V333.333H888.89zm0-111.11v55.555H111.11v-55.556H888.89zm0-55.556H111.11c-30.722 0-55.555 24.833-55.555 55.555v555.556c0 30.722 24.833 55.555 55.555 55.555H888.89c30.667 0 55.555-24.833 55.555-55.555V222.222c0-30.722-24.888-55.555-55.555-55.555zm-340.05 467.45H682.95l-31.111 31.166c-10.889 10.834-10.889 28.39 0 39.278 10.833 10.833 28.389 10.833 39.278 0l78.555-78.555c10.834-10.89 10.834-28.445 0-39.334l-78.555-78.555c-10.89-10.834-28.445-10.834-39.278 0-10.889 10.889-10.889 28.444 0 39.277l31.111 31.167H548.839c-15.333 0-27.778 12.445-27.778 27.778 0 15.333 12.445 27.778 27.778 27.778", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPeerPay" }, props, { ref }), React__namespace.createElement(SvgIcon$1j, null));
  });
  const SvgIcon$1i = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M111.111 222.222v555.556H888.89V222.222H111.11zm0-55.555H888.89c30.682 0 55.555 24.873 55.555 55.555v555.556c0 30.682-24.873 55.555-55.555 55.555H111.11c-30.682 0-55.555-24.873-55.555-55.555V222.222c0-30.682 24.873-55.555 55.555-55.555zM916.667 361.11v55.556H611.11c-46.024 0-83.333 37.31-83.333 83.333 0 46.024 37.31 83.333 83.333 83.333h305.556v55.556H611.11c-76.706 0-138.889-62.183-138.889-138.889 0-76.706 62.183-138.889 138.89-138.889h305.555zM680.556 541.667c-23.012 0-41.667-18.655-41.667-41.667s18.655-41.667 41.667-41.667c23.011 0 41.666 18.655 41.666 41.667s-18.655 41.667-41.666 41.667z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPendingPayment" }, props, { ref }), React__namespace.createElement(SvgIcon$1i, null));
  });
  const SvgIcon$1h = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "nonzero" }, React__namespace.createElement("path", { d: "M500 888.889c214.777 0 388.889-174.112 388.889-388.889 0-214.777-174.112-388.889-388.889-388.889-214.777 0-388.889 174.112-388.889 388.889 0 214.777 174.112 388.889 388.889 388.889zm0 55.555C254.54 944.444 55.556 745.46 55.556 500S254.54 55.556 500 55.556 944.444 254.54 944.444 500 745.46 944.444 500 944.444z" }), React__namespace.createElement("path", { d: "M424.637 385.957c-5.88-11.14-14.05-24.352-22.897-36.991-8.742-12.49-17.897-24.134-26.313-32.862-7.953-8.248-11.739-10.548-11.342-10.548-4.51 0-20.957 15.064-32.707 30.729-14.685 19.583-25.822 42.224-25.822 59.164 0 17.823 11.983 46.263 31 77.126 20.357 33.035 48.78 68.956 79.593 100.58l10.44 10.443c31.88 31.066 67.8 59.49 100.836 79.846 30.847 19.013 59.3 31 77.123 31 16.945 0 39.592-11.139 59.165-25.82 15.667-11.752 30.731-28.198 30.731-32.71 0 .398-2.3-3.387-10.544-11.337-8.732-8.42-20.376-17.574-32.864-26.316-12.651-8.854-25.86-17.021-36.989-22.895-12.709-6.707-18.068-8.4-19.894-8.435.34.005.273.123-1.436 2.6-2.262 3.276-4.17 7.178-8.277 16.683-1.353 3.127-1.353 3.127-3.104 7.02-.894 1.933-.894 1.933-1.864 3.937-2.254 4.588-4.25 8.082-6.832 11.322l-10.971 13.764-17.131-4.043c-10.148-2.395-24.785-9.9-42.996-22.303-18.456-12.571-38.284-28.688-53.982-43.99-14.785-15.181-30.902-35.01-43.471-53.465-12.4-18.204-19.906-32.844-22.302-42.993l-4.046-17.135 13.769-10.972c3.24-2.583 6.735-4.579 11.327-6.834 1.998-.967 1.998-.967 3.926-1.858 3.898-1.752 3.898-1.752 7.034-3.109 9.506-4.11 13.402-6.015 16.685-8.28 2.458-1.695 2.579-1.765 2.584-1.43-.034-1.829-1.725-7.184-8.429-19.888zm-37.075 237.178l-10.95-10.952c-33.828-34.716-64.781-73.834-87.353-110.463C265.134 462.567 250 426.65 250 395.449c0-32.38 15.534-63.96 36.933-92.497C310.208 271.922 334.141 250 364.085 250c18.342 0 33.884 9.446 51.335 27.542 10.786 11.187 21.572 24.906 31.833 39.565 10.122 14.46 19.5 29.627 26.517 42.92 10.634 20.151 14.852 33.744 14.852 45.88 0 19.201-9.832 35.535-26.596 47.1-4.963 3.423-9.292 5.86-15.583 8.813a276.228 276.228 0 003.562 5.36c10.779 15.827 24.856 33.147 36.836 45.46 12.83 12.497 30.151 26.576 45.975 37.355 1.87 1.272 3.66 2.46 5.361 3.562 2.953-6.292 5.396-10.628 8.82-15.586 11.565-16.762 27.895-26.596 47.1-26.596 12.131 0 25.726 4.222 45.88 14.858 13.28 7.008 28.443 16.385 42.916 26.514 14.66 10.261 28.378 21.048 39.569 31.837 18.092 17.447 27.538 32.99 27.538 51.33 0 29.945-21.922 53.878-52.952 77.152-28.522 21.395-60.113 36.934-92.5 36.934-31.2 0-67.136-15.14-106.27-39.26-36.628-22.571-75.745-53.525-110.716-87.605z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPhoneCircleO" }, props, { ref }), React__namespace.createElement(SvgIcon$1h, null));
  });
  const SvgIcon$1g = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 55.556c245.46 0 444.444 198.984 444.444 444.444S745.46 944.444 500 944.444 55.556 745.46 55.556 500 254.54 55.556 500 55.556zM364.085 250c-29.944 0-53.877 21.922-77.152 52.952C265.534 331.488 250 363.068 250 395.45c0 31.2 15.134 67.118 39.259 106.27 22.572 36.63 53.525 75.748 87.354 110.464l10.949 10.952c34.97 34.08 74.088 65.034 110.717 87.605 39.133 24.12 75.068 39.26 106.27 39.26 32.386 0 63.977-15.54 92.5-36.934C728.077 689.792 750 665.86 750 635.915c0-18.342-9.446-33.884-27.538-51.33-11.19-10.79-24.91-21.577-39.57-31.838-14.472-10.13-29.635-19.506-42.915-26.514-20.154-10.636-33.749-14.858-45.88-14.858-19.205 0-35.535 9.834-47.1 26.596-3.424 4.958-5.867 9.294-8.82 15.586a276.654 276.654 0 01-5.36-3.562c-15.825-10.78-33.146-24.858-45.976-37.354-11.98-12.314-26.057-29.634-36.836-45.46a276.228 276.228 0 01-3.562-5.36c6.29-2.953 10.62-5.391 15.583-8.813 16.764-11.566 26.596-27.9 26.596-47.102 0-12.135-4.218-25.728-14.852-45.88-7.016-13.292-16.395-28.459-26.517-42.919-10.26-14.659-21.047-28.378-31.833-39.565C397.97 259.446 382.427 250 364.085 250zm0 55.556c-.397 0 3.389 2.3 11.342 10.548 8.416 8.728 17.57 20.373 26.313 32.862 8.847 12.64 17.017 25.85 22.897 36.991 6.704 12.704 8.395 18.06 8.43 19.887l-.003-.054c-.026-.266-.269-.11-2.582 1.486-3.283 2.264-7.18 4.169-16.685 8.28-3.136 1.356-3.136 1.356-7.034 3.108-1.928.891-1.928.891-3.926 1.858-4.592 2.255-8.087 4.251-11.327 6.834l-13.77 10.972 4.047 17.135c2.396 10.15 9.902 24.789 22.302 42.993 12.569 18.455 28.686 38.284 43.471 53.465 15.698 15.302 35.526 31.419 53.982 43.99 18.211 12.403 32.848 19.908 42.996 22.303l17.13 4.043 10.972-13.764c2.582-3.24 4.578-6.734 6.832-11.322.97-2.004.97-2.004 1.864-3.937.904-2.01 1.341-2.982 1.739-3.882l.148-.336c.32-.73.65-1.49 1.217-2.802 4.107-9.505 6.015-13.407 8.277-16.683 1.71-2.477 1.777-2.595 1.436-2.6 1.826.035 7.185 1.728 19.894 8.435 11.13 5.874 24.338 14.041 36.989 22.895 12.488 8.742 24.132 17.897 32.864 26.316 8.244 7.95 10.544 11.735 10.544 11.338 0 4.51-15.064 20.957-30.731 32.709-19.573 14.681-42.22 25.82-59.165 25.82-17.824 0-46.276-11.987-77.123-31-33.035-20.357-68.956-48.78-100.836-79.846l-10.44-10.443c-30.813-31.624-59.236-67.545-79.593-100.58-19.017-30.863-31-59.303-31-77.126 0-16.94 11.137-39.581 25.822-59.164 11.75-15.665 28.196-30.73 32.707-30.73z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPhoneCircle" }, props, { ref }), React__namespace.createElement(SvgIcon$1g, null));
  });
  const SvgIcon$1f = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M295.13 166.637c-.723 0-1.39.055-2.112.055-23.278 1-51.666 18.445-86.666 53.445-139.723 139.777 136.5 419.277 139.333 422.11 2.833 2.723 282.167 279.223 422.111 139.278 35-35 52.444-63.333 53.444-86.61.834-21.5-11.666-43.945-40.722-73-28.778-28.834-52.833-42.445-72.833-40.612-18.278 1.778-37.778 17.89-57.945 47.945-18.166 30.444-43.277 39.722-60.944 41.889-46 5.888-100.389-25.834-173.278-98.723-72.944-73-104.333-128.055-98.722-173.222 2.167-17.722 11.389-42.778 43.056-61.778 28.888-19.389 45-38.889 46.777-57.166 1.89-19.5-11.777-44-40.666-72.89-28-28-50-40.721-70.834-40.721m376.167 710.166c-167.111 0-354.778-185.166-364.889-195.278-13.055-13.11-317.944-322.055-139.333-500.666 45.944-45.945 85.222-68.111 123.666-69.667 51.39-1.944 89.167 31.5 114.5 56.89 41.778 41.721 60.334 80.221 56.667 117.555-3.555 36.11-27.167 68.388-72.333 98.666-14.5 8.722-16.945 16.111-17.667 21.667-1.778 14.667 6.556 50.778 82.889 127.167 76.278 76.222 112.389 84.333 127.167 82.888 5.555-.722 12.944-3.222 20.889-16.5 31.055-46.333 63.333-70 99.444-73.5 36.833-4.166 75.722 14.778 117.5 56.612 25.389 25.388 59 64.888 56.944 114.555-1.61 38.39-23.722 77.667-69.666 123.611-40.278 40.278-87.167 56-135.778 56", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPhoneO" }, props, { ref }), React__namespace.createElement(SvgIcon$1f, null));
  });
  const SvgIcon$1e = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M818.386 630.252a854.628 854.628 0 0110.747 9.133c23.422 20.25 32.808 31.484 33.802 32.7.015.018 2.042 2.486 4.058 4.975a331.072 331.072 0 012.89 3.61c.495.63.904 1.161 1.186 1.542a20.98 20.98 0 011.61 2.524l4.978 7.571v.722c9.807 20.553 2.962 47.657-3.161 61.354-10.802 24.166-31.145 48.673-46.58 63.551-31.067 29.938-73.547 64.302-126.741 64.302-5.558 0-11.217-.38-16.817-1.125-38.744-5.067-97.94-29.434-162.37-66.85-69.939-40.614-137.416-91.721-190.001-143.904-52.591-52.197-104.107-119.205-145.059-188.683-37.8-64.132-62.457-123.19-67.648-162.03-3.413-25.436 2.603-53.727 17.402-81.803 13.219-25.08 32.933-49.276 57.014-69.974 1.424-1.225 2.82-2.43 4.197-3.618 18.517-15.983 34.52-29.797 61.067-40.125 9.327-4.12 18.101-6.124 26.811-6.124 8.014 0 16.04 1.747 23.856 5.193l.355.161c3.526 1.657 9.35 4.828 10.882 5.668 4.568 2.303 29.546 16.083 57.197 54.51 8.83 12.28 22.732 33.007 32.857 51.024 17.035 30.318 28.122 56.516 28.585 57.618l.317.752 2.145 6.742c7.14 19.025 2.946 38.767-11.271 52.953-.824.849-1.785 1.863-1.804 1.882l-1.18 1.246-.892.626c-.604.52-1.802 1.586-2.564 2.264-2.157 1.919-2.812 2.498-3.566 3.07l-.657.476c-9.13 6.27-12.418 8.147-15.897 10.134-2.362 1.349-4.804 2.742-10.08 6.184l-.244.156c-9.005 5.651-17.54 9.209-26.577 12.978-7.113 2.964-15.175 6.325-24.98 11.323-14.067 7.17-14.565 27.57-11.664 34.33 17.352 40.45 48.168 81.385 99.916 132.728 45.62 45.314 90.452 74.318 128.29 96.712 4.597 2.721 9.147 4.043 13.908 4.043 13.37 0 26.2-10.877 31.962-21.62 4.434-8.271 8.59-16.924 12.257-24.557 2.99-6.227 5.815-12.108 8.5-17.209l.065-.12c6.692-12.476 11.599-20.487 14.536-25.01 2.096-3.227 4.142-6.377 6.535-8.934 5.769-8.513 14.853-15.671 24.512-19.148 5.43-1.957 11.714-2.993 18.165-2.993 8.324 0 16.29 1.751 22.427 4.931l16.474 8.617-.011.021c1.254.674 2.544 1.508 4.045 2.479 1.81 1.17 4.444 2.889 7.766 5.08a1617.985 1617.985 0 0126.862 18.147 411.87 411.87 0 015.932 4.17l45.656 35.625z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPhone" }, props, { ref }), React__namespace.createElement(SvgIcon$1e, null));
  });
  const SvgIcon$1d = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M389.334 167l-18.5 55.556H111.556v388.889l71.833-71.833c20.051-20.052 51.558-21.594 73.372-4.628l5.24 4.628 71.777 71.833 102.89-123.5L556 667l-55.556 166.667h-388.89c-28.476 0-51.97-21.46-55.181-49.08L56 778.112V222.556c0-28.528 21.46-51.978 49.08-55.183l6.476-.373h277.778zm500 0c28.528 0 51.978 21.412 55.183 49.07l.373 6.486v555.556c0 28.476-21.412 51.97-49.07 55.182l-6.486.374H611.556L667.112 667 498.389 413.889l71.112-85.278c20.533-24.681 57.182-26.569 80.135-5.481l4.698 4.87 235 274.167V222.556H481.945l18.5-55.556h388.89zM306.028 278.089c15.508 0 30.03 4.243 42.47 11.63l-14.72 43.948 45.282 67.904c-14.188 25.737-41.585 43.185-73.032 43.185-46 0-83.333-37.333-83.333-83.334 0-46 37.333-83.333 83.333-83.333z", fillRule: "evenodd" }));
  const SvgPhotoFail = React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPhotoFail" }, props, { ref }), React__namespace.createElement(SvgIcon$1d, null));
  });
  const SvgIcon$1c = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M305.556 388.889c-15.334 0-27.778-12.5-27.778-27.778 0-15.278 12.444-27.778 27.778-27.778 15.333 0 27.777 12.5 27.777 27.778 0 15.278-12.444 27.778-27.777 27.778m0-111.111c-46.056 0-83.334 37.333-83.334 83.333s37.278 83.333 83.334 83.333c46.055 0 83.333-37.333 83.333-83.333s-37.278-83.333-83.333-83.333" }), React__namespace.createElement("path", { d: "M653.889 327.667c-11.056-12.945-26.611-19.445-42.167-19.445-15.778 0-31.555 6.722-42.666 20.056L333.333 611.11l-71.777-71.833C250.666 528.388 236.444 523 222.222 523c-14.166 0-28.389 5.389-39.278 16.278l-71.833 71.833V222.222H888.89v379.611l-235-274.166zm235 450.11H111.11v-88.11l111.111-111.111 71.834 71.833c23.11 23.111 61.055 21.333 82-3.778L611.61 363.778h.111L888.89 687.222v90.556zm0-611.11H111.11c-30.667 0-55.555 24.833-55.555 55.555v555.555c0 30.667 24.888 55.556 55.555 55.556H888.89c30.722 0 55.555-24.889 55.555-55.555V222.222c0-30.722-24.833-55.555-55.555-55.555z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPhotoO" }, props, { ref }), React__namespace.createElement(SvgIcon$1c, null));
  });
  const SvgIcon$1b = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M305.583 277.756c-46 0-83.333 37.333-83.333 83.333s37.333 83.333 83.333 83.333 83.334-37.333 83.334-83.333-37.334-83.333-83.334-83.333m348.306 49.91c-22.333-26.11-62.833-25.833-84.833.612L333.333 611.11l-71.777-71.833c-21.723-21.722-56.89-21.722-78.612 0l-71.833 71.833V222.222H888.89v379.611l-235-274.166zm235-161H111.11c-30.667 0-55.555 24.834-55.555 55.556v555.555c0 30.667 24.888 55.556 55.555 55.556H888.89c30.722 0 55.555-24.889 55.555-55.555V222.222c0-30.722-24.833-55.555-55.555-55.555z", fillRule: "evenodd" }));
  const SvgPhoto = React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPhoto" }, props, { ref }), React__namespace.createElement(SvgIcon$1b, null));
  });
  const SvgIcon$1a = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M618.416 111.111a55.556 55.556 0 0146.225 24.739l57.581 86.372H888.89c30.682 0 55.555 24.873 55.555 55.556v555.555c0 30.683-24.873 55.556-55.555 55.556H111.11c-30.682 0-55.555-24.873-55.555-55.556V277.778c0-30.683 24.873-55.556 55.555-55.556h166.667l57.581-86.372a55.556 55.556 0 0146.225-24.739h236.832zM500 333.333c-122.73 0-222.222 99.493-222.222 222.223 0 122.73 99.492 222.222 222.222 222.222s222.222-99.493 222.222-222.222c0-122.73-99.492-222.223-222.222-222.223zm0 111.111c61.365 0 111.111 49.747 111.111 111.112 0 61.365-49.746 111.11-111.111 111.11s-111.111-49.745-111.111-111.11S438.635 444.444 500 444.444z", fillRule: "evenodd" }));
  const SvgPhotograph = React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPhotograph" }, props, { ref }), React__namespace.createElement(SvgIcon$1a, null));
  });
  const SvgIcon$19 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M667.75 521.737L462.214 686.164c-11.98 9.584-29.46 7.642-39.043-4.338a27.778 27.778 0 01-6.087-17.353V335.62c0-15.34 12.436-27.777 27.778-27.777a27.778 27.778 0 0117.352 6.086L667.75 478.356c11.98 9.583 13.922 27.064 4.338 39.043a27.778 27.778 0 01-4.338 4.338zM500 888.89c214.777 0 388.889-174.112 388.889-388.889 0-214.777-174.112-388.889-388.889-388.889-214.777 0-388.889 174.112-388.889 388.889 0 214.777 174.112 388.889 388.889 388.889zm0 55.555C254.54 944.444 55.556 745.46 55.556 500S254.54 55.556 500 55.556 944.444 254.54 944.444 500 745.46 944.444 500 944.444z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPlayCircleO" }, props, { ref }), React__namespace.createElement(SvgIcon$19, null));
  });
  const SvgIcon$18 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 944.444C254.54 944.444 55.556 745.46 55.556 500S254.54 55.556 500 55.556 944.444 254.54 944.444 500 745.46 944.444 500 944.444zm167.75-422.707a27.778 27.778 0 004.337-4.338c9.584-11.98 7.642-29.46-4.338-39.043L462.215 313.928a27.778 27.778 0 00-17.352-6.086c-15.342 0-27.778 12.436-27.778 27.777v328.854a27.778 27.778 0 006.087 17.353c9.584 11.98 27.064 13.922 39.043 4.338L667.75 521.737z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPlayCircle" }, props, { ref }), React__namespace.createElement(SvgIcon$18, null));
  });
  const SvgIcon$17 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M767.38 527.269L378.465 838.402c-11.98 9.584-29.46 7.641-39.044-4.338a27.778 27.778 0 01-6.087-17.353V194.444c0-15.34 12.437-27.777 27.778-27.777a27.778 27.778 0 0117.353 6.087L767.38 483.887c11.979 9.584 13.921 27.064 4.338 39.044a27.778 27.778 0 01-4.338 4.338z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPlay" }, props, { ref }), React__namespace.createElement(SvgIcon$17, null));
  });
  const SvgIcon$16 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M537.5 537.5v325c0 20.71-16.79 37.5-37.5 37.5s-37.5-16.79-37.5-37.5v-325h-325c-20.71 0-37.5-16.79-37.5-37.5s16.79-37.5 37.5-37.5h325v-325c0-20.71 16.79-37.5 37.5-37.5s37.5 16.79 37.5 37.5v325h325c20.71 0 37.5 16.79 37.5 37.5s-16.79 37.5-37.5 37.5h-325z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPlus" }, props, { ref }), React__namespace.createElement(SvgIcon$16, null));
  });
  const SvgIcon$15 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M727.566 114.481c32.544 32.544 14.956 102.895-39.283 157.135a234.744 234.744 0 01-6.4 6.163l151.45-.001c30.683 0 55.556 24.873 55.556 55.555v111.111c0 30.376-24.378 55.058-54.637 55.549l-.919.007v333.333c0 30.683-24.873 55.556-55.555 55.556H222.222c-30.682 0-55.555-24.873-55.555-55.556V500c-30.683 0-55.556-24.873-55.556-55.556v-111.11c0-30.683 24.873-55.556 55.556-55.556l187.942.001a234.743 234.743 0 01-6.4-6.163c-54.24-54.24-71.827-124.591-39.283-157.135 32.543-32.544 102.895-14.956 157.134 39.284 26.578 26.577 44.355 57.023 51.746 84.994l.44 1.71c7.109-28.437 25.066-59.584 52.185-86.704 54.24-54.24 124.592-71.828 157.135-39.284zM472.222 500l-250 .001v333.333h250V499.998zm305.556.001h-250v333.332l250 .001V500zM472.222 333.332l-305.555.001v111.111h305.555V333.332zm361.111.001H527.777v111.111h305.556v-111.11zM609.715 193.05c-35.366 35.366-44.79 73.06-39.284 78.567 5.507 5.506 43.201-3.917 78.568-39.284 35.367-35.366 44.79-73.06 39.284-78.567-5.507-5.507-43.201 3.917-78.568 39.284zM348.21 153.765c-5.506 5.506 3.917 43.2 39.284 78.567 35.367 35.367 73.06 44.79 78.567 39.284 5.507-5.507-3.917-43.2-39.283-78.567-35.367-35.367-73.061-44.79-78.568-39.284z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPointGiftO" }, props, { ref }), React__namespace.createElement(SvgIcon$15, null));
  });
  const SvgIcon$14 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M630.833 246.217c-15.055 15.055-29.11 24-41.666 30.333h-38.223c1.445-13.833 11.945-41.055 40.556-69.666 38.056-38 73.667-44.278 78.611-39.278 4.889 4.889-1.278 40.555-39.278 78.61zM410.89 276.55c-12.556-6.333-26.611-15.278-41.611-30.278-38.056-38.11-44.167-73.722-39.278-78.61.944-.945 2.944-1.445 5.778-1.445 12.61 0 41.889 9.833 72.833 40.722 28.5 28.556 39.056 55.722 40.5 69.611H410.89zm61.361 222.217v388.889h-250c-30.415 0-55.058-24.34-55.548-54.636l-.008-.92V498.767H472.25zm361.111 0V832.1c0 30.722-24.833 55.556-55.555 55.556h-250v-388.89H833.36zM447.89 167.66c26.944 26.945 44.611 56.611 52.167 83.89 7.5-27.279 25.166-56.945 52.166-83.945 56-56.056 123.722-72.834 157.167-39.278 31.46 31.57 18.053 92.87-29.817 146.596l-1.46 1.626h155.277c30.36 0 55.057 24.34 55.548 54.636l.007.92v55.555c0 30.415-24.393 55.059-54.637 55.548l-.918.008H527.833V276.55h-55.555v166.667H166.667c-30.36 0-55.058-24.34-55.548-54.636l-.008-.92v-55.555c0-30.415 24.394-55.059 54.637-55.548l.919-.008h155.277c-49.11-54.166-63.055-116.333-31.222-148.166 33.5-33.723 101.167-16.723 157.167 39.277z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPointGift" }, props, { ref }), React__namespace.createElement(SvgIcon$14, null));
  });
  const SvgIcon$13 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "nonzero" }, React__namespace.createElement("path", { d: "M500 472.222c-228.552 0-416.667-80.62-416.667-194.444C83.333 163.954 271.448 83.333 500 83.333c228.552 0 416.667 80.62 416.667 194.445 0 113.824-188.115 194.444-416.667 194.444zm0-55.555c201.002 0 361.111-68.618 361.111-138.89 0-70.27-160.109-138.888-361.111-138.888-201.002 0-361.111 68.618-361.111 138.889 0 70.27 160.109 138.889 361.111 138.889z" }), React__namespace.createElement("path", { d: "M199.455 363.207l23.81 50.195c-55.488 26.32-84.376 57.859-84.376 86.598 0 70.27 160.109 138.889 361.111 138.889 201.002 0 361.111-68.618 361.111-138.889 0-30.411-32.381-63.863-93.63-90.827l22.384-50.846C869.058 393.19 916.667 442.372 916.667 500c0 113.824-188.115 194.444-416.667 194.444-228.552 0-416.667-80.62-416.667-194.444 0-54.948 43.35-102.273 116.122-136.793z" }), React__namespace.createElement("path", { d: "M199.97 585.186l23.738 50.228c-55.765 26.356-84.82 57.987-84.82 86.808 0 70.271 160.11 138.89 361.112 138.89s361.111-68.619 361.111-138.89c0-30.116-31.75-63.23-91.973-90.092l22.63-50.737c78.053 34.814 124.899 83.672 124.899 140.83 0 113.823-188.115 194.444-416.667 194.444-228.552 0-416.667-80.62-416.667-194.445 0-55.079 43.554-102.496 116.637-137.036z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPoints" }, props, { ref }), React__namespace.createElement(SvgIcon$13, null));
  });
  const SvgIcon$12 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M833.333 777.778V611.11H166.667v166.667H111.11c-30.682 0-55.555-24.873-55.555-55.556V388.89c0-30.683 24.873-55.556 55.555-55.556H888.89c30.682 0 55.555 24.873 55.555 55.556v333.333c0 30.683-24.873 55.556-55.555 55.556h-55.556zM222.223 111.11h555.555c30.682 0 55.555 24.873 55.555 55.556v111.11H166.667v-111.11c0-30.683 24.873-55.556 55.555-55.556zM819.443 500c23.012 0 41.667-18.655 41.667-41.667s-18.655-41.666-41.667-41.666c-23.011 0-41.666 18.654-41.666 41.666 0 23.012 18.655 41.667 41.666 41.667zM222.222 666.667h555.556v166.666c0 30.683-24.873 55.556-55.556 55.556H277.778c-30.683 0-55.556-24.873-55.556-55.556V666.667z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgPrinter" }, props, { ref }), React__namespace.createElement(SvgIcon$12, null));
  });
  const SvgIcon$11 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M708.333 861.111c-23.012 0-41.666-18.655-41.666-41.667 0-23.011 18.654-41.666 41.666-41.666 23.012 0 41.667 18.655 41.667 41.666 0 23.012-18.655 41.667-41.667 41.667zm125-194.444h55.556l-55.556 55.555v-42.075l6.74 2.792-6.74-6.74v-9.532zm-277.777-32.544l55.555 55.556v199.21c-30.682 0-55.555-24.873-55.555-55.556v-199.21zM750 527.778v138.889h83.333v-138.89c30.683 0 55.556 24.874 55.556 55.556v138.89h-88.1L694.445 615.876v-32.544h-32.543l-55.37-55.37a56.305 56.305 0 014.58-.185H750zm-638.889-338.1l55.556 55.556v171.433h171.432l55.556 55.555H166.667c-30.683 0-55.556-24.873-55.556-55.555V189.679zm305.556-78.567c30.682 0 55.555 24.873 55.555 55.556v226.988l-55.555-55.556V166.667H245.234L189.68 111.11h226.988zm166.666 55.556v250h250v-250h-250zm0-55.556h250c30.683 0 55.556 24.873 55.556 55.556v250c0 30.682-24.873 55.555-55.556 55.555h-250c-30.682 0-55.555-24.873-55.555-55.555v-250c0-30.683 24.873-55.556 55.555-55.556zM166.667 583.333v250h250v-250h-250zm0-55.555h250c30.682 0 55.555 24.873 55.555 55.555v250c0 30.683-24.873 55.556-55.555 55.556h-250c-30.683 0-55.556-24.873-55.556-55.556v-250c0-30.682 24.873-55.555 55.556-55.555z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgQrInvalid" }, props, { ref }), React__namespace.createElement(SvgIcon$11, null));
  });
  const SvgIcon$10 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M750 527.778v138.888h83.333V527.778c30.683 0 55.556 24.873 55.556 55.555v138.89H694.444v-138.89H611.11v305.556c-30.682 0-55.555-24.873-55.555-55.556V528.778a1 1 0 011-1H750zm-41.667 250c23.012 0 41.667 18.655 41.667 41.666 0 23.012-18.655 41.667-41.667 41.667s-41.666-18.655-41.666-41.667c0-23.011 18.654-41.666 41.666-41.666zm138.89 0c23.011 0 41.666 18.655 41.666 41.666 0 23.012-18.655 41.667-41.667 41.667s-41.666-18.655-41.666-41.667c0-23.011 18.654-41.666 41.666-41.666z" }), React__namespace.createElement("path", { d: "M166.667 166.667v250h250v-250h-250zm250 361.11c30.682 0 55.555 24.874 55.555 55.556v250c0 30.683-24.873 55.556-55.555 55.556h-250c-30.683 0-55.556-24.873-55.556-55.556v-250c0-30.682 24.873-55.555 55.556-55.555h250zm0 55.556h-250v250h250v-250zm0-472.222c30.682 0 55.555 24.873 55.555 55.556v250c0 30.682-24.873 55.555-55.555 55.555h-250c-30.683 0-55.556-24.873-55.556-55.555v-250c0-30.683 24.873-55.556 55.556-55.556h250zm416.666 0c30.683 0 55.556 24.873 55.556 55.556v250c0 30.682-24.873 55.555-55.556 55.555h-250c-30.682 0-55.555-24.873-55.555-55.555v-250c0-30.683 24.873-55.556 55.555-55.556h250zm0 55.556h-250v250h250v-250z", fillRule: "nonzero" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgQr" }, props, { ref }), React__namespace.createElement(SvgIcon$10, null));
  });
  const SvgIcon$$ = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 888.889c-214.389 0-388.889-174.5-388.889-388.889S285.611 111.111 500 111.111 888.889 285.611 888.889 500 714.389 888.889 500 888.889m0-833.333c-245.444 0-444.444 199-444.444 444.444 0 245.444 199 444.444 444.444 444.444 245.444 0 444.444-199 444.444-444.444 0-245.444-199-444.444-444.444-444.444m6.456 222.222c-44.612 0-80 12.778-105.612 39.055-26.277 25.667-39.055 60.445-39.055 105.056v1c0 17.944 14.444 32.444 32.389 32.444 17.889 0 32.389-14.5 32.389-32.444 0-.389-.111-1-.111-1 0-26.945 5.444-48.222 16.444-62.889 12.222-17.111 32.333-25.667 59.889-25.667 21.944 0 39.055 6.111 51.222 18.334 11.611 12.222 17.778 28.722 17.778 50.055 0 15.89-5.556 30.5-16.556 44.556l-10.389 11.61c-37.777 33.556-60.333 59-69.61 75.668-13.834 24.944-11.334 48-11.334 48 0 17.888 14.556 32.388 32.444 32.388 17.945 0 29.778-12.333 32.39-32.388 0 0 3.333-18.667 10.055-30.89 5.5-10.944 14.055-21.388 25-31.11 29.389-25.056 46.444-40.945 51.889-47.667 14.666-19.5 22.555-44.556 22.555-74.445 0-36.61-12.166-65.944-35.944-87.333-24.445-21.944-56.167-32.333-95.833-32.333m-10.417 357.15c-12.778 0-23.222 3.666-31.111 12.222-9.222 7.889-13.5 18.333-13.5 31.111 0 12.222 4.278 22.611 13.5 31.167 7.889 8.5 18.333 12.778 31.11 12.778 12.279 0 23.223-4.278 32.39-12.167 8.5-8.611 12.778-18.945 12.778-31.778 0-12.778-4.278-23.222-12.778-31.111-8.556-8.556-19.556-12.222-32.39-12.222", fillRule: "evenodd" }));
  const SvgQuestionO = React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgQuestionO" }, props, { ref }), React__namespace.createElement(SvgIcon$$, null));
  });
  const SvgIcon$_ = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 55.556c245.444 0 444.444 199 444.444 444.444 0 245.444-199 444.444-444.444 444.444-245.444 0-444.444-199-444.444-444.444 0-245.444 199-444.444 444.444-444.444zm-3.961 579.372c-12.778 0-23.222 3.666-31.111 12.222-9.222 7.889-13.5 18.333-13.5 31.111 0 12.222 4.278 22.611 13.5 31.167 7.889 8.5 18.333 12.778 31.11 12.778 12.279 0 23.223-4.278 32.39-12.167 8.5-8.611 12.778-18.945 12.778-31.778 0-12.778-4.278-23.222-12.778-31.111-8.556-8.556-19.556-12.222-32.39-12.222zm10.417-357.15c-44.612 0-80 12.778-105.612 39.055-26.277 25.667-39.055 60.445-39.055 105.056v1c0 17.944 14.444 32.444 32.389 32.444 17.889 0 32.389-14.5 32.389-32.444 0-.389-.111-1-.111-1 0-26.945 5.444-48.222 16.444-62.889 12.222-17.111 32.333-25.667 59.889-25.667 21.944 0 39.055 6.111 51.222 18.334 11.611 12.222 17.778 28.722 17.778 50.055 0 15.89-5.556 30.5-16.556 44.556l-10.389 11.61c-37.777 33.556-60.333 59-69.61 75.668-13.834 24.944-11.334 48-11.334 48 0 17.888 14.556 32.388 32.444 32.388 17.945 0 29.778-12.333 32.39-32.388 0 0 3.333-18.667 10.055-30.89 5.5-10.944 14.055-21.388 25-31.11 29.389-25.056 46.444-40.945 51.889-47.667 14.666-19.5 22.555-44.556 22.555-74.445 0-36.61-12.166-65.944-35.944-87.333-24.445-21.944-56.167-32.333-95.833-32.333z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgQuestion" }, props, { ref }), React__namespace.createElement(SvgIcon$_, null));
  });
  const SvgIcon$Z = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M527.778 111.111H218.167c-28.445 0-51.5 23.056-51.5 51.5v730.333c0 28.445 23.055 51.5 51.5 51.5h508.11c28.445 0 51.5-23.055 51.5-51.5V361.111c0-15.333-12.444-27.778-27.777-27.778s-27.778 12.445-27.778 27.778V888.89h-500V166.667h305.556c15.333 0 27.778-12.445 27.778-27.778 0-15.333-12.445-27.778-27.778-27.778m-55.556 555.556H305.556c-15.334 0-27.778 12.444-27.778 27.777 0 15.334 12.444 27.778 27.778 27.778h166.666c15.334 0 27.778-12.444 27.778-27.778 0-15.333-12.444-27.777-27.778-27.777m0 111.11H305.556c-15.334 0-27.778 12.445-27.778 27.779 0 15.333 12.444 27.777 27.778 27.777h166.666c15.334 0 27.778-12.444 27.778-27.777 0-15.334-12.444-27.778-27.778-27.778M726.944 55.556c-7.055 0-14.166 2.722-19.61 8.11l-210.5 210.556a29.374 29.374 0 00-7.612 13.222L460.5 394.611c-4.889 18.056 9.111 34.778 26.556 34.778 2.388 0 4.833-.333 7.277-1l107.111-28.722c5-1.334 9.556-3.945 13.223-7.611l210.61-210.5c10.779-10.89 10.779-28.39 0-39.223l-78.721-78.666c-5.445-5.39-12.5-8.111-19.612-8.111m0 67.11l39.278 39.278-185.889 185.89-53.61 14.388 14.333-53.666 185.888-185.89", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgRecords" }, props, { ref }), React__namespace.createElement(SvgIcon$Z, null));
  });
  const SvgIcon$Y = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M555.556 111.111c214.777 0 388.888 174.112 388.888 388.889 0 214.777-174.111 388.889-388.888 388.889-214.778 0-388.89-174.112-388.89-388.889 0-214.777 174.112-388.889 388.89-388.889zm0 55.556c-184.095 0-333.334 149.238-333.334 333.333 0 184.095 149.239 333.333 333.334 333.333 184.094 0 333.333-149.238 333.333-333.333 0-184.095-149.239-333.333-333.333-333.333zm121.278 125c13.286 7.67 17.838 24.659 10.167 37.945l-46.34 80.264h60.882c15.341 0 27.778 12.437 27.778 27.778s-12.437 27.778-27.778 27.778H590.43v55.555h111.112c15.341 0 27.778 12.437 27.778 27.778s-12.437 27.778-27.778 27.778H590.43v111.111c0 15.341-12.436 27.778-27.777 27.778-15.341 0-27.778-12.437-27.778-27.778V576.543h-111.11c-15.342 0-27.779-12.437-27.779-27.778s12.437-27.778 27.778-27.778h111.11v-55.555h-111.11c-15.341 0-27.778-12.437-27.778-27.778s12.437-27.778 27.778-27.778h39.241l-46.34-80.264c-7.593-13.153-3.208-29.935 9.772-37.712l.396-.233c13.153-7.594 29.935-3.209 37.712 9.771l.233.396 62.378 108.042h49.353l62.379-108.042c7.67-13.286 24.66-17.838 37.945-10.167zm-501.388-38.765c13.739 6.828 19.341 23.5 12.514 37.238-32.126 64.644-49.071 136.013-49.071 209.86 0 54.301 9.156 107.312 26.863 157.41 5.112 14.464-2.469 30.334-16.933 35.447-8.604 3.04-17.706 1.59-24.745-3.129a27.726 27.726 0 01-7.482-6.854l-85.416-113.22c-9.239-12.247-6.8-29.666 5.446-38.905 12.247-9.24 29.665-6.801 38.905 5.446l10.108 13.4A534.07 534.07 0 0183.333 500c0-82.474 18.954-162.3 54.876-234.584 6.827-13.739 23.5-19.341 37.237-12.514z", fillRule: "nonzero" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgRefundO" }, props, { ref }), React__namespace.createElement(SvgIcon$Y, null));
  });
  const SvgIcon$X = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M574.975 74.022L741.64 185.133c16.493 10.995 16.493 35.23 0 46.225L574.975 342.47c-18.46 12.307-43.186-.926-43.186-23.112V218.86c-142.994-13.088-282.443 70.705-333.864 211.984C136.71 599.032 223.428 785 391.615 846.215c168.187 61.215 354.155-25.503 415.37-193.69a326.704 326.704 0 0014.287-52.363c.189-1.023.401-2.037.636-3.04a32.49 32.49 0 011.763-7.498c6.122-16.82 24.718-25.491 41.537-19.37 16.819 6.122 25.49 24.719 19.37 41.537-3.458 21.173-9.134 42.15-16.687 62.902-73.458 201.824-296.62 305.886-498.444 232.428C167.622 833.663 63.56 610.5 137.019 408.677c61.002-167.602 225.242-267.785 394.77-254.873v-56.67c0-22.185 24.726-35.419 43.186-23.112z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgReplay" }, props, { ref }), React__namespace.createElement(SvgIcon$X, null));
  });
  const SvgIcon$W = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M381.087 424.471c9.643 9.643 10.714 24.61 3.215 35.437l-3.215 3.847c-9.642 9.642-24.61 10.714-35.436 3.214l-3.848-3.214-166.667-166.668-2.083-2.327-2.345-3.439-1.619-3.287-1.166-3.47-.62-3.004-.202-1.736-.101-2.964c.03-1.178.13-2.354.303-3.521l-.303 4.106.157-2.968.766-4.15 1.724-4.734 2.275-3.942 2.555-3.166L341.803 91.136c10.848-10.848 28.436-10.848 39.284 0 9.643 9.643 10.714 24.61 3.215 35.437l-3.215 3.847-119.309 119.248h226.335c190.607 0 345.557 148.99 345.557 333.335 0 180.248-148.14 326.695-332.904 333.115l-12.653.22H194.778C179.437 916.337 167 903.9 167 888.56c0-13.637 9.826-24.979 22.785-27.33l4.993-.448h293.335c160.402 0 290.001-124.615 290.001-277.78 0-149.236-123.039-271.37-277.725-277.534l-12.276-.245H261.778l119.31 119.248z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgRevoke" }, props, { ref }), React__namespace.createElement(SvgIcon$W, null));
  });
  const SvgIcon$V = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "nonzero" }, React__namespace.createElement("path", { d: "M111.111 305.556v-138.89c0-30.682 24.873-55.555 55.556-55.555h138.889c15.34 0 27.777 12.437 27.777 27.778s-12.436 27.778-27.777 27.778h-138.89v138.889c0 15.34-12.436 27.777-27.777 27.777-15.341 0-27.778-12.436-27.778-27.777zm55.556 388.888v138.89h138.889c15.34 0 27.777 12.436 27.777 27.777 0 15.341-12.436 27.778-27.777 27.778h-138.89c-30.682 0-55.555-24.873-55.555-55.556V694.444c0-15.34 12.437-27.777 27.778-27.777s27.778 12.436 27.778 27.777zm666.666-388.888v-138.89H694.444c-15.34 0-27.777-12.436-27.777-27.777 0-15.341 12.436-27.778 27.777-27.778h138.89c30.682 0 55.555 24.873 55.555 55.556v138.889c0 15.34-12.437 27.777-27.778 27.777s-27.778-12.436-27.778-27.777zm55.556 388.888v138.89c0 30.682-24.873 55.555-55.556 55.555H694.444c-15.34 0-27.777-12.437-27.777-27.778s12.436-27.778 27.777-27.778h138.89V694.444c0-15.34 12.436-27.777 27.777-27.777 15.341 0 27.778 12.436 27.778 27.777zM138.889 472.222H861.11c15.341 0 27.778 12.437 27.778 27.778s-12.437 27.778-27.778 27.778H138.89c-15.341 0-27.778-12.437-27.778-27.778s12.437-27.778 27.778-27.778z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgScan" }, props, { ref }), React__namespace.createElement(SvgIcon$V, null));
  });
  const SvgIcon$U = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M402.785 654.797c138.071 0 250-111.929 250-250s-111.929-250-250-250-250 111.929-250 250 111.929 250 250 250zm236.179-56.12l249.678 249.678c10.848 10.848 10.848 28.436 0 39.284-10.847 10.848-28.435 10.848-39.283 0L599.954 638.234c-53.216 44.993-122.025 72.119-197.169 72.119-168.753 0-305.555-136.802-305.555-305.556S234.032 99.242 402.785 99.242c168.754 0 305.556 136.801 305.556 305.555 0 73.605-26.026 141.132-69.377 193.88z", fillRule: "nonzero" }));
  const SvgSearch = React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgSearch" }, props, { ref }), React__namespace.createElement(SvgIcon$U, null));
  });
  const SvgIcon$T = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M798.414 151.086H201.369l-27.734 55.467h-62.014l40.136-80.272a55.467 55.467 0 0149.61-30.661h597.047a55.467 55.467 0 0149.61 30.661l40.137 80.272h.002v610.14c0 30.634-24.833 55.467-55.468 55.467H167.088c-30.634 0-55.467-24.833-55.467-55.468V206.553h714.527l-27.734-55.467zm34.28 110.935l-166.401-.001v332.805l-166.402-64.067-166.402 64.067V262.02h-166.4v554.672h665.605V262.021zm-221.868 0H388.958v252.011l110.933-42.71 110.935 42.71V262.021z", fillRule: "nonzero" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgSendGiftO" }, props, { ref }), React__namespace.createElement(SvgIcon$T, null));
  });
  const SvgIcon$S = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M888.889 277.778v555.555c0 30.723-24.833 55.556-55.556 55.556H166.667c-30.723 0-55.556-24.833-55.556-55.556V277.778H888.89zm-222.222 55.555H333.333v317.945c0 7.555 7.445 12.889 14.667 10.5l134.444-44.834a55.804 55.804 0 0135.112 0L652 661.778c7.222 2.389 14.667-2.945 14.667-10.5V333.333zm132.3-222.239c21.055 0 40.333 11.89 49.722 30.723l40.222 80.389H111.133l40.167-80.39c9.389-18.833 28.667-30.722 49.722-30.722z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgSendGift" }, props, { ref }), React__namespace.createElement(SvgIcon$S, null));
  });
  const SvgIcon$R = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M500 55.556c212.63 0 385.403 170.646 388.837 382.457l.052 6.431v277.778c0 30.683-24.873 55.556-55.556 55.556h-55.555c-30.683 0-55.556-24.873-55.556-55.556V500c0-30.682 24.873-55.556 55.556-55.556h55.555c0-182.254-146.268-330.345-327.82-333.288L500 111.11l-5.512.045C314.75 114.07 169.596 259.243 166.71 438.987l-.043 5.457h55.555c30.376 0 55.058 24.379 55.548 54.637l.008.919v222.222c0 30.376-24.378 55.058-54.637 55.548l-.919.008h-110.11a1 1 0 01-1-1V444.444c0-214.777 174.11-388.888 388.888-388.888zM833.333 500h-55.555v222.222h55.555V500zm-611.11 0h-55.556v222.222h55.555V500z" }), React__namespace.createElement("path", { d: "M833.333 452.274c0-15.341 12.437-27.777 27.778-27.777 15.342 0 27.778 12.436 27.778 27.778v316.407c-.822 113.295-54.114 176.047-153.867 176.047H528.01c-15.34 0-27.777-12.436-27.777-27.778 0-15.34 12.436-27.777 27.777-27.777h207.013c66.931 0 97.698-36.229 98.31-120.693l.001-316.207z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgServiceO" }, props, { ref }), React__namespace.createElement(SvgIcon$R, null));
  });
  const SvgIcon$Q = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M222.222 444.444c30.683 0 55.556 24.874 55.556 55.556v222.222c0 30.683-24.873 55.556-55.556 55.556h-55.555c-30.683 0-55.556-24.873-55.556-55.556V444.444h111.111zm666.667 0v277.778c0 30.683-24.873 55.556-55.556 55.556h-55.555c-30.683 0-55.556-24.873-55.556-55.556V500c0-30.682 24.873-55.556 55.556-55.556h111.11zM861.11 638.89c15.342 0 27.778 12.437 27.778 27.778v102.015c-.822 113.295-54.114 176.047-153.867 176.047H528.01c-15.34 0-27.777-12.436-27.777-27.778 0-15.34 12.436-27.777 27.777-27.777h207.013c66.931 0 97.698-36.229 98.31-120.693l.001-101.815c0-15.34 12.437-27.777 27.778-27.777zM500 55.556c214.777 0 388.889 174.111 388.889 388.888h-55.556c0-184.094-149.238-333.333-333.333-333.333-184.095 0-333.333 149.239-333.333 333.333H111.11c0-214.777 174.112-388.888 388.889-388.888z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgService" }, props, { ref }), React__namespace.createElement(SvgIcon$Q, null));
  });
  const SvgIcon$P = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M227.12 203.74c12.33 42.68 7.376 89.46-15.795 129.593-23.19 40.166-61.27 67.858-104.436 78.5-6.4 28.675-9.667 58.183-9.667 88.167s3.267 59.492 9.667 88.166c43.167 10.643 81.246 38.335 104.436 78.5 23.17 40.133 28.124 86.914 15.794 129.594 43.708 40.289 95.8 70.525 152.663 88.285 30.802-32.073 73.83-51.212 120.218-51.212 46.388 0 89.416 19.139 120.218 51.212 56.864-17.76 108.955-47.996 152.663-88.285-12.33-42.68-7.377-89.46 15.794-129.593 23.19-40.166 61.27-67.858 104.436-78.5 6.4-28.675 9.667-58.183 9.667-88.167s-3.267-59.492-9.667-88.166c-43.167-10.643-81.246-38.335-104.436-78.5-23.17-40.133-28.124-86.914-15.794-129.594-43.708-40.289-95.8-70.525-152.663-88.285-30.802 32.073-73.83 51.212-120.218 51.212-46.388 0-89.416-19.139-120.218-51.212-56.864 17.76-108.955 47.996-152.663 88.285zM598.114 52.192c94.33 20.573 177.807 70.193 240.589 139.017-20.969 33.701-23.15 77.57-1.916 114.347 21.255 36.814 60.396 56.864 100.11 55.51 13.923 43.822 21.435 90.5 21.435 138.934 0 48.433-7.512 95.112-21.436 138.935-39.713-1.355-78.854 18.695-100.11 55.51-21.232 36.776-19.052 80.645 1.917 114.346-62.782 68.824-146.26 118.444-240.59 139.017-18.687-35.058-55.614-58.92-98.114-58.92-42.5 0-79.427 23.862-98.115 58.92-94.33-20.573-177.807-70.193-240.589-139.017 20.969-33.701 23.15-77.57 1.916-114.347-21.255-36.814-60.396-56.864-100.11-55.51C49.18 595.113 41.668 548.435 41.668 500c0-48.433 7.512-95.112 21.436-138.935 39.713 1.355 78.854-18.695 100.11-55.51 21.232-36.776 19.052-80.645-1.917-114.346 62.782-68.824 146.26-118.444 240.59-139.017 18.687 35.058 55.614 58.92 98.114 58.92 42.5 0 79.427-23.862 98.115-58.92zM500 333.333c-92.047 0-166.667 74.62-166.667 166.667S407.953 666.667 500 666.667 666.667 592.047 666.667 500 592.047 333.333 500 333.333zm0 55.556c61.365 0 111.111 49.746 111.111 111.111S561.365 611.111 500 611.111 388.889 561.365 388.889 500 438.635 388.889 500 388.889z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgSettingO" }, props, { ref }), React__namespace.createElement(SvgIcon$P, null));
  });
  const SvgIcon$O = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M598.11 52.192c94.333 20.572 177.813 70.193 240.596 139.02-20.97 33.7-23.15 77.568-1.918 114.344 21.253 36.812 60.39 56.861 100.101 55.51 13.931 43.818 21.444 90.499 21.444 138.934s-7.513 95.116-21.437 138.94c-39.717-1.357-78.855 18.692-100.108 55.504-21.233 36.776-19.053 80.645 1.915 114.346-62.78 68.825-146.26 118.446-240.592 139.018l-.002-.012c-18.69-35.05-55.614-58.907-98.109-58.907s-79.419 23.856-98.109 58.907l-.001.013c-94.333-20.573-177.813-70.194-240.596-139.02 20.97-33.7 23.15-77.569 1.918-114.345-21.253-36.812-60.391-56.861-100.102-55.51C49.18 595.117 41.667 548.436 41.667 500s7.513-95.116 21.437-138.94c39.717 1.357 78.855-18.692 100.108-55.504 21.233-36.776 19.053-80.645-1.915-114.346 62.78-68.825 146.26-118.446 240.593-139.019l.002.014c18.69 35.05 55.613 58.906 98.108 58.906 42.342 0 79.152-23.684 97.905-58.527zM500 388.889c-61.365 0-111.111 49.746-111.111 111.111S438.635 611.111 500 611.111 611.111 561.365 611.111 500 561.365 388.889 500 388.889z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgSetting" }, props, { ref }), React__namespace.createElement(SvgIcon$O, null));
  });
  const SvgIcon$N = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M607.651 120.192l324.795 316.981c16.478 16.106 16.602 42.164.308 58.206L607.342 815.552c-16.313 16.042-29.538 10.121-29.538-12.809V635.287C109.358 635.287 57.572 880.73 56 888.779l.45-17.767c4.604-91.379 51.475-502.827 521.354-570.618V132.917c0-23.098 13.225-28.935 29.847-12.725zm32.684 120.169l.037 60.033c0 31.772-22.94 58.7-53.8 63.152C386.401 392.425 258.8 488.09 184.921 630.456a551.876 551.876 0 00-11.054 22.547l-3.663 8.373 9.905-5.718c92.745-51.281 215.82-81.075 372.651-83.926l25.044-.226c32.087 0 58.533 24.622 62.147 56.343l.42 7.438-.036 59.127 231.624-227.951L640.335 240.36z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgShareO" }, props, { ref }), React__namespace.createElement(SvgIcon$N, null));
  });
  const SvgIcon$M = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M577.281 140.477c0-22.634 13.21-28.354 29.815-12.47L931.54 438.626c16.461 15.782 16.585 41.317.309 57.037L606.787 809.407c-16.296 15.72-29.506 9.917-29.506-12.552V632.761C101.541 632.76 56 881.36 56 881.36s-7.34-501.954 521.281-576.77V140.478z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgShare" }, props, { ref }), React__namespace.createElement(SvgIcon$M, null));
  });
  const SvgIcon$L = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M519.254 62.174l305.324 98.016c27.386 9.051 45.688 34.032 45.42 61.99v402.577c0 143.888-268.304 275.044-350.497 311.808A50.581 50.581 0 01498.768 941a50.025 50.025 0 01-19.006-3.79c-82.193-33.57-350.493-155.357-349.76-312.716V222.132c-.24-27.951 18.053-52.92 45.424-61.99l303.596-97.968a65.326 65.326 0 0140.232 0zm-19.997 54.384c-.76.011-1.512.14-2.229.382l-304.9 97.967c-3.097 1.046-5.178 3.851-5.203 7.01V624.54c-.494 102.331 194.186 209.526 311.837 257.806 156.784-70.406 314.312-177.004 314.312-257.806V222.084c.017-3.204-2.067-6.07-5.201-7.152l-306.387-98.016c-.6-.186-1.222-.3-1.85-.342l-.379-.016zm.745 149.363c14.907.077 26.817 12.107 26.74 26.87l-.976 144.127h145.292c14.845 0 26.88 12.03 26.88 26.87 0 14.841-12.035 26.872-26.88 26.872H525.487l-.984 145.382c-.074 14.168-11.584 25.615-25.757 25.615-14.152 0-25.624-11.468-25.624-25.615V490.66H328.947c-14.846 0-26.88-12.03-26.88-26.871 0-14.84 12.034-26.871 26.88-26.871h144.175V292.792c0-14.84 12.035-26.871 26.88-26.871z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgShieldO" }, props, { ref }), React__namespace.createElement(SvgIcon$L, null));
  });
  const SvgIcon$K = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M777.292 611.025c61.202 0 110.926 50.008 110.926 111.423l-.057 2.633-.022.496c-.014.28-.033.587-.058.996l.02 1.147c0 10.93-2.404 21.999-6.81 33.18l-.29.782-.306.803c-1.633 4.21-3.848 8.813-8.715 16.955l1.316-1.766.166-.237.04-.06 1.068-1.85-.651 1.181.075-.111c.023-.025-.093.198-.521 1.017l-.578 1.075-.403.737c-1 1.812-1.932 3.389-2.603 4.316a196.206 196.206 0 01-6.61 10.228c-12.945 18.773-30.582 38.098-51.832 57.804-14.205 13.173-29.268 25.82-44.55 37.742l-3.264 2.53c-9.713 7.474-25.961 19.394-21.314 15.875a41.957 41.957 0 01-25.21 8.419c-8.78 0-17.343-2.697-24.683-8.006l-.484-.354.8.612.05.044c.065.12-14.664-10.694-23.086-17.192l-.26-.201c-15.965-12.339-31.707-25.473-46.516-39.198-21.907-20.302-39.962-40.223-52.997-59.604-5.951-8.848-10.823-17.547-14.573-26.266l-.42-1.034c-5.387-12.872-8.234-25.384-8.234-37.446a58.794 58.794 0 01-.222-5.247c0-61.436 49.708-111.423 110.927-111.423 21.437 0 42.202 6.352 59.935 17.9 17.71-11.549 38.484-17.9 59.946-17.9zm-5.29-419.154c24.98 0 46.753 17 52.811 41.233l34.216 136.862c9.208 19.523 14.068 40.948 14.068 62.977 0 81.602-66.151 147.753-147.753 147.753-47.414 0-89.612-22.333-116.648-57.053-27.036 34.72-69.233 57.053-116.647 57.053s-89.612-22.333-116.648-57.053c-27.036 34.72-69.234 57.053-116.647 57.053-13.457 0-26.494-1.799-38.883-5.17v269.571h299.396c15.031 0 27.217 12.186 27.217 27.218s-12.186 27.218-27.217 27.218H206.262c-22.548 0-40.826-18.279-40.826-40.827V547.504C132.214 520.41 111 479.154 111 432.943c0-22.03 4.86-43.454 14.069-62.977l34.215-136.862c6.059-24.233 27.832-41.233 52.81-41.233h559.909zm5.29 473.59c-15.09 0-29.631 6.307-40.27 17.408L717.42 703.32l-19.652-20.403c-10.733-11.143-25.3-17.458-40.357-17.458-30.775 0-55.983 25.04-56.484 56.047l-.004 1.092.15 6.631.03-.343.032-.939c.007 4.065 1.261 9.576 4.014 16.145l.411 1.024c2.265 5.194 5.46 10.875 9.542 16.944 10.341 15.375 25.747 32.373 44.83 50.058 13.507 12.518 28.037 24.641 42.802 36.053l1.625 1.249 1.566 1.193a1209.35 1209.35 0 0011.155 8.346l3.18-2.367 3.506-2.626a727.922 727.922 0 007.175-5.45l.527-.408c14.812-11.478 29.402-23.672 42.964-36.249 18.25-16.924 33.155-33.202 43.494-48.014l.54-.778c1.741-2.526 3.335-4.99 5.606-8.68l.182-.277.257-.428c.173-.3.416-.734.817-1.45l.41-.826.227-.437c.098-.184.215-.394.395-.722l.954-1.654a58.14 58.14 0 003.08-6.987c2.15-5.469 3.14-9.742 3.26-13.186l.014-.801-.015-2.856.13-2.185v-.131c0-31.42-25.423-56.988-56.491-56.988zm-5.29-419.154H212.096l-35.663 142.648-.38.717c-6.78 12.934-10.616 27.654-10.616 43.27 0 51.539 41.78 93.319 93.318 93.319 51.022 0 92.481-40.949 93.305-91.775l.013-1.543h46.659l.012 1.543c.824 50.826 42.283 91.775 93.306 91.775 51.022 0 92.481-40.949 93.305-91.775l.013-1.543h46.659l.012 1.543c.824 50.826 42.283 91.775 93.306 91.775 51.538 0 93.318-41.78 93.318-93.318 0-15.617-3.836-30.337-10.617-43.271l-.38-.717-35.662-142.648zM764.227 83c15.032 0 27.218 12.186 27.218 27.218s-12.186 27.218-27.218 27.218H219.871c-15.032 0-27.218-12.186-27.218-27.218S204.84 83 219.871 83h544.355z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgShopCollectO" }, props, { ref }), React__namespace.createElement(SvgIcon$K, null));
  });
  const SvgIcon$J = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M777.292 611.025c61.202 0 110.926 50.008 110.926 111.423l-.057 2.633c-.017.446-.04.837-.08 1.492l.02 1.147c0 10.93-2.404 21.999-6.81 33.18l-.29.782c-1.667 4.44-3.843 9.096-9.02 17.758l1.315-1.766c.095-.132.156-.22.205-.297l1.07-1.85-.654 1.185.077-.115c.023-.025-.093.198-.521 1.017l-.578 1.075c-1.149 2.117-2.245 4.002-3.006 5.053a196.206 196.206 0 01-6.61 10.228c-12.945 18.773-30.582 38.098-51.832 57.804-14.205 13.173-29.268 25.82-44.55 37.742l-3.264 2.53c-9.713 7.474-25.961 19.394-21.314 15.875a41.957 41.957 0 01-25.21 8.419c-8.78 0-17.343-2.697-24.683-8.006l-.484-.354.8.612c1.052.853-14.663-10.677-23.297-17.35-15.964-12.338-31.706-25.472-46.515-39.197-21.907-20.302-39.962-40.223-52.997-59.604-5.951-8.848-10.823-17.547-14.573-26.266l-.381-.934-.04-.1c-5.386-12.872-8.233-25.384-8.233-37.446a58.794 58.794 0 01-.222-5.247c0-61.436 49.708-111.423 110.927-111.423 21.437 0 42.202 6.352 59.935 17.9 17.71-11.549 38.484-17.9 59.946-17.9zm-5.29-419.154c24.98 0 46.753 17 52.811 41.233l34.216 136.862c9.208 19.523 14.068 40.948 14.068 62.977 0 81.602-66.151 147.753-147.753 147.753-47.414 0-89.612-22.333-116.648-57.053-27.036 34.72-69.233 57.053-116.647 57.053s-89.612-22.333-116.648-57.053c-27.036 34.72-69.234 57.053-116.647 57.053-13.457 0-26.494-1.799-38.883-5.17v269.571h299.396c15.031 0 27.217 12.186 27.217 27.218s-12.186 27.218-27.217 27.218H206.262c-22.548 0-40.826-18.279-40.826-40.827V547.504C132.214 520.41 111 479.154 111 432.943c0-22.03 4.86-43.454 14.069-62.977l34.215-136.862c6.059-24.233 27.832-41.233 52.81-41.233h559.909zM764.227 83c15.032 0 27.218 12.186 27.218 27.218s-12.186 27.218-27.218 27.218H219.871c-15.032 0-27.218-12.186-27.218-27.218S204.84 83 219.871 83h544.355z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgShopCollect" }, props, { ref }), React__namespace.createElement(SvgIcon$J, null));
  });
  const SvgIcon$I = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M785.605 194.111c25.493 0 47.714 17.35 53.897 42.082l34.92 139.678c9.397 19.925 14.358 41.79 14.358 64.273 0 47.162-21.651 89.267-55.556 116.918V874.67c0 23.012-18.655 41.667-41.667 41.667H208.222c-23.011 0-41.666-18.655-41.666-41.667V557.062C132.65 529.412 111 487.306 111 440.144c0-22.482 4.96-44.348 14.358-64.273l34.92-139.678c6.183-24.732 28.404-42.082 53.897-42.082h571.43zm-166.667 338.6c-27.592 35.434-70.658 58.227-119.048 58.227s-91.456-22.793-119.048-58.228c-27.592 35.435-70.658 58.228-119.048 58.228-13.734 0-27.039-1.836-39.683-5.276V860.78H777.67V585.662c-12.644 3.44-25.95 5.276-39.683 5.276-48.39 0-91.456-22.793-119.048-58.228zm166.667-283.044h-571.43l-36.396 145.584-.388.732c-6.92 13.2-10.835 28.223-10.835 44.16 0 52.6 42.64 95.24 95.238 95.24 52.073 0 94.385-41.792 95.226-93.664l.012-1.575h47.62l.012 1.575c.841 51.872 43.153 93.663 95.226 93.663s94.385-41.79 95.226-93.663l.012-1.575h47.62l.012 1.575c.841 51.872 43.153 93.663 95.226 93.663 52.599 0 95.238-42.64 95.238-95.238 0-15.938-3.915-30.961-10.835-44.161l-.388-.732-36.396-145.584zM777.67 83c15.34 0 27.777 12.437 27.777 27.778s-12.436 27.778-27.777 27.778H222.11c-15.34 0-27.777-12.437-27.777-27.778S206.77 83 222.11 83H777.67z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgShopO" }, props, { ref }), React__namespace.createElement(SvgIcon$I, null));
  });
  const SvgIcon$H = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M785.605 194.111c25.493 0 47.714 17.35 53.897 42.082l34.92 139.678c9.397 19.925 14.358 41.79 14.358 64.273 0 47.162-21.651 89.267-55.556 116.918V874.67c0 23.012-18.655 41.667-41.667 41.667H208.222c-23.011 0-41.666-18.655-41.666-41.667V557.062C132.65 529.412 111 487.306 111 440.144c0-22.482 4.96-44.348 14.358-64.273l34.92-139.678c6.183-24.732 28.404-42.082 53.897-42.082h571.43zm-166.667 338.6c-27.592 35.434-70.658 58.227-119.048 58.227s-91.456-22.793-119.048-58.228c-27.592 35.435-70.658 58.228-119.048 58.228-13.734 0-27.039-1.836-39.683-5.276V860.78H777.67V585.662c-12.644 3.44-25.95 5.276-39.683 5.276-48.39 0-91.456-22.793-119.048-58.228zM222.111 83H777.67c15.34 0 27.777 12.437 27.777 27.778s-12.436 27.778-27.777 27.778H222.11c-15.34 0-27.777-12.437-27.777-27.778S206.77 83 222.11 83z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgShop" }, props, { ref }), React__namespace.createElement(SvgIcon$H, null));
  });
  const SvgIcon$G = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { transform: "translate(0 55.556)", fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M132.939 55.364c42.68 0 78.461 32.247 82.885 74.697l3.813 36.605h650.59c30.682 0 55.555 24.874 55.555 55.556 0 5.3-.758 10.571-2.252 15.655l-82.684 281.535c-6.41 21.824-25.475 37.536-48.121 39.658L265.67 608.458l3.5 33.587c1.475 14.15 13.402 24.899 27.629 24.899h534.848c15.341 0 27.778 12.436 27.778 27.777 0 15.342-12.437 27.778-27.778 27.778H296.8c-42.68 0-78.462-32.246-82.885-74.697L160.567 135.82c-1.474-14.15-13.401-24.899-27.628-24.899H55.556c-15.342 0-27.778-12.437-27.778-27.778s12.436-27.778 27.778-27.778h77.383zM259.913 553.2l527.629-49.442 82.684-281.535h-644.8l34.487 330.977z", fillRule: "nonzero" }), React__namespace.createElement("circle", { cx: 333.333, cy: 833.333, r: 55.556 }), React__namespace.createElement("circle", { cx: 722.222, cy: 833.333, r: 55.556 })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgShoppingCartO" }, props, { ref }), React__namespace.createElement(SvgIcon$G, null));
  });
  const SvgIcon$F = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { transform: "translate(0 55.556)", fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M132.939 55.364c42.68 0 78.461 32.247 82.885 74.697l3.813 36.605h723.472a1 1 0 01.959 1.282L830.422 554.905a1 1 0 01-.866.714l-563.885 52.84 3.5 33.586c1.475 14.15 13.402 24.899 27.629 24.899h534.848c15.341 0 27.778 12.436 27.778 27.777 0 15.342-12.437 27.778-27.778 27.778H296.8c-42.68 0-78.462-32.246-82.885-74.697L160.567 135.82c-1.474-14.15-13.401-24.899-27.628-24.899H55.556c-15.342 0-27.778-12.437-27.778-27.778s12.436-27.778 27.778-27.778h77.383z" }), React__namespace.createElement("circle", { cx: 333.333, cy: 833.333, r: 55.556 }), React__namespace.createElement("circle", { cx: 722.222, cy: 833.333, r: 55.556 })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgShoppingCart" }, props, { ref }), React__namespace.createElement(SvgIcon$F, null));
  });
  const SvgIcon$E = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M166.667 166.667v666.666h666.666V166.667H166.667zm0-55.556h666.666c30.683 0 55.556 24.873 55.556 55.556v666.666c0 30.683-24.873 55.556-55.556 55.556H166.667c-30.683 0-55.556-24.873-55.556-55.556V166.667c0-30.683 24.873-55.556 55.556-55.556zM650.395 388.89H750c15.341 0 27.778 12.436 27.778 27.778 0 15.34-12.437 27.777-27.778 27.777H583.333c-15.34 0-27.777-12.436-27.777-27.777V250c0-15.341 12.436-27.778 27.777-27.778 15.342 0 27.778 12.437 27.778 27.778v99.605l119.247-119.247c10.848-10.848 28.436-10.848 39.284 0 10.848 10.848 10.848 28.436 0 39.284L650.395 388.889zM349.605 611.11H250c-15.341 0-27.778-12.436-27.778-27.778 0-15.34 12.437-27.777 27.778-27.777h166.667c15.34 0 27.777 12.436 27.777 27.777V750c0 15.341-12.436 27.778-27.777 27.778-15.342 0-27.778-12.437-27.778-27.778v-99.605L269.642 769.642c-10.848 10.848-28.436 10.848-39.284 0-10.848-10.848-10.848-28.436 0-39.284l119.247-119.247z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgShrink" }, props, { ref }), React__namespace.createElement(SvgIcon$E, null));
  });
  const SvgIcon$D = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M166.667 277.778v555.555h666.666V277.778H166.667zm-55.556-55.556H888.89v611.111c0 30.683-24.873 55.556-55.556 55.556H166.667c-30.683 0-55.556-24.873-55.556-55.556v-611.11zm687.887-111.11a55.556 55.556 0 0149.69 30.71l40.2 80.4h-62.112l-27.778-55.555H201.002l-27.778 55.555h-62.113l40.2-80.4a55.556 55.556 0 0149.69-30.71zm-86.502 278.32c.91-.756 2.779-.672 3.376-.062l5.967 6.096c.61.623.557 1.797-.629 3.008l-1.161 1.187c3.48 4.877 2.732 11.643-1.9 16.267L472.58 661.135c-4.32 4.314-10.21 6.082-15.933 5.384-3.013.554-6.371-.443-8.895-3.022l-.884-.902a21.197 21.197 0 01-2.338-2.018L337.485 553.69c-2.044-2.042-3.367-4.56-3.893-7.195a3 3 0 01-.224-1.652 12.776 12.776 0 012.757-8.93l10.004-12.612c4.1-5.17 11.771-6.468 17.193-2.85l86.587 57.793c4.567 3.049 12.428 2.652 16.692-.808l228.8-185.625c4.38-3.553 10.872-3.823 15.486-1.045z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgSign" }, props, { ref }), React__namespace.createElement(SvgIcon$D, null));
  });
  const SvgIcon$C = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M341.623 722.222h491.71V166.667H166.667v555.555h111.11V773.3l63.846-51.077zm19.488 55.556l-138.889 111.11v-111.11h-55.555c-30.683 0-55.556-24.873-55.556-55.556V166.667c0-30.683 24.873-55.556 55.556-55.556h666.666c30.683 0 55.556 24.873 55.556 55.556v555.555c0 30.683-24.873 55.556-55.556 55.556H361.111zM660.64 444.444h.075c0 92.048-73.286 166.667-163.69 166.667-90.291 0-163.508-74.433-163.69-166.323v-.139c0-15.341 12.436-27.778 27.777-27.778 15.273 0 27.667 12.326 27.777 27.573 0 61.587 48.64 111.112 108.136 111.112 58.85 0 107.079-48.457 108.118-109.113a28.198 28.198 0 01-.058-1.805c0-15.342 12.436-27.778 27.778-27.778 15.276 0 27.673 12.332 27.777 27.584zM361.11 277.778c15.341 0 27.778 12.436 27.778 27.778 0 15.34-12.437 27.777-27.778 27.777s-27.778-12.436-27.778-27.777c0-15.342 12.437-27.778 27.778-27.778zm277.778 0c15.341 0 27.778 12.436 27.778 27.778 0 15.34-12.437 27.777-27.778 27.777s-27.778-12.436-27.778-27.777c0-15.342 12.437-27.778 27.778-27.778z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgSmileCommentO" }, props, { ref }), React__namespace.createElement(SvgIcon$C, null));
  });
  const SvgIcon$B = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M361.111 777.778l-138.889 111.11v-111.11h-55.555c-30.683 0-55.556-24.873-55.556-55.556V166.667c0-30.683 24.873-55.556 55.556-55.556h666.666c30.683 0 55.556 24.873 55.556 55.556v555.555c0 30.683-24.873 55.556-55.556 55.556H361.111zM660.64 444.444c-.104-15.252-12.5-27.584-27.777-27.584-15.342 0-27.778 12.436-27.778 27.778 0 .606.02 1.208.058 1.805-1.04 60.656-49.268 109.113-108.118 109.113-59.495 0-108.135-49.525-108.136-111.112-.11-15.247-12.504-27.573-27.777-27.573-15.341 0-27.778 12.437-27.778 27.778v.14c.183 91.889 73.4 166.322 163.69 166.322 90.405 0 163.691-74.62 163.691-166.667h-.075zM361.11 277.778c-15.341 0-27.778 12.436-27.778 27.778 0 15.34 12.437 27.777 27.778 27.777s27.778-12.436 27.778-27.777c0-15.342-12.437-27.778-27.778-27.778zm277.778 0c-15.341 0-27.778 12.436-27.778 27.778 0 15.34 12.437 27.777 27.778 27.777s27.778-12.436 27.778-27.777c0-15.342-12.437-27.778-27.778-27.778z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgSmileComment" }, props, { ref }), React__namespace.createElement(SvgIcon$B, null));
  });
  const SvgIcon$A = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M500 857.143c197.245 0 357.143-159.898 357.143-357.143 0-197.245-159.898-357.143-357.143-357.143-197.245 0-357.143 159.898-357.143 357.143 0 197.245 159.898 357.143 357.143 357.143zm0 59.524C269.881 916.667 83.333 730.119 83.333 500 83.333 269.881 269.881 83.333 500 83.333c230.119 0 416.667 186.548 416.667 416.667 0 230.119-186.548 416.667-416.667 416.667z", fillRule: "nonzero" }), React__namespace.createElement("circle", { cx: 347.002, cy: 392.857, r: 47.619 }), React__namespace.createElement("circle", { cx: 655.644, cy: 392.857, r: 47.619 }), React__namespace.createElement("path", { d: "M684.632 549.606c5.477-15.498 22.481-23.62 37.979-18.143 15.497 5.478 23.62 22.481 18.142 37.979C705.315 669.706 610.25 738.095 502.18 738.095c-108.07 0-203.136-68.39-238.574-168.653-5.478-15.498 2.645-32.501 18.143-37.979 15.497-5.477 32.5 2.645 37.978 18.143 27.095 76.658 99.805 128.965 182.453 128.965 82.647 0 155.357-52.307 182.452-128.965z", fillRule: "nonzero" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgSmileO" }, props, { ref }), React__namespace.createElement(SvgIcon$A, null));
  });
  const SvgIcon$z = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 55.556c245.46 0 444.444 198.984 444.444 444.444S745.46 944.444 500 944.444 55.556 745.46 55.556 500 254.54 55.556 500 55.556zm222.61 475.907c-15.497-5.477-32.5 2.645-37.978 18.143-27.095 76.658-99.805 128.965-182.452 128.965-82.648 0-155.358-52.307-182.453-128.965-5.477-15.498-22.48-23.62-37.978-18.143-15.498 5.478-23.62 22.481-18.143 37.979 35.438 100.264 130.503 168.653 238.574 168.653 108.07 0 203.135-68.39 238.573-168.653 5.478-15.498-2.645-32.501-18.142-37.979zM347.003 345.238c-26.3 0-47.62 21.32-47.62 47.62 0 26.298 21.32 47.618 47.62 47.618 26.299 0 47.619-21.32 47.619-47.619 0-26.3-21.32-47.619-47.62-47.619zm308.642 0c-26.3 0-47.62 21.32-47.62 47.62 0 26.298 21.32 47.618 47.62 47.618 26.299 0 47.619-21.32 47.619-47.619 0-26.3-21.32-47.619-47.62-47.619z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgSmile" }, props, { ref }), React__namespace.createElement(SvgIcon$z, null));
  });
  const SvgIcon$y = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M444.002 160.354l.332 6.313v666.669c0 30.682-24.873 55.555-55.555 55.555-28.491 0-51.973-21.446-55.182-49.076l-.374-6.48V300.78L205.84 428.174c-20.027 20.027-51.54 21.567-73.334 4.621l-5.234-4.621c-20.027-20.027-21.568-51.54-4.622-73.334l4.622-5.234 222.223-222.223c33.476-33.476 89.683-12.253 94.507 32.971zm167-49.354c28.49 0 51.972 21.447 55.181 49.077l.374 6.479v532.557L793.94 571.718c20.027-20.027 51.54-21.568 73.334-4.622l5.234 4.622c20.027 20.027 21.568 51.54 4.622 73.333l-4.622 5.234-222.223 222.223c-33.476 33.477-89.683 12.254-94.507-32.97l-.332-6.314V166.556C555.446 135.873 580.319 111 611 111z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgSort" }, props, { ref }), React__namespace.createElement(SvgIcon$y, null));
  });
  const SvgIcon$x = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M703.801 621.775l166.747-186.618-244.592-52.965L500 165.938 374.044 382.192l-244.592 52.965 166.747 186.618-25.21 248.988L500 769.845l229.011 100.918-25.21-248.988zM500 830.555L249.75 940.833c-14.04 6.187-30.435-.179-36.621-14.217a27.778 27.778 0 01-2.217-14l27.547-272.08L56.25 436.61c-10.223-11.44-9.235-29 2.205-39.222a27.778 27.778 0 0112.629-6.434l267.276-57.878 137.638-236.31c7.721-13.256 24.727-17.743 37.984-10.022a27.778 27.778 0 0110.022 10.022l137.638 236.31 267.276 57.878c14.994 3.246 24.517 18.033 21.27 33.027a27.778 27.778 0 01-6.435 12.63L761.54 640.534l27.547 272.08c1.546 15.263-9.575 28.89-24.838 30.435-4.78.484-9.603-.28-14-2.218L500 830.556z", fillRule: "nonzero" }));
  const SvgStarO = React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgStarO" }, props, { ref }), React__namespace.createElement(SvgIcon$x, null));
  });
  const SvgIcon$w = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 817.591L249.75 927.868c-14.04 6.186-30.435-.18-36.621-14.218a27.778 27.778 0 01-2.217-14l27.547-272.08L56.25 423.647c-10.223-11.44-9.235-29 2.205-39.222a27.778 27.778 0 0112.629-6.435l267.276-57.878 137.638-236.31c7.721-13.256 24.727-17.743 37.984-10.022a27.778 27.778 0 0110.022 10.023l137.638 236.31 267.276 57.877c14.994 3.247 24.517 18.034 21.27 33.027a27.778 27.778 0 01-6.435 12.63L761.54 627.57l27.547 272.08c1.546 15.263-9.575 28.889-24.838 30.434-4.78.484-9.603-.28-14-2.217L500 817.59z", fillRule: "evenodd" }));
  const SvgStar = React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgStar" }, props, { ref }), React__namespace.createElement(SvgIcon$w, null));
  });
  const SvgIcon$v = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M389.422 360.863h222.222c15.342 0 27.778 12.437 27.778 27.778v222.222c0 15.342-12.436 27.778-27.778 27.778H389.422c-15.341 0-27.778-12.436-27.778-27.778V388.641c0-15.341 12.437-27.778 27.778-27.778zM500 888.89c214.777 0 388.889-174.112 388.889-388.889 0-214.777-174.112-388.889-388.889-388.889-214.777 0-388.889 174.112-388.889 388.889 0 214.777 174.112 388.889 388.889 388.889zm0 55.555C254.54 944.444 55.556 745.46 55.556 500S254.54 55.556 500 55.556 944.444 254.54 944.444 500 745.46 944.444 500 944.444z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgStopCircleO" }, props, { ref }), React__namespace.createElement(SvgIcon$v, null));
  });
  const SvgIcon$u = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 944.444C254.54 944.444 55.556 745.46 55.556 500S254.54 55.556 500 55.556 944.444 254.54 944.444 500 745.46 944.444 500 944.444zm-110.578-583.58c-15.341 0-27.778 12.436-27.778 27.777v222.222c0 15.342 12.437 27.778 27.778 27.778h222.222c15.342 0 27.778-12.436 27.778-27.778V388.641c0-15.341-12.436-27.778-27.778-27.778H389.422z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgStopCircle" }, props, { ref }), React__namespace.createElement(SvgIcon$u, null));
  });
  const SvgIcon$t = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M340 300h320c22.091 0 40 17.909 40 40v320c0 22.091-17.909 40-40 40H340c-22.091 0-40-17.909-40-40V340c0-22.091 17.909-40 40-40z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgStop" }, props, { ref }), React__namespace.createElement(SvgIcon$t, null));
  });
  const SvgIcon$s = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M119.415 524.046c-9.708-9.693-11.278-24.766-2.72-35.554l20.007-25.223c8.201-10.34 23.543-12.936 34.386-5.699l173.175 115.585c9.134 6.097 24.856 5.303 33.384-1.616l457.6-371.25c10.286-8.345 26.397-7.634 35.412 1.368l11.272 11.255c9.81 9.795 9.096 25.343-1.187 35.611l-491.14 490.414c-15.28 15.258-40.369 14.59-56.099-1.116l-214.09-213.775z", fillRule: "nonzero" }));
  const SvgSuccess = React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgSuccess" }, props, { ref }), React__namespace.createElement(SvgIcon$s, null));
  });
  const SvgIcon$r = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "nonzero" }, React__namespace.createElement("path", { d: "M578.69 327.564l-5.962 77.831 70.278-8.36c37.332-4.448 63.459 24.7 54.125 63.088-.287.848-.929 3.264-1.637 7.088-.517 2.786-.96 5.825-1.304 9.127-.16 1.519-.044 2.567.565 4.906l.339 1.254.067.246c.125.454.266.956.561 2.009 2.687 9.68 3.7 17.221 2.837 28.083-.812 10.115-2.571 17.009-5.821 25.297-.557 1.408-.557 1.408-1.03 2.598-1.448 3.679-1.914 5.395-2.177 8.44-.339 3.935-.195 5.389.723 9.715 1.618 7.619 2.144 12.518 1.587 20.318-.742 10.412-2.943 18.349-6.666 26.388-.524 1.13-2.574 5.303-2.874 5.997-.612 2.875-.595 4.976-.369 6.532.069.38.069.38.5 3.082 2.535 27.761-17.15 53.48-44.75 57.959l-292.717 47.483c-23.73 3.846-44.363-13.7-44.363-37.833V525.615c0-18.503 13.926-35.205 32.136-38.59a8840.647 8840.647 0 0032.263-6.06l1.746-.33 1.749-.333 1.342-.256c16.87-3.214 28.674-5.54 32.197-6.37 16.078-3.79 33.55-33.608 46.844-80.85 5.7-20.254 10.277-42.113 13.81-63.995 2.12-13.129 3.411-23.281 4.066-29.615 2.574-19.041 17.896-36.11 36.527-41.052.853-.38 1.739-.502 2.621-.61.618-.123 1.24-.234 1.864-.33 41.98-3.952 74.21 27.428 70.923 70.34zM342.27 527.634V684.87l32.73-5.31V521.478a8889.391 8889.391 0 01-32.73 6.156zm170.895-228.92c-2.164.994-4.828 3.924-5.037 5.398-.65 6.412-2.043 17.36-4.304 31.36-3.767 23.335-8.66 46.692-14.835 68.64-16.482 58.567-38.56 97.677-72.32 108.697l-.002 159.993 214.344-34.769c5.886-.955 10.484-6.962 10.523-9.655-.348-1.39-.348-1.39-.834-4.266-.81-5.57-.863-11.914.267-18.794.593-3.623 1.626-6.88 3.09-10.268.785-1.812 3.172-6.67 3.31-6.969 1.697-3.663 2.55-6.742 2.914-11.841.233-3.266.093-4.57-.75-8.545-1.733-8.16-2.256-13.456-1.511-22.1.658-7.637 2.12-13.019 4.92-20.128l1.008-2.548c1.855-4.729 2.623-7.739 3.078-13.398.425-5.363.036-8.266-1.452-13.625-.525-1.869-.525-1.869-1.142-4.158-1.773-6.815-2.427-12.678-1.68-19.749.457-4.389 1.06-8.518 1.774-12.372 1.084-5.85 2.236-10.187 2.62-11.059 1.994-8.273-.606-11.174-9.213-10.148l-74.928 8.913c-24.426 2.885-44.022-16.06-42.162-40.656l6.303-82.286c1.26-16.453-8.407-26.587-23.98-25.668z" }), React__namespace.createElement("path", { d: "M500 888.889c214.777 0 388.889-174.112 388.889-388.889 0-214.777-174.112-388.889-388.889-388.889-214.777 0-388.889 174.112-388.889 388.889 0 214.777 174.112 388.889 388.889 388.889zm0 55.555C254.54 944.444 55.556 745.46 55.556 500S254.54 55.556 500 55.556 944.444 254.54 944.444 500 745.46 944.444 500 944.444z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgThumbCircleO" }, props, { ref }), React__namespace.createElement(SvgIcon$r, null));
  });
  const SvgIcon$q = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 55.556c245.46 0 444.444 198.984 444.444 444.444S745.46 944.444 500 944.444 55.556 745.46 55.556 500 254.54 55.556 500 55.556zm78.69 272.008c3.288-42.912-28.942-74.292-70.923-70.34-.624.096-1.246.207-1.864.33-.882.108-1.768.23-2.62.61-18.632 4.941-33.954 22.01-36.528 41.052-.655 6.334-1.946 16.486-4.066 29.615-3.533 21.882-8.11 43.74-13.81 63.994-13.295 47.243-30.766 77.061-46.844 80.851-3.523.83-15.327 3.156-32.197 6.37l-1.342.256-1.749.332-1.746.332a8840.647 8840.647 0 01-32.263 6.06c-18.21 3.384-32.136 20.086-32.136 38.59v163.196c0 24.132 20.632 41.679 44.363 37.833l292.717-47.483c27.6-4.478 47.285-30.198 44.75-57.959-.431-2.702-.431-2.702-.5-3.082-.226-1.556-.243-3.657.369-6.532.3-.694 2.35-4.867 2.874-5.997 3.723-8.04 5.924-15.976 6.666-26.388.557-7.8.03-12.7-1.587-20.318-.918-4.326-1.062-5.78-.723-9.714.263-3.046.73-4.762 2.178-8.441l1.029-2.598c3.25-8.288 5.01-15.182 5.821-25.297.862-10.862-.15-18.403-2.837-28.083-.295-1.053-.436-1.555-.56-2.009l-.068-.246-.339-1.254c-.609-2.339-.726-3.387-.565-4.906.344-3.302.787-6.341 1.304-9.127.708-3.824 1.35-6.24 1.637-7.088 9.334-38.389-16.793-67.536-54.125-63.088l-70.278 8.36zM375 521.478v158.083l-32.731 5.31V527.634a8889.391 8889.391 0 0032.73-6.156zm138.164-222.765c15.574-.92 25.242 9.215 23.981 25.668l-6.303 82.286c-1.86 24.596 17.736 43.54 42.162 40.656l74.928-8.913c8.607-1.026 11.207 1.875 9.214 10.148-.385.872-1.537 5.209-2.621 11.059a157.817 157.817 0 00-1.774 12.372c-.747 7.07-.093 12.934 1.68 19.749.617 2.29.617 2.29 1.142 4.158 1.488 5.359 1.877 8.262 1.452 13.625-.455 5.66-1.223 8.67-3.078 13.398l-1.008 2.548c-2.8 7.11-4.262 12.491-4.92 20.128-.745 8.644-.222 13.94 1.51 22.1.844 3.975.984 5.28.751 8.545-.363 5.1-1.217 8.178-2.914 11.841-.077.167-.848 1.74-1.652 3.416l-.242.504a106.53 106.53 0 00-1.415 3.05c-1.465 3.387-2.498 6.644-3.091 10.267-1.13 6.88-1.077 13.224-.267 18.794.318 1.884.428 2.533.564 3.149l.044.194c.06.262.13.54.226.923-.04 2.693-4.637 8.7-10.523 9.655l-214.344 34.769.001-159.993c33.76-11.02 55.84-50.13 72.32-108.697 6.177-21.948 11.069-45.305 14.836-68.64 2.26-14 3.653-24.948 4.304-31.36.21-1.474 2.873-4.404 5.037-5.399z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgThumbCircle" }, props, { ref }), React__namespace.createElement(SvgIcon$q, null));
  });
  const SvgIcon$p = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M222.222 111.111h555.556c30.682 0 55.555 24.873 55.555 55.556v250c0 15.34-12.436 27.777-27.777 27.777-15.342 0-27.778-12.436-27.778-27.777v-250H222.222v666.666h194.445c15.34 0 27.777 12.437 27.777 27.778s-12.436 27.778-27.777 27.778H222.222c-30.682 0-55.555-24.873-55.555-55.556V166.667c0-30.683 24.873-55.556 55.555-55.556z" }), React__namespace.createElement("path", { d: "M722.222 888.889c92.048 0 166.667-74.62 166.667-166.667s-74.62-166.666-166.667-166.666-166.666 74.619-166.666 166.666c0 92.048 74.619 166.667 166.666 166.667zm0 55.555C599.492 944.444 500 844.952 500 722.222S599.492 500 722.222 500s222.222 99.492 222.222 222.222-99.492 222.222-222.222 222.222z", fillRule: "nonzero" }), React__namespace.createElement("path", { d: "M694.444 640.488c0-15.341 12.437-27.778 27.778-27.778S750 625.147 750 640.488v71.175l53.834 53.834c10.848 10.848 10.848 28.436 0 39.284-10.848 10.848-28.436 10.848-39.284 0l-53.834-53.834a55.556 55.556 0 01-16.272-39.284v-71.175z", fillRule: "nonzero" }), React__namespace.createElement("path", { d: "M305.556 277.778h333.333c15.341 0 27.778 12.436 27.778 27.778 0 15.34-12.437 27.777-27.778 27.777H305.556c-15.342 0-27.778-12.436-27.778-27.777 0-15.342 12.436-27.778 27.778-27.778zM305.556 388.889h222.222c15.341 0 27.778 12.436 27.778 27.778 0 15.34-12.437 27.777-27.778 27.777H305.556c-15.342 0-27.778-12.436-27.778-27.777 0-15.342 12.436-27.778 27.778-27.778zM305.556 500h111.11c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.777 27.778H305.556c-15.342 0-27.778-12.437-27.778-27.778S290.214 500 305.556 500z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgTodoListO" }, props, { ref }), React__namespace.createElement(SvgIcon$p, null));
  });
  const SvgIcon$o = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M722.206 555.572c92.055 0 166.666 74.556 166.666 166.667 0 92.055-74.61 166.667-166.666 166.667s-166.667-74.612-166.667-166.667c0-92.111 74.611-166.667 166.667-166.667zm55.572-444.46c30.722 0 55.555 24.832 55.555 55.555v364.166C800.5 511.723 762.89 500 722.223 500 599.5 500 500 599.5 500 722.222c0 66.722 30.056 125.945 76.667 166.667H222.222c-30.722 0-55.555-24.833-55.555-55.556V166.667c0-30.723 24.833-55.556 55.555-55.556zm-55.572 501.571c-15.334 0-27.778 12.5-27.778 27.778v71.167a55.545 55.545 0 0016.278 39.278l53.833 53.888c10.833 10.834 28.444 10.834 39.278 0 10.833-10.833 10.833-28.444 0-39.277l-53.834-53.89v-71.166c0-15.278-12.389-27.778-27.777-27.778zM416.666 500h-111.11c-15.334 0-27.778 12.444-27.778 27.778 0 15.333 12.444 27.778 27.778 27.778h111.11c15.334 0 27.778-12.445 27.778-27.778C444.444 512.444 432 500 416.667 500zm111.112-111.111H305.556c-15.334 0-27.778 12.444-27.778 27.778 0 15.333 12.444 27.777 27.778 27.777h222.222c15.333 0 27.778-12.444 27.778-27.777 0-15.334-12.445-27.778-27.778-27.778zm111.11-111.111H305.557c-15.334 0-27.778 12.444-27.778 27.778 0 15.333 12.444 27.777 27.778 27.777h333.333c15.333 0 27.778-12.444 27.778-27.777 0-15.334-12.445-27.778-27.778-27.778z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgTodoList" }, props, { ref }), React__namespace.createElement(SvgIcon$o, null));
  });
  const SvgIcon$n = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M166.667 277.778v555.555h666.666V277.778H166.667zm-55.556-55.556H888.89v611.111c0 30.683-24.873 55.556-55.556 55.556H166.667c-30.683 0-55.556-24.873-55.556-55.556v-611.11zM481.214 388.89a13.534 13.534 0 0113.467 12.188l19.011 190.12 118.698 74.531a13.875 13.875 0 01-11.636 24.956l-176.2-56.827h-.085l.002-.026-.027-.008.035-.076 23.268-232.67a13.534 13.534 0 0113.467-12.188zM798.998 111.11a55.556 55.556 0 0149.69 30.71l40.2 80.401h-62.112l-27.778-55.555H201.002l-27.778 55.555h-62.113l40.2-80.4a55.556 55.556 0 0149.69-30.71z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgTosend" }, props, { ref }), React__namespace.createElement(SvgIcon$n, null));
  });
  const SvgIcon$m = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M166.667 111.111h666.666c30.723 0 55.556 24.833 55.556 55.556v500c0 30.722-24.833 55.555-55.556 55.555H527.778v111.111h166.666c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.778 27.778H305.556c-15.342 0-27.778-12.437-27.778-27.778s12.436-27.778 27.778-27.778h166.666v-111.11H166.667c-30.723 0-55.556-24.834-55.556-55.556v-500c0-30.723 24.833-55.556 55.556-55.556zm0 555.556h666.666v-500H166.667v500zm450.31-242.323l-187.888 93.944c-13.721 6.86-30.407 1.299-37.268-12.423a27.778 27.778 0 01-2.932-12.422V305.556c0-15.342 12.436-27.778 27.778-27.778 4.312 0 8.565 1.004 12.422 2.932l187.887 93.944c13.722 6.86 19.284 23.546 12.423 37.268a27.778 27.778 0 01-12.423 12.422z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgTvO" }, props, { ref }), React__namespace.createElement(SvgIcon$m, null));
  });
  const SvgIcon$l = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M748.1 500H251.878c-17.111 0-29.778-15.222-27.834-32.278 14.945-129 118.612-229.889 248.167-242.889v-30.389c0-15.333 12.445-27.777 27.778-27.777 15.389 0 27.778 12.444 27.778 27.777v30.39c129.555 13 233.222 113.888 248.166 242.888C777.878 484.778 765.267 500 748.1 500zM527.767 722.222c0 45.945-37.39 83.334-83.334 83.334s-83.333-37.39-83.333-83.334v-27.778c0-15.333 12.444-27.777 27.778-27.777 15.389 0 27.778 12.444 27.778 27.777v27.778c0 15.278 12.5 27.778 27.777 27.778 15.334 0 27.778-12.5 27.778-27.778V555.556h55.556v166.666zM499.989 55.556c-245.445 0-444.445 199-444.445 444.444 0 245.444 199 444.444 444.445 444.444 245.444 0 444.444-199 444.444-444.444 0-245.444-199-444.444-444.444-444.444z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgUmbrellaCircle" }, props, { ref }), React__namespace.createElement(SvgIcon$l, null));
  });
  const SvgIcon$k = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M500 888.889c214.777 0 388.889-174.112 388.889-388.889 0-214.777-174.112-388.889-388.889-388.889-214.777 0-388.889 174.112-388.889 388.889 0 214.777 174.112 388.889 388.889 388.889zm0 55.555C254.54 944.444 55.556 745.46 55.556 500S254.54 55.556 500 55.556 944.444 254.54 944.444 500 745.46 944.444 500 944.444z" }), React__namespace.createElement("path", { d: "M496.972 222.222c9.933 0 18.25 7.527 19.239 17.411l27.16 271.601 169.568 106.473c8.466 5.316 11.648 16.104 7.424 25.163-4.225 9.06-14.535 13.556-24.048 10.488l-251.719-81.182-.117.001.003-.038-.038-.011.05-.107 33.24-332.388c.988-9.884 9.305-17.41 19.238-17.41z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgUnderwayO" }, props, { ref }), React__namespace.createElement(SvgIcon$k, null));
  });
  const SvgIcon$j = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 55.556c245.46 0 444.444 198.984 444.444 444.444S745.46 944.444 500 944.444 55.556 745.46 55.556 500 254.54 55.556 500 55.556zm-3.028 166.666c-9.933 0-18.25 7.527-19.239 17.411l-33.238 332.385-.05.11.038.01-.004.04.12-.001 251.716 81.181c9.4 3.032 19.578-1.322 23.894-10.166l.154-.322c4.224-9.06 1.042-19.847-7.424-25.163L543.37 511.234l-27.16-271.6c-.977-9.77-9.113-17.236-18.893-17.409z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgUnderway" }, props, { ref }), React__namespace.createElement(SvgIcon$j, null));
  });
  const SvgIcon$i = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M500 888.889c214.777 0 388.889-174.112 388.889-388.889 0-214.777-174.112-388.889-388.889-388.889-214.777 0-388.889 174.112-388.889 388.889 0 214.777 174.112 388.889 388.889 388.889zm0 55.555C254.54 944.444 55.556 745.46 55.556 500S254.54 55.556 500 55.556 944.444 254.54 944.444 500 745.46 944.444 500 944.444z", fillRule: "nonzero" }), React__namespace.createElement("path", { d: "M501.58 277.383l39.283 39.284L678.356 454.16c10.848 10.848 10.848 28.435 0 39.283-10.848 10.848-28.436 10.848-39.284 0l-111.69-111.69V694.05c0 15.34-12.436 27.777-27.777 27.777-15.341 0-27.778-12.436-27.778-27.777V385.702l-107.74 107.741c-10.849 10.848-28.437 10.848-39.284 0-10.848-10.848-10.848-28.435 0-39.283l137.493-137.493 39.283-39.284z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgUpgrade" }, props, { ref }), React__namespace.createElement(SvgIcon$i, null));
  });
  const SvgIcon$h = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M499.994 444.461c-61.277 0-111.11-49.833-111.11-111.111 0-61.278 49.833-111.111 111.11-111.111 61.278 0 111.112 49.833 111.112 111.111 0 61.278-49.834 111.111-111.112 111.111M666.661 333.35c0-92.056-74.611-166.667-166.667-166.667-92.055 0-166.666 74.611-166.666 166.667s74.61 166.667 166.666 166.667 166.667-74.611 166.667-166.667m113.283 435.928c-6.5 6.778-13.333 13.11-20.277 19.444-2.945 2.611-5.834 5.39-8.834 8-6.055 5.167-12.389 9.834-18.666 14.556-4.278 3.11-8.334 6.444-12.667 9.444-5.278 3.611-10.722 6.834-16.167 10.167-5.61 3.444-11.11 7.055-16.889 10.278-4.444 2.389-9.055 4.444-13.555 6.666-6.945 3.5-13.833 7.111-21.056 10.167-3.777 1.611-7.722 2.833-11.666 4.333-8 3.111-16.056 6.334-24.334 8.945-3.833 1.166-7.889 2-11.777 3.11-8.445 2.334-16.89 4.779-25.556 6.556-6.222 1.278-12.667 1.945-19 2.945-6.556 1-13 2.278-19.667 3a395.119 395.119 0 01-39.833 2c-13.389 0-26.722-.667-39.833-2-6.667-.722-13.111-2-19.667-3-6.389-1-12.778-1.667-19-2.945-8.667-1.777-17.111-4.222-25.556-6.555-3.888-1.111-7.944-1.945-11.777-3.111-8.278-2.611-16.334-5.834-24.334-8.945-3.944-1.5-7.889-2.722-11.666-4.333-7.223-3.056-14.111-6.667-21.056-10.167-4.5-2.222-9.111-4.277-13.611-6.666-5.722-3.223-11.222-6.834-16.833-10.278-5.445-3.333-10.945-6.556-16.167-10.167-4.333-3-8.444-6.333-12.667-9.444-6.277-4.722-12.61-9.39-18.666-14.556-3-2.61-5.89-5.389-8.834-8-6.944-6.333-13.777-12.666-20.277-19.444a64.608 64.608 0 01-1.89-2.111C278.834 670.11 383.89 611.11 500 611.11c116.111 0 221.111 59 281.833 156.056-.666.722-1.222 1.389-1.889 2.11M111.111 500c0-214.389 174.5-388.889 388.889-388.889S888.889 285.611 888.889 500c0 82.833-26.222 159.444-70.5 222.556-70.167-100.667-186.278-167-318.389-167-132.111 0-248.222 66.333-318.444 167C137.333 659.444 111.11 582.833 111.11 500m738.167 274.278c59.389-75.611 95.166-170.611 95.166-274.278 0-245.444-199-444.444-444.444-444.444-245.444 0-444.444 199-444.444 444.444 0 103.667 35.722 198.667 95.166 274.278 30.278 38.5 66.611 71.833 107.778 98.555 1.556.945 3.056 1.778 4.556 2.723a423.926 423.926 0 0035.61 20.333c3.556 1.833 7.223 3.5 10.778 5.222 10.5 4.945 21.056 9.556 31.89 13.667 4.722 1.778 9.444 3.555 14.222 5.222 10.222 3.5 20.61 6.556 31.222 9.333 5.278 1.39 10.389 2.89 15.722 4.056 11 2.444 22.167 4.278 33.444 5.944 4.89.667 9.723 1.667 14.723 2.278 16.222 1.778 32.61 2.833 49.333 2.833 16.722 0 33.111-1.055 49.333-2.833 4.945-.611 9.778-1.611 14.723-2.278 11.222-1.666 22.444-3.5 33.444-5.944 5.333-1.167 10.444-2.667 15.722-4.056 10.556-2.777 21-5.833 31.222-9.333 4.723-1.667 9.445-3.444 14.167-5.222 10.889-4.111 21.445-8.722 31.889-13.667 3.611-1.722 7.278-3.389 10.833-5.222a423.926 423.926 0 0035.611-20.333c1.5-.945 3-1.778 4.556-2.723 41.167-26.722 77.5-60.055 107.778-98.555", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgUserCircleO" }, props, { ref }), React__namespace.createElement(SvgIcon$h, null));
  });
  const SvgIcon$g = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M388.889 555.556L500 666.666l111.111-111.11h42.978c8.28 0 16.456 1.85 23.93 5.417l179.244 85.549a55.556 55.556 0 0131.626 50.138v192.229c0 30.682-24.873 55.555-55.556 55.555H166.667c-30.683 0-55.556-24.873-55.556-55.555v-192.23a55.556 55.556 0 0131.626-50.137l179.245-85.549a55.556 55.556 0 0123.93-5.417h42.977zm-23.012 55.555h-19.966L166.667 696.66v192.229h666.666v-192.23L654.09 611.112h-19.966L500 745.234 365.877 611.111zM500 55.556c122.73 0 222.222 99.492 222.222 222.222S622.73 500 500 500s-222.222-99.492-222.222-222.222S377.27 55.556 500 55.556zm0 55.555c-92.047 0-166.667 74.62-166.667 166.667S407.953 444.444 500 444.444s166.667-74.619 166.667-166.666c0-92.048-74.62-166.667-166.667-166.667z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgUserO" }, props, { ref }), React__namespace.createElement(SvgIcon$g, null));
  });
  const SvgIcon$f = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M166.667 166.667v666.666h666.666V166.667H166.667zm0-55.556h666.666c30.683 0 55.556 24.873 55.556 55.556v666.666c0 30.683-24.873 55.556-55.556 55.556H166.667c-30.683 0-55.556-24.873-55.556-55.556V166.667c0-30.683 24.873-55.556 55.556-55.556z", fillRule: "nonzero" }), React__namespace.createElement("path", { d: "M166.667 277.778h666.666v55.555H166.667zM616.976 608.179L429.09 702.122c-13.721 6.86-30.407 1.3-37.268-12.423a27.778 27.778 0 01-2.932-12.422V489.39c0-15.341 12.436-27.778 27.778-27.778 4.312 0 8.565 1.004 12.422 2.933l187.887 93.943c13.722 6.86 19.284 23.546 12.423 37.268a27.778 27.778 0 01-12.423 12.423zm-61.42-24.846l-111.112-55.555v111.11l111.112-55.555zM277.778 166.667h55.555l55.9 111.11h-55.556zM444.444 166.667H500l55.9 111.11h-55.556zM611.111 166.667h55.556l55.9 111.11H667.01z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgVideoO" }, props, { ref }), React__namespace.createElement(SvgIcon$f, null));
  });
  const SvgIcon$e = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M888.889 277.778H111.11V166.667c0-30.683 24.873-55.556 55.556-55.556h666.666c30.683 0 55.556 24.873 55.556 55.556v111.11zm0 55.555v500c0 30.683-24.873 55.556-55.556 55.556H166.667c-30.683 0-55.556-24.873-55.556-55.556v-500H888.89zM277.778 166.667l55.9 111.11h55.555l-55.9-111.11h-55.555zm166.666 0l55.9 111.11H555.9L500 166.668h-55.556zm166.667 0l55.9 111.11h55.555l-55.9-111.11h-55.555zm5.865 441.512a27.778 27.778 0 0012.423-12.423c6.86-13.722 1.299-30.407-12.423-37.268L429.09 464.545a27.778 27.778 0 00-12.422-2.933c-15.342 0-27.778 12.437-27.778 27.778v187.887c0 4.312 1.004 8.565 2.932 12.422 6.861 13.722 23.547 19.284 37.268 12.423l187.887-93.943z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgVideo" }, props, { ref }), React__namespace.createElement(SvgIcon$e, null));
  });
  const SvgIcon$d = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M888.889 166.667c30.667 0 55.555 24.889 55.555 55.555v555.556c0 30.722-24.888 55.555-55.555 55.555H111.11c-30.667 0-55.555-24.833-55.555-55.555V222.222c0-30.666 24.888-55.555 55.555-55.555zm0 166.666H111.11v444.445H888.89V333.333zm0-111.11H111.11v55.555H888.89v-55.556zM239.833 428.666h42.334l65.333 194h1l65.333-194h42.334l-84.667 238h-47l-84.667-238zm241.334 0h39v238h-39v-238zm85.666 0H665.5c57.333 0 86.333 24.333 86.333 73 0 49-29 73.666-87 73.666h-59v91.334h-39v-238zm39 33.333v80H662.5c17.333 0 30-3.333 38-9.333 8-6.334 12-16.667 12-31 0-14.334-4.333-24.334-12.333-30.334C692.167 465 679.5 462 662.5 462h-56.667z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgVipCardO" }, props, { ref }), React__namespace.createElement(SvgIcon$d, null));
  });
  const SvgIcon$c = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M944.444 277.778H55.556v-55.556c0-30.682 24.873-55.555 55.555-55.555H888.89c30.682 0 55.555 24.873 55.555 55.555v55.556zm0 55.555v444.445c0 30.682-24.873 55.555-55.555 55.555H111.11c-30.682 0-55.555-24.873-55.555-55.555V333.333h888.888zm-704.61 95.334l84.666 238h47l84.667-238h-42.334l-65.333 194h-1l-65.333-194h-42.334zm241.333 0v238h39v-238h-39zm85.666 0v238h39v-91.334h59c58 0 87-24.666 87-73.666 0-48.667-29-73-86.333-73h-98.667zm39 33.333H662.5c17 0 29.667 3 37.667 9.333 8 6 12.333 16 12.333 30.334 0 14.333-4 24.666-12 31-8 6-20.667 9.333-38 9.333h-56.667v-80z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgVipCard" }, props, { ref }), React__namespace.createElement(SvgIcon$c, null));
  });
  const SvgIcon$b = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "nonzero" }, React__namespace.createElement("path", { d: "M291.667 694.444l219.298 153.809V151.747L291.667 305.556H111.11v388.888h180.556zm0 55.556H97.222c-23.012 0-41.666-16.79-41.666-37.5v-425c0-20.71 18.654-37.5 41.666-37.5h194.445L513.889 83.333c30.682 0 55.555 17.49 55.555 39.063v755.208c0 21.574-24.873 39.063-55.555 39.063L291.667 750zM814.27 185.73C894.698 266.16 944.444 377.27 944.444 500c0 122.73-49.746 233.841-130.174 314.27l-39.284-39.284C845.361 704.611 888.889 607.389 888.889 500c0-107.389-43.528-204.61-113.903-274.986l39.284-39.284zM696.419 303.581C746.686 353.85 777.778 423.294 777.778 500c0 76.706-31.092 146.15-81.36 196.419l-39.283-39.284c40.214-40.214 65.087-95.77 65.087-157.135 0-61.365-24.873-116.92-65.087-157.135l39.284-39.284zm-19.925 401.4c-15.34 0-27.777-12.436-27.777-27.777 0-15.342 12.436-27.778 27.777-27.778 15.342 0 27.778 12.436 27.778 27.778 0 15.34-12.436 27.777-27.778 27.777zm1.047-353.435c-15.341 0-27.778-12.436-27.778-27.778 0-15.34 12.437-27.777 27.778-27.777s27.778 12.436 27.778 27.777c0 15.342-12.437 27.778-27.778 27.778zm116.655 471.108c-15.34 0-27.777-12.437-27.777-27.778s12.436-27.778 27.777-27.778c15.342 0 27.778 12.437 27.778 27.778s-12.436 27.778-27.778 27.778zm.109-589.863c-15.342 0-27.778-12.436-27.778-27.777 0-15.342 12.436-27.778 27.778-27.778 15.34 0 27.777 12.436 27.777 27.778 0 15.34-12.436 27.777-27.777 27.777z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgVolumeO" }, props, { ref }), React__namespace.createElement(SvgIcon$b, null));
  });
  const SvgIcon$a = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M513.511 136.339c18.5-11.111 42.056 2.222 42.056 23.833V839.84c0 21.611-23.556 34.944-42.056 23.833L290.956 730.117c-8.612-5.167-18.5-7.89-28.612-7.89H111.122c-30.722 0-55.555-24.833-55.555-55.555V333.34c0-30.722 24.833-55.556 55.555-55.556h151.222c10.112 0 20-2.722 28.612-7.944zm253.361 29.733c10.834-10.833 28.445-10.833 39.278 0 89.167 89.222 138.278 207.834 138.278 333.945 0 126.055-49.111 244.666-138.278 333.889a27.725 27.725 0 01-19.667 8.166c-7.055 0-14.166-2.722-19.61-8.166-10.834-10.834-10.834-28.39 0-39.278 78.666-78.722 122-183.334 122-294.611 0-111.278-43.334-215.945-122-294.667-10.834-10.833-10.834-28.444 0-39.278zm-117.889 117.89c10.834-10.834 28.445-10.834 39.278 0 57.722 57.666 89.5 134.388 89.5 216.055 0 81.61-31.778 158.333-89.5 216a27.725 27.725 0 01-19.667 8.166c-7.055 0-14.166-2.722-19.61-8.166-10.834-10.834-10.834-28.39 0-39.278 47.277-47.167 73.222-109.945 73.222-176.722 0-66.778-25.945-129.556-73.223-176.778-10.833-10.833-10.833-28.445 0-39.278z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgVolume" }, props, { ref }), React__namespace.createElement(SvgIcon$a, null));
  });
  const SvgIcon$9 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M536.155 105.516l349.721 299.76c11.648 9.984 12.997 27.52 3.013 39.168s-27.52 12.997-39.168 3.013l-16.388-14.046v399.922c0 30.683-24.917 55.56-55.655 55.56h-166.57c-30.738 0-55.655-24.877-55.655-55.56V666.667l-111.559-.004.028 166.674c0 30.682-24.918 55.555-55.656 55.555H222.322c-30.738 0-55.655-24.876-55.655-55.559V433.41l-16.388 14.047c-11.648 9.984-29.184 8.635-39.168-3.013-9.984-11.647-8.635-29.184 3.013-39.168l349.72-299.76c20.806-17.833 51.506-17.833 72.311 0zM500 147.696l-277.679 238.01v447.63h165.946l-.028-166.666c-.004-30.682 24.91-55.559 55.653-55.562l111.56.003c30.738 0 55.656 24.873 55.656 55.556v166.67h166.57V385.706L500 147.696z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgWapHomeO" }, props, { ref }), React__namespace.createElement(SvgIcon$9, null));
  });
  const SvgIcon$8 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M535.867 115.379l349.83 299.854c11.651 9.987 13 27.529 3.013 39.18-9.987 11.652-27.528 13.001-39.18 3.014l-16.414-14.098.022 400.095c0 30.692-24.926 55.576-55.673 55.576H610.843c-30.747 0-55.673-24.884-55.673-55.576V676.705H444.127v166.719l-.522.003c0 30.692-24.926 55.573-55.673 55.573H221.936c-30.748 0-55.673-24.884-55.673-55.576l-.021-400.095-16.372 14.098c-11.651 9.987-29.193 8.638-39.18-3.014-9.987-11.651-8.638-29.193 3.014-39.18l349.83-299.854c20.811-17.839 51.521-17.839 72.333 0z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgWapHome" }, props, { ref }), React__namespace.createElement(SvgIcon$8, null));
  });
  const SvgIcon$7 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M159.722 222.222h680.556c26.847 0 48.61 21.764 48.61 48.611 0 26.848-21.763 48.611-48.61 48.611H159.722c-26.847 0-48.61-21.763-48.61-48.61 0-26.848 21.763-48.612 48.61-48.612zm0 243.056h680.556c26.847 0 48.61 21.764 48.61 48.61 0 26.848-21.763 48.612-48.61 48.612H159.722c-26.847 0-48.61-21.764-48.61-48.611 0-26.847 21.763-48.611 48.61-48.611zm0 243.055h680.556c26.847 0 48.61 21.764 48.61 48.611 0 26.848-21.763 48.612-48.61 48.612H159.722c-26.847 0-48.61-21.764-48.61-48.612 0-26.847 21.763-48.61 48.61-48.61z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgWapNav" }, props, { ref }), React__namespace.createElement(SvgIcon$7, null));
  });
  const SvgIcon$6 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M497.455 222.233l-330.788 607.96h661.576l-330.788-607.96zm48.8-26.552l330.788 607.96c14.664 26.952 4.703 60.688-22.248 75.352a55.556 55.556 0 01-26.552 6.755H166.667c-30.683 0-55.556-24.873-55.556-55.555a55.556 55.556 0 016.756-26.552l330.788-607.96c14.664-26.951 48.4-36.912 75.351-22.248a55.556 55.556 0 0122.249 22.248z", fillRule: "nonzero" }), React__namespace.createElement("path", { d: "M472.484 400.03c-.091-4.104 2.838-7.43 7.14-7.43h41.266c4.035 0 7.235 3.12 7.14 7.43l-5.877 262.918c-.092 4.103-3.577 7.43-7.343 7.43h-29.107c-3.963 0-7.246-3.12-7.342-7.43l-5.877-262.918zm27.773 353.68c-15.342 0-27.778-12.436-27.778-27.777 0-15.341 12.436-27.778 27.778-27.778 15.34 0 27.777 12.437 27.777 27.778s-12.436 27.778-27.777 27.778z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgWarnO" }, props, { ref }), React__namespace.createElement(SvgIcon$6, null));
  });
  const SvgIcon$5 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M500 888.889c214.777 0 388.889-174.112 388.889-388.889 0-214.777-174.112-388.889-388.889-388.889-214.777 0-388.889 174.112-388.889 388.889 0 214.777 174.112 388.889 388.889 388.889zm0 55.555C254.54 944.444 55.556 745.46 55.556 500S254.54 55.556 500 55.556 944.444 254.54 944.444 500 745.46 944.444 500 944.444z", fillRule: "nonzero" }), React__namespace.createElement("path", { d: "M463.896 257.624c-.128-5.745 3.974-10.402 9.995-10.402h57.774c5.648 0 10.13 4.368 9.994 10.402l-8.227 368.085c-.128 5.745-5.007 10.402-10.28 10.402h-40.749c-5.549 0-10.145-4.367-10.28-10.402l-8.227-368.085zm38.882 495.154c-21.478 0-38.89-17.411-38.89-38.89 0-21.477 17.412-38.888 38.89-38.888s38.889 17.411 38.889 38.889-17.411 38.889-38.89 38.889z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgWarningO" }, props, { ref }), React__namespace.createElement(SvgIcon$5, null));
  });
  const SvgIcon$4 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("g", { fillRule: "evenodd" }, React__namespace.createElement("path", { d: "M500 55.556c245.46 0 444.444 198.984 444.444 444.444S745.46 944.444 500 944.444 55.556 745.46 55.556 500 254.54 55.556 500 55.556zM502.778 675c-21.478 0-38.89 17.411-38.89 38.889s17.412 38.889 38.89 38.889 38.889-17.411 38.889-38.89c0-21.477-17.411-38.888-38.89-38.888zm28.887-427.778H473.89c-6.021 0-10.123 4.657-9.995 10.402l8.227 368.085c.135 6.035 4.731 10.402 10.28 10.402h40.75c5.272 0 10.15-4.657 10.28-10.402l8.226-368.085c.135-6.034-4.346-10.402-9.994-10.402z" })));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgWarning" }, props, { ref }), React__namespace.createElement(SvgIcon$4, null));
  });
  const SvgIcon$3 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M500 666.667c-92.047 0-166.667-74.62-166.667-166.667S407.953 333.333 500 333.333 666.667 407.953 666.667 500 592.047 666.667 500 666.667zm388.889-55.556c-61.365 0-111.111-49.746-111.111-111.111s49.746-111.111 111.11-111.111C950.255 388.889 1000 438.635 1000 500s-49.746 111.111-111.111 111.111zm-777.778 0C49.746 611.111 0 561.365 0 500s49.746-111.111 111.111-111.111S222.222 438.635 222.222 500s-49.746 111.111-111.11 111.111z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgWeappNav" }, props, { ref }), React__namespace.createElement(SvgIcon$3, null));
  });
  const SvgIcon$2 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M373.247 606.702c-49.878 28.447-57.276-15.97-57.276-15.97l-62.51-149.228c-24.053-70.91 20.815-31.973 20.815-31.973s38.5 29.796 67.72 47.953c29.203 18.156 62.49 5.33 62.49 5.33l408.667-192.97c-75.398-95.976-199.947-158.733-340.952-158.733-230.118 0-416.645 167.01-416.645 373.04 0 118.505 61.764 223.98 157.97 292.342l-17.35 102.028s-8.457 29.786 20.855 15.97c19.973-9.419 70.893-43.174 101.205-63.717 47.65 16.987 99.566 26.42 153.988 26.42 230.1 0 416.665-167.01 416.665-373.043 0-59.676-15.721-116.034-43.568-166.059-130.203 80.142-433.047 266.389-472.074 288.61z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgWechatPay" }, props, { ref }), React__namespace.createElement(SvgIcon$2, null));
  });
  const SvgIcon$1 = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M677.715 374.35c141.332 0 267.175 102.227 267.175 227.747 0 70.018-46.134 132.111-108.227 179.37l-1.886 1.427 23.717 78.33-86.276-47.07-8.995 2.206c-28.5 6.962-57.153 13.483-85.508 13.483-149.681 0-267.538-102.106-267.538-227.746 0-125.4 117.857-227.747 267.538-227.747zM370.608 139c154.643 0 290.166 93.899 317.513 220.264-9.922-1.087-19.965-1.81-30.25-1.81-149.44 0-267.539 111.278-267.539 248.384 0 22.81 3.51 44.777 9.68 65.777-9.68.725-19.481 1.207-29.404 1.207-38.152 0-69.015-7.497-106.732-14.998l-3.501-.692-109.992 55.036 31.46-94.381C103.191 562.75 56 492.025 56 405.85 56 256.554 197.695 139 370.608 139zm224.22 357.008c-19.724 0-35.696 15.931-35.696 35.604 0 19.673 15.972 35.605 35.696 35.605 19.723 0 35.696-15.932 35.696-35.605 0-19.673-15.973-35.604-35.696-35.604zm173.155-.241c-19.723 0-35.696 15.931-35.696 35.604 0 19.673 15.973 35.604 35.696 35.604 19.724 0 35.696-15.931 35.696-35.604 0-19.673-15.972-35.604-35.696-35.604zm-503.131-226.66c-23.596 0-42.715 19.069-42.715 42.604s19.119 42.604 42.715 42.604c23.716 0 42.835-19.19 42.715-42.604 0-23.535-19.12-42.605-42.715-42.605zm219.742 0c-23.596 0-42.715 19.069-42.715 42.604s19.119 42.604 42.715 42.604c23.595 0 42.835-19.19 42.715-42.604 0-23.535-19.12-42.605-42.715-42.605z", fillRule: "nonzero" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgWechat" }, props, { ref }), React__namespace.createElement(SvgIcon$1, null));
  });
  const SvgIcon = (props) => React__namespace.createElement("svg", Object.assign({ width: "1em", height: "1em", viewBox: "0 0 1024 1024", xmlns: "http://www.w3.org/2000/svg", fill: "currentColor" }, props), React__namespace.createElement("path", { d: "M579.338 67.384l309.55 93.828v399.15c0 67.18 0 244.55-361.107 384.082C166.7 804.912 166.667 627.542 166.667 560.363v-399.15l315.906-95.23c2.737-.824 5.387-1.85 7.986-2.912 34.104-13.9 63.686-5.12 75.077-.564 4.466 1.786 9.018 3.46 13.702 4.877zM333.333 502.873v189.198c3.3 6.73 10.403 10.59 18.619 9.217l48.198-8.03v-211.56c-21.808 4.35-53.416 10.376-53.416 10.376-5.75 1.103-10.764 5.385-13.4 10.799zM421 689.786l231.778-38.61c17.057-2.836 29.246-19.504 27.656-37.258 0 0-1.6-6.325-.17-15.273 1.431-8.947 8.485-13.866 9.784-32.616 1.014-14.507-3.65-16.46-2.346-31.97 1.304-15.503 7.673-18.001 9.246-38.147 1.573-20.157-5.859-25.092-4.428-38.998 1.42-13.9 4.034-21.806 4.034-21.806 5.54-23.685-8.983-40.562-32.425-37.703l-77.241 9.448c-11.608 1.413-20.285-7.18-19.386-19.217l6.484-86.977c2.428-32.599-20.98-54.962-52.276-49.96l4.04-.647c-11.806 1.891-22.521 13.337-24.127 25.537 0 0-18.049 182.67-80.623 201.629v212.568z", fillRule: "evenodd" }));
  React__namespace.forwardRef((props, ref) => {
    return React__namespace.createElement(IconBase, Object.assign({ name: "SvgYouzanShield" }, props, { ref }), React__namespace.createElement(SvgIcon, null));
  });
  var index$$ = "";
  const [bem$1y] = createNamespace("cell-group");
  const CellGroup = (props) => {
    const { title, border, inset: insetP, card } = props;
    const inset = card || insetP;
    const renderGroup = () => /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$1y({ inset }), {
        [BORDER_TOP_BOTTOM]: !inset && border
      })
    }, props.children);
    const renderTitle = () => {
      if (title)
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$1y("title"))
        }, title);
      return null;
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: props.className,
      style: props.style
    }, renderTitle(), renderGroup());
  };
  CellGroup.defaultProps = {
    border: true
  };
  const [bem$1x] = createNamespace("cell");
  const Cell$1 = (props) => {
    const renderLabel = () => {
      const showLabel = isDef(props.label);
      if (showLabel) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$1x("label"), props.labelClass)
        }, props.label);
      }
      return null;
    };
    const renderTitle = () => {
      if (isDef(props.title)) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$1x("title"), props.titleClass),
          style: props.titleStyle
        }, props.title, renderLabel());
      }
      return null;
    };
    const renderValue = () => {
      const hasTitle = isDef(props.title);
      const hasValue = props.children || isDef(props.value);
      if (hasValue) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$1x("value", { alone: !hasTitle }), props.valueClass)
        }, props.children ? props.children : /* @__PURE__ */ React__default["default"].createElement("span", null, props.value));
      }
      return null;
    };
    const renderLeftIcon = () => {
      if (props.icon) {
        return React__default["default"].cloneElement(props.icon, {
          className: clsx(bem$1x("left-icon"))
        });
      }
      return null;
    };
    const renderRightIcon = () => {
      if (props.rightIcon) {
        return props.rightIcon;
      }
      if (props.isLink) {
        const className2 = clsx(bem$1x("right-icon"));
        if (props.arrowDirection === "left")
          return /* @__PURE__ */ React__default["default"].createElement(SvgArrowLeft, {
            className: className2
          });
        if (props.arrowDirection === "up")
          return /* @__PURE__ */ React__default["default"].createElement(SvgArrowUp, {
            className: className2
          });
        if (props.arrowDirection === "down")
          return /* @__PURE__ */ React__default["default"].createElement(SvgArrowDown, {
            className: className2
          });
        return /* @__PURE__ */ React__default["default"].createElement(SvgArrow, {
          className: className2
        });
      }
      return null;
    };
    const {
      className,
      style,
      size,
      center,
      border = true,
      isLink,
      required: required2,
      onClick
    } = props;
    const clickable = isLink || props.clickable;
    const classes = {
      center,
      required: required2,
      clickable,
      borderless: !border
    };
    if (size) {
      classes[size] = !!size;
    }
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      style,
      className: clsx(bem$1x(classes), className),
      role: clickable ? "button" : void 0,
      onClick
    }, renderLeftIcon(), renderTitle(), renderValue(), renderRightIcon(), props.extra);
  };
  const Cell = Object.assign(Cell$1, { Group: CellGroup });
  var index$_ = "";
  var index$Z = "";
  function _extends$4() {
    _extends$4 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$4.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose$3(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _setPrototypeOf$1(o, p2) {
    _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p3) {
      o2.__proto__ = p3;
      return o2;
    };
    return _setPrototypeOf$1(o, p2);
  }
  function _inheritsLoose$1(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf$1(subClass, superClass);
  }
  function hasClass(element, className) {
    if (element.classList)
      return !!className && element.classList.contains(className);
    return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
  }
  function addClass(element, className) {
    if (element.classList)
      element.classList.add(className);
    else if (!hasClass(element, className))
      if (typeof element.className === "string")
        element.className = element.className + " " + className;
      else
        element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
  }
  function replaceClassName(origClass, classToRemove) {
    return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
  }
  function removeClass$1(element, className) {
    if (element.classList) {
      element.classList.remove(className);
    } else if (typeof element.className === "string") {
      element.className = replaceClassName(element.className, className);
    } else {
      element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
    }
  }
  var config$1 = {
    disabled: false
  };
  var TransitionGroupContext = React__default["default"].createContext(null);
  var UNMOUNTED = "unmounted";
  var EXITED = "exited";
  var ENTERING = "entering";
  var ENTERED = "entered";
  var EXITING = "exiting";
  var Transition = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose$1(Transition2, _React$Component);
    function Transition2(props, context) {
      var _this;
      _this = _React$Component.call(this, props, context) || this;
      var parentGroup = context;
      var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
      var initialStatus;
      _this.appearStatus = null;
      if (props.in) {
        if (appear) {
          initialStatus = EXITED;
          _this.appearStatus = ENTERING;
        } else {
          initialStatus = ENTERED;
        }
      } else {
        if (props.unmountOnExit || props.mountOnEnter) {
          initialStatus = UNMOUNTED;
        } else {
          initialStatus = EXITED;
        }
      }
      _this.state = {
        status: initialStatus
      };
      _this.nextCallback = null;
      return _this;
    }
    Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
      var nextIn = _ref.in;
      if (nextIn && prevState.status === UNMOUNTED) {
        return {
          status: EXITED
        };
      }
      return null;
    };
    var _proto = Transition2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      this.updateStatus(true, this.appearStatus);
    };
    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      var nextStatus = null;
      if (prevProps !== this.props) {
        var status = this.state.status;
        if (this.props.in) {
          if (status !== ENTERING && status !== ENTERED) {
            nextStatus = ENTERING;
          }
        } else {
          if (status === ENTERING || status === ENTERED) {
            nextStatus = EXITING;
          }
        }
      }
      this.updateStatus(false, nextStatus);
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cancelNextCallback();
    };
    _proto.getTimeouts = function getTimeouts() {
      var timeout = this.props.timeout;
      var exit, enter, appear;
      exit = enter = appear = timeout;
      if (timeout != null && typeof timeout !== "number") {
        exit = timeout.exit;
        enter = timeout.enter;
        appear = timeout.appear !== void 0 ? timeout.appear : enter;
      }
      return {
        exit,
        enter,
        appear
      };
    };
    _proto.updateStatus = function updateStatus(mounting, nextStatus) {
      if (mounting === void 0) {
        mounting = false;
      }
      if (nextStatus !== null) {
        this.cancelNextCallback();
        if (nextStatus === ENTERING) {
          this.performEnter(mounting);
        } else {
          this.performExit();
        }
      } else if (this.props.unmountOnExit && this.state.status === EXITED) {
        this.setState({
          status: UNMOUNTED
        });
      }
    };
    _proto.performEnter = function performEnter(mounting) {
      var _this2 = this;
      var enter = this.props.enter;
      var appearing = this.context ? this.context.isMounting : mounting;
      var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM__default["default"].findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
      var timeouts2 = this.getTimeouts();
      var enterTimeout = appearing ? timeouts2.appear : timeouts2.enter;
      if (!mounting && !enter || config$1.disabled) {
        this.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode);
        });
        return;
      }
      this.props.onEnter(maybeNode, maybeAppearing);
      this.safeSetState({
        status: ENTERING
      }, function() {
        _this2.props.onEntering(maybeNode, maybeAppearing);
        _this2.onTransitionEnd(enterTimeout, function() {
          _this2.safeSetState({
            status: ENTERED
          }, function() {
            _this2.props.onEntered(maybeNode, maybeAppearing);
          });
        });
      });
    };
    _proto.performExit = function performExit() {
      var _this3 = this;
      var exit = this.props.exit;
      var timeouts2 = this.getTimeouts();
      var maybeNode = this.props.nodeRef ? void 0 : ReactDOM__default["default"].findDOMNode(this);
      if (!exit || config$1.disabled) {
        this.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
        return;
      }
      this.props.onExit(maybeNode);
      this.safeSetState({
        status: EXITING
      }, function() {
        _this3.props.onExiting(maybeNode);
        _this3.onTransitionEnd(timeouts2.exit, function() {
          _this3.safeSetState({
            status: EXITED
          }, function() {
            _this3.props.onExited(maybeNode);
          });
        });
      });
    };
    _proto.cancelNextCallback = function cancelNextCallback() {
      if (this.nextCallback !== null) {
        this.nextCallback.cancel();
        this.nextCallback = null;
      }
    };
    _proto.safeSetState = function safeSetState(nextState, callback) {
      callback = this.setNextCallback(callback);
      this.setState(nextState, callback);
    };
    _proto.setNextCallback = function setNextCallback(callback) {
      var _this4 = this;
      var active = true;
      this.nextCallback = function(event) {
        if (active) {
          active = false;
          _this4.nextCallback = null;
          callback(event);
        }
      };
      this.nextCallback.cancel = function() {
        active = false;
      };
      return this.nextCallback;
    };
    _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
      this.setNextCallback(handler);
      var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM__default["default"].findDOMNode(this);
      var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
      if (!node || doesNotHaveTimeoutOrListener) {
        setTimeout(this.nextCallback, 0);
        return;
      }
      if (this.props.addEndListener) {
        var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
        this.props.addEndListener(maybeNode, maybeNextCallback);
      }
      if (timeout != null) {
        setTimeout(this.nextCallback, timeout);
      }
    };
    _proto.render = function render2() {
      var status = this.state.status;
      if (status === UNMOUNTED) {
        return null;
      }
      var _this$props = this.props, children = _this$props.children;
      _this$props.in;
      _this$props.mountOnEnter;
      _this$props.unmountOnExit;
      _this$props.appear;
      _this$props.enter;
      _this$props.exit;
      _this$props.timeout;
      _this$props.addEndListener;
      _this$props.onEnter;
      _this$props.onEntering;
      _this$props.onEntered;
      _this$props.onExit;
      _this$props.onExiting;
      _this$props.onExited;
      _this$props.nodeRef;
      var childProps = _objectWithoutPropertiesLoose$3(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
      return /* @__PURE__ */ React__default["default"].createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : React__default["default"].cloneElement(React__default["default"].Children.only(children), childProps));
    };
    return Transition2;
  }(React__default["default"].Component);
  Transition.contextType = TransitionGroupContext;
  Transition.propTypes = {};
  function noop$2() {
  }
  Transition.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: noop$2,
    onEntering: noop$2,
    onEntered: noop$2,
    onExit: noop$2,
    onExiting: noop$2,
    onExited: noop$2
  };
  Transition.UNMOUNTED = UNMOUNTED;
  Transition.EXITED = EXITED;
  Transition.ENTERING = ENTERING;
  Transition.ENTERED = ENTERED;
  Transition.EXITING = EXITING;
  var Transition$1 = Transition;
  var _addClass = function addClass$1(node, classes) {
    return node && classes && classes.split(" ").forEach(function(c6) {
      return addClass(node, c6);
    });
  };
  var removeClass = function removeClass2(node, classes) {
    return node && classes && classes.split(" ").forEach(function(c6) {
      return removeClass$1(node, c6);
    });
  };
  var CSSTransition = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose$1(CSSTransition2, _React$Component);
    function CSSTransition2() {
      var _this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
      _this.appliedClasses = {
        appear: {},
        enter: {},
        exit: {}
      };
      _this.onEnter = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
        _this.removeClasses(node, "exit");
        _this.addClass(node, appearing ? "appear" : "enter", "base");
        if (_this.props.onEnter) {
          _this.props.onEnter(maybeNode, maybeAppearing);
        }
      };
      _this.onEntering = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
        var type2 = appearing ? "appear" : "enter";
        _this.addClass(node, type2, "active");
        if (_this.props.onEntering) {
          _this.props.onEntering(maybeNode, maybeAppearing);
        }
      };
      _this.onEntered = function(maybeNode, maybeAppearing) {
        var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
        var type2 = appearing ? "appear" : "enter";
        _this.removeClasses(node, type2);
        _this.addClass(node, type2, "done");
        if (_this.props.onEntered) {
          _this.props.onEntered(maybeNode, maybeAppearing);
        }
      };
      _this.onExit = function(maybeNode) {
        var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
        _this.removeClasses(node, "appear");
        _this.removeClasses(node, "enter");
        _this.addClass(node, "exit", "base");
        if (_this.props.onExit) {
          _this.props.onExit(maybeNode);
        }
      };
      _this.onExiting = function(maybeNode) {
        var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
        _this.addClass(node, "exit", "active");
        if (_this.props.onExiting) {
          _this.props.onExiting(maybeNode);
        }
      };
      _this.onExited = function(maybeNode) {
        var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
        _this.removeClasses(node, "exit");
        _this.addClass(node, "exit", "done");
        if (_this.props.onExited) {
          _this.props.onExited(maybeNode);
        }
      };
      _this.resolveArguments = function(maybeNode, maybeAppearing) {
        return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
      };
      _this.getClassNames = function(type2) {
        var classNames = _this.props.classNames;
        var isStringClassNames = typeof classNames === "string";
        var prefix2 = isStringClassNames && classNames ? classNames + "-" : "";
        var baseClassName = isStringClassNames ? "" + prefix2 + type2 : classNames[type2];
        var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type2 + "Active"];
        var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type2 + "Done"];
        return {
          baseClassName,
          activeClassName,
          doneClassName
        };
      };
      return _this;
    }
    var _proto = CSSTransition2.prototype;
    _proto.addClass = function addClass2(node, type2, phase) {
      var className = this.getClassNames(type2)[phase + "ClassName"];
      var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
      if (type2 === "appear" && phase === "done" && doneClassName) {
        className += " " + doneClassName;
      }
      if (phase === "active") {
        node && node.scrollTop;
      }
      if (className) {
        this.appliedClasses[type2][phase] = className;
        _addClass(node, className);
      }
    };
    _proto.removeClasses = function removeClasses(node, type2) {
      var _this$appliedClasses$ = this.appliedClasses[type2], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
      this.appliedClasses[type2] = {};
      if (baseClassName) {
        removeClass(node, baseClassName);
      }
      if (activeClassName) {
        removeClass(node, activeClassName);
      }
      if (doneClassName) {
        removeClass(node, doneClassName);
      }
    };
    _proto.render = function render2() {
      var _this$props = this.props;
      _this$props.classNames;
      var props = _objectWithoutPropertiesLoose$3(_this$props, ["classNames"]);
      return /* @__PURE__ */ React__default["default"].createElement(Transition$1, _extends$4({}, props, {
        onEnter: this.onEnter,
        onEntered: this.onEntered,
        onEntering: this.onEntering,
        onExit: this.onExit,
        onExiting: this.onExiting,
        onExited: this.onExited
      }));
    };
    return CSSTransition2;
  }(React__default["default"].Component);
  CSSTransition.defaultProps = {
    classNames: ""
  };
  CSSTransition.propTypes = {};
  var CSSTransition$1 = CSSTransition;
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  var index$Y = "";
  const [bem$1w] = createNamespace("overlay");
  const Overlay = (props) => {
    const nodeRef = React.useRef(null);
    const { visible, duration } = props;
    const preventTouchMove = (event) => {
      if (!props.lockScroll)
        return;
      preventDefault(event, true);
    };
    const renderOverlay = () => {
      const style = __spreadValues(__spreadValues({
        zIndex: props.zIndex !== void 0 ? +props.zIndex : void 0,
        touchAction: props.lockScroll && "none"
      }, props.style), props.customStyle);
      if (isDef(duration)) {
        style.animationDuration = `${duration}ms`;
      }
      return withStopPropagation(props.stopPropagation, /* @__PURE__ */ React__default["default"].createElement("div", {
        ref: nodeRef,
        style,
        onClick: (e2) => {
          var _a;
          if (e2.target === e2.currentTarget) {
            (_a = props.onClick) == null ? void 0 : _a.call(props, e2);
          }
        },
        className: clsx(bem$1w(), props.className)
      }, props.children));
    };
    useEventListener("touchmove", preventTouchMove, { target: nodeRef });
    return /* @__PURE__ */ React__default["default"].createElement(CSSTransition$1, {
      nodeRef,
      mountOnEnter: true,
      unmountOnExit: true,
      in: visible,
      timeout: duration,
      classNames: "rv-fade"
    }, renderOverlay());
  };
  Overlay.defaultProps = {
    stopPropagation: ["click"],
    lockScroll: true,
    duration: 300
  };
  function callInterceptor(options) {
    const { interceptor, args, done, canceled } = options;
    if (interceptor) {
      const returnVal = interceptor.apply(null, args || []);
      if (isPromise(returnVal)) {
        returnVal.then((value) => {
          if (value) {
            done();
          } else if (canceled) {
            canceled();
          }
        }).catch(noop$3);
      } else if (returnVal) {
        done();
      } else if (canceled) {
        canceled();
      }
    } else {
      done();
    }
  }
  function resolveContainer(getContainer) {
    const container = typeof getContainer === "function" ? getContainer() : getContainer;
    return container || document.body;
  }
  function canUseDom() {
    return !!(typeof window !== "undefined" && window.document && window.document.createElement);
  }
  function renderToContainer(getContainer, node) {
    if (canUseDom() && getContainer) {
      const container = resolveContainer(getContainer);
      return ReactDOM.createPortal(node, container);
    }
    return node;
  }
  const PopupContext = React.createContext({});
  let supportsPassive = false;
  if (canUseDom()) {
    try {
      const opts = {};
      Object.defineProperty(opts, "passive", {
        get() {
          supportsPassive = true;
        }
      });
      window.addEventListener("test-passive", null, opts);
    } catch (e2) {
    }
  }
  let totalLockCount = 0;
  const BODY_LOCK_CLASS = "rv-overflow-hidden";
  function useLockScroll(rootRef, shouldLock) {
    const touch = useTouch();
    const onTouchMove = (event) => {
      touch.move(event);
      const direction = touch.deltaY.current > 0 ? "10" : "01";
      const el = getScrollParent$1(event.target, rootRef.current);
      if (!el)
        return;
      const { scrollHeight, offsetHeight, scrollTop } = el;
      let status = "11";
      if (scrollTop === 0) {
        status = offsetHeight >= scrollHeight ? "00" : "01";
      } else if (scrollTop + offsetHeight >= scrollHeight) {
        status = "10";
      }
      if (status !== "11" && touch.isVertical() && !(parseInt(status, 2) & parseInt(direction, 2))) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    };
    const lock = () => {
      document.addEventListener("touchstart", touch.start);
      document.addEventListener("touchmove", onTouchMove, supportsPassive ? { passive: false } : false);
      if (!totalLockCount) {
        document.body.classList.add(BODY_LOCK_CLASS);
      }
      totalLockCount++;
    };
    const unlock = () => {
      if (totalLockCount) {
        document.removeEventListener("touchstart", touch.start);
        document.removeEventListener("touchmove", onTouchMove);
        totalLockCount--;
        if (!totalLockCount) {
          document.body.classList.remove(BODY_LOCK_CLASS);
        }
      }
    };
    React.useEffect(() => {
      if (shouldLock) {
        lock();
        return () => {
          unlock();
        };
      }
    }, [shouldLock]);
  }
  const sharedPopupProps = [
    "round",
    "zIndex",
    "closeable",
    "overlay",
    "overlayClass",
    "overlayStyle",
    "destroyOnClose",
    "forceRender",
    "lockScroll",
    "duration",
    "transition",
    "closeOnClickOverlay",
    "closeOnPopstate",
    "onClickOverlay",
    "safeAreaInsetBottom",
    "onOpen",
    "onClose",
    "onOpened",
    "onClosed",
    "beforeClose"
  ];
  let globalZIndex = 2e3;
  const [bem$1v] = createNamespace("popup");
  const Popup = React.forwardRef((props, ref) => {
    var _a;
    const {
      round: round2,
      closeable,
      title,
      description,
      children,
      duration,
      closeIcon,
      position
    } = props;
    const opened = React.useRef(false);
    const zIndex = React.useRef((_a = props.zIndex) != null ? _a : globalZIndex);
    const popupRef = React.useRef();
    const [visible, setVisible] = React.useState(props.visible);
    const [animatedVisible, setAnimatedVisible] = React.useState(visible);
    const style = React.useMemo(() => {
      const initStyle = __spreadValues({
        zIndex: zIndex.current
      }, props.style);
      if (isDef(props.duration)) {
        const key = props.position === "center" ? "animationDuration" : "transitionDuration";
        initStyle[key] = `${props.duration}ms`;
      }
      return initStyle;
    }, [zIndex.current, props.position, props.style, props.duration]);
    const open2 = () => {
      var _a2;
      if (props.zIndex !== void 0) {
        zIndex.current = +props.zIndex;
      } else {
        zIndex.current = globalZIndex++;
      }
      opened.current = true;
      (_a2 = props.onOpen) == null ? void 0 : _a2.call(props);
    };
    const close = () => {
      callInterceptor({
        interceptor: props.beforeClose,
        args: ["close"],
        done: () => {
          var _a2;
          opened.current = false;
          (_a2 = props.onClose) == null ? void 0 : _a2.call(props);
        }
      });
    };
    const onClickOverlay = (event) => {
      var _a2;
      (_a2 = props.onClickOverlay) == null ? void 0 : _a2.call(props, event);
      if (props.closeOnClickOverlay) {
        close();
      }
    };
    const renderOverlay = () => {
      if (props.overlay) {
        return /* @__PURE__ */ React__default["default"].createElement(Overlay, {
          visible,
          className: props.overlayClass,
          customStyle: props.overlayStyle,
          zIndex: zIndex.current,
          duration,
          onClick: onClickOverlay
        });
      }
      return null;
    };
    const onClickCloseIcon = (e2) => {
      if (props.onClickCloseIcon) {
        props.onClickCloseIcon(e2);
      }
      close();
    };
    const renderCloseIcon = () => {
      if (closeable) {
        const { closeIconPosition } = props;
        if (closeIcon) {
          return /* @__PURE__ */ React__default["default"].createElement("div", {
            className: clsx(bem$1v("close-icon", closeIconPosition)),
            onClick: onClickCloseIcon
          }, closeIcon);
        }
        return null;
      }
      return null;
    };
    const renderTitle = () => {
      if (title) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$1v("title"))
        }, title);
      }
      return null;
    };
    const renderDescription = () => {
      if (description) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$1v("description"))
        }, description);
      }
      return null;
    };
    const renderPopup = () => {
      const { safeAreaInsetBottom } = props;
      return withStopPropagation(props.stopPropagation, /* @__PURE__ */ React__default["default"].createElement("div", {
        ref: popupRef,
        style: __spreadProps(__spreadValues({}, style), {
          display: !visible && !animatedVisible ? "none" : void 0
        }),
        className: clsx(bem$1v({
          round: round2,
          [position]: position
        }), { "rv-safe-area-bottom": safeAreaInsetBottom }, props.className),
        onClick: props.onClick
      }, renderTitle(), renderDescription(), children, renderCloseIcon()));
    };
    const renderTransition = () => {
      const { transition, destroyOnClose, forceRender } = props;
      const name = position === "center" ? "rv-fade" : `rv-popup-slide-${position}`;
      return /* @__PURE__ */ React__default["default"].createElement(CSSTransition$1, {
        in: visible,
        nodeRef: popupRef,
        timeout: duration,
        classNames: transition || name,
        mountOnEnter: !forceRender,
        unmountOnExit: destroyOnClose,
        onEnter: open2,
        onEntered: props.onOpened,
        onExited: () => {
          var _a2;
          setAnimatedVisible(false);
          (_a2 = props.onClosed) == null ? void 0 : _a2.call(props);
        }
      }, renderPopup());
    };
    useEventListener("popstate", () => {
      if (props.closeOnPopstate) {
        close();
      }
    });
    useIsomorphicLayoutEffect(() => {
      if (visible) {
        setAnimatedVisible(true);
      }
    }, [visible]);
    useIsomorphicLayoutEffect(() => {
      setVisible(props.visible);
    }, [props.visible]);
    useLockScroll(popupRef, visible && props.lockScroll);
    React.useImperativeHandle(ref, () => ({
      popupRef
    }));
    return renderToContainer(props.teleport, /* @__PURE__ */ React__default["default"].createElement(PopupContext.Provider, {
      value: { visible }
    }, renderOverlay(), renderTransition()));
  });
  Popup.defaultProps = {
    duration: 300,
    overlay: true,
    lockScroll: true,
    position: "center",
    closeIcon: /* @__PURE__ */ React__default["default"].createElement(SvgCross, null),
    closeIconPosition: "top-right",
    closeOnClickOverlay: true,
    stopPropagation: ["click"],
    teleport: () => document.body
  };
  var index$X = "";
  const ActionButtonContext = React.createContext({});
  const [bem$1u] = createNamespace("action-bar");
  const ActionBar$1 = (props) => {
    const children = React.useMemo(() => React__default["default"].Children.toArray(props.children), [props.children]);
    return /* @__PURE__ */ React__default["default"].createElement(ActionButtonContext.Provider, {
      value: { parent: { children } }
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, bem$1u(), {
        "rv-safe-area-bottom": props.safeAreaInsetBottom
      }),
      style: props.style
    }, React__default["default"].Children.toArray(props.children).filter(Boolean).map((child, index2) => React__default["default"].cloneElement(child, {
      index: index2
    }))));
  };
  ActionBar$1.defaultProps = {
    safeAreaInsetBottom: true
  };
  const [bem$1t] = createNamespace("action-bar-icon");
  const ActionBarIcon = (props) => {
    const renderIcon = () => {
      const { badge, icon } = props;
      if (icon) {
        return /* @__PURE__ */ React__default["default"].createElement(Badge, __spreadProps(__spreadValues({}, badge), {
          className: clsx(bem$1t("icon"))
        }), icon);
      }
      return null;
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      role: "button",
      className: clsx(props.className, bem$1t()),
      style: props.style,
      tabIndex: 0,
      onClick: props.onClick
    }, renderIcon(), props.children || props.text);
  };
  const [bem$1s] = createNamespace("action-bar-button");
  const ActionBarButton = (props) => {
    const { type: type2, icon, text, color, loading, disabled, index: index2 } = props;
    const { parent } = React.useContext(ActionButtonContext);
    const isFirst = React.useMemo(() => {
      if (parent) {
        const prev2 = parent.children[index2 - 1];
        return !(prev2 && "isButton" in prev2.type);
      }
      return false;
    }, [index2, parent]);
    const isLast = React.useMemo(() => {
      if (parent) {
        const next = parent.children[index2 + 1];
        return !(next && "isButton" in next.type);
      }
      return false;
    }, [index2, parent]);
    return /* @__PURE__ */ React__default["default"].createElement(Button, {
      className: clsx(props.className, bem$1s([
        type2,
        {
          last: isLast,
          first: isFirst
        }
      ])),
      style: props.style,
      size: "large",
      type: type2,
      icon,
      color,
      loading,
      disabled,
      onClick: props.onClick
    }, props.children ? props.children : text);
  };
  const ActionBarButtonNameSpace = Object.assign(ActionBarButton, {
    isButton: true
  });
  const ActionBar = Object.assign(ActionBar$1, {
    Icon: ActionBarIcon,
    Button: ActionBarButtonNameSpace
  });
  function assignKey(to2, from, key) {
    const val = from[key];
    if (!isDef(val)) {
      return;
    }
    if (!Object.prototype.hasOwnProperty.call(to2, key) || !isObject$1(val)) {
      to2[key] = val;
    } else {
      to2[key] = deepAssign(Object(to2[key]), from[key]);
    }
  }
  function deepAssign(to2, from) {
    Object.keys(from).forEach((key) => {
      assignKey(to2, from, key);
    });
    return to2;
  }
  const base = {
    name: "\u59D3\u540D",
    tel: "\u7535\u8BDD",
    save: "\u4FDD\u5B58",
    confirm: "\u786E\u8BA4",
    cancel: "\u53D6\u6D88",
    delete: "\u5220\u9664",
    loading: "\u52A0\u8F7D\u4E2D...",
    noCoupon: "\u6682\u65E0\u4F18\u60E0\u5238",
    nameEmpty: "\u8BF7\u586B\u5199\u59D3\u540D",
    telInvalid: "\u8BF7\u586B\u5199\u6B63\u786E\u7684\u7535\u8BDD",
    vanCalendar: {
      end: "\u7ED3\u675F",
      start: "\u5F00\u59CB",
      title: "\u65E5\u671F\u9009\u62E9",
      confirm: "\u786E\u5B9A",
      startEnd: "\u5F00\u59CB/\u7ED3\u675F",
      weekdays: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"],
      monthTitle: (year, month) => `${year}\u5E74${month}\u6708`,
      rangePrompt: (maxRange) => `\u6700\u591A\u9009\u62E9 ${maxRange} \u5929`
    },
    vanPicker: {
      select: "\u8BF7\u9009\u62E9"
    },
    vanContactCard: {
      addText: "\u6DFB\u52A0\u8054\u7CFB\u4EBA"
    },
    vanContactList: {
      addText: "\u65B0\u5EFA\u8054\u7CFB\u4EBA"
    },
    vanPagination: {
      prev: "\u4E0A\u4E00\u9875",
      next: "\u4E0B\u4E00\u9875"
    },
    vanPullRefresh: {
      pulling: "\u4E0B\u62C9\u5373\u53EF\u5237\u65B0...",
      loosing: "\u91CA\u653E\u5373\u53EF\u5237\u65B0...",
      loading: "\u52A0\u8F7D\u4E2D..."
    },
    vanSubmitBar: {
      label: "\u5408\u8BA1\uFF1A"
    },
    vanCoupon: {
      unlimited: "\u65E0\u4F7F\u7528\u95E8\u69DB",
      discount: (discount) => `${discount}\u6298`,
      condition: (condition) => `\u6EE1${condition}\u5143\u53EF\u7528`
    },
    vanCouponCell: {
      title: "\u4F18\u60E0\u5238",
      count: (count) => `${count}\u5F20\u53EF\u7528`
    },
    vanCouponList: {
      exchange: "\u5151\u6362",
      close: "\u4E0D\u4F7F\u7528\u4F18\u60E0\u5238",
      enable: "\u53EF\u7528",
      disabled: "\u4E0D\u53EF\u7528",
      placeholder: "\u8BF7\u8F93\u5165\u4F18\u60E0\u7801"
    },
    vanAddressEdit: {
      area: "\u5730\u533A",
      postal: "\u90AE\u653F\u7F16\u7801",
      areaEmpty: "\u8BF7\u9009\u62E9\u5730\u533A",
      addressEmpty: "\u8BF7\u586B\u5199\u8BE6\u7EC6\u5730\u5740",
      postalEmpty: "\u90AE\u653F\u7F16\u7801\u4E0D\u6B63\u786E",
      defaultAddress: "\u8BBE\u4E3A\u9ED8\u8BA4\u6536\u8D27\u5730\u5740"
    },
    vanAddressEditDetail: {
      label: "\u8BE6\u7EC6\u5730\u5740",
      placeholder: "\u8857\u9053\u95E8\u724C\u4FE1\u606F"
    },
    vanAddressList: {
      add: "\u65B0\u589E\u5730\u5740"
    }
  };
  const zhCN = deepAssign(base, {});
  const INITIAL_STATE$1 = {
    locale: zhCN
  };
  const ConfigProvider$1 = React.createContext(INITIAL_STATE$1);
  const [bem$1r] = createNamespace("dialog");
  const Dialog$1 = (props) => {
    const { locale } = React.useContext(ConfigProvider$1);
    const _a = props, {
      width,
      title,
      theme,
      visible,
      message,
      className,
      messageAlign,
      closeOnClickOverlay,
      onClickCloseIcon
    } = _a, others = __objRest(_a, [
      "width",
      "title",
      "theme",
      "visible",
      "message",
      "className",
      "messageAlign",
      "closeOnClickOverlay",
      "onClickCloseIcon"
    ]);
    const renderTitle = () => {
      if (props.title) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$1r("header", {
            isolated: !props.message && !props.children
          }))
        }, title);
      }
      return null;
    };
    const renderContent = () => {
      if (props.children) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$1r("content"))
        }, props.children);
      }
      if (message) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$1r("content", { isolated: !title }))
        }, /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$1r("message", {
            "has-title": title,
            [messageAlign]: messageAlign
          }))
        }, message));
      }
      return null;
    };
    const renderButtons = () => {
      var _a2, _b, _c, _d, _e, _f;
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(BORDER_TOP, bem$1r("footer"))
      }, props.showCancelButton && /* @__PURE__ */ React__default["default"].createElement(Button, {
        size: "large",
        text: props.cancelButtonText || locale.cancel,
        className: clsx(bem$1r("cancel")),
        style: { color: props.cancelButtonColor },
        loading: (_a2 = props.cancelProps) == null ? void 0 : _a2.loading,
        disabled: (_b = props.cancelProps) == null ? void 0 : _b.disabled,
        onClick: ((_c = props.cancelProps) == null ? void 0 : _c.loading) ? noop$3 : props.onCancel
      }), props.showConfirmButton && /* @__PURE__ */ React__default["default"].createElement(Button, {
        size: "large",
        text: props.confirmButtonText || locale.confirm,
        className: clsx(bem$1r("confirm"), {
          [BORDER_LEFT]: props.showCancelButton
        }),
        round: theme === "round-button",
        style: { color: props.confirmButtonColor },
        loading: (_d = props.confirmProps) == null ? void 0 : _d.loading,
        disabled: (_e = props.confirmProps) == null ? void 0 : _e.disabled,
        onClick: ((_f = props.confirmProps) == null ? void 0 : _f.loading) ? noop$3 : props.onConfirm
      }));
    };
    const renderRoundButtons = () => {
      var _a2, _b, _c, _d, _e, _f;
      return /* @__PURE__ */ React__default["default"].createElement(ActionBar, {
        className: clsx(bem$1r("footer"))
      }, props.showCancelButton && /* @__PURE__ */ React__default["default"].createElement(ActionBar.Button, {
        type: "warning",
        text: props.cancelButtonText || locale.cancel,
        className: clsx(bem$1r("cancel")),
        color: props.cancelButtonColor,
        loading: (_a2 = props.cancelProps) == null ? void 0 : _a2.loading,
        disabled: (_b = props.cancelProps) == null ? void 0 : _b.disabled,
        onClick: ((_c = props.cancelProps) == null ? void 0 : _c.loading) ? noop$3 : props.onCancel
      }), props.showConfirmButton && /* @__PURE__ */ React__default["default"].createElement(ActionBar.Button, {
        type: "danger",
        text: props.confirmButtonText || locale.confirm,
        className: clsx(bem$1r("confirm")),
        color: props.confirmButtonColor,
        loading: (_d = props.confirmProps) == null ? void 0 : _d.loading,
        disabled: (_e = props.confirmProps) == null ? void 0 : _e.disabled,
        onClick: ((_f = props.confirmProps) == null ? void 0 : _f.loading) ? noop$3 : props.onConfirm
      }));
    };
    const renderFooter = () => {
      if (props.footer)
        return props.footer;
      return props.theme === "round-button" ? renderRoundButtons() : renderButtons();
    };
    return /* @__PURE__ */ React__default["default"].createElement(Popup, __spreadProps(__spreadValues({}, others), {
      visible,
      className: clsx(bem$1r([theme]), className),
      style: { width: addUnit$1(width) },
      "aria-labelledby": title || message,
      closeOnClickOverlay,
      onClickCloseIcon,
      onClose: props.onClose,
      onClosed: props.onClosed
    }), renderTitle(), renderContent(), renderFooter());
  };
  Dialog$1.defaultProps = {
    transition: "rv-dialog-bounce",
    showConfirmButton: true,
    closeOnPopstate: true
  };
  Number((React.version || "").split(".")[0]);
  const reactDomVersion = Number((ReactDOM.version || "").split(".")[0]);
  const fullClone = __spreadValues({}, ReactDOM__namespace);
  const { render: reactRender, unmountComponentAtNode } = fullClone;
  let createRoot;
  try {
    if (reactDomVersion >= 18 && fullClone.createRoot) {
      createRoot = fullClone.createRoot;
    }
  } catch (e2) {
  }
  function toggleWarning(skip) {
    const { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED } = fullClone;
    if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && typeof __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED === "object") {
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
    }
  }
  const MARK = "__react_vant_root__";
  function legacyRender(node, container) {
    reactRender(node, container);
  }
  function concurrentRender(node, container) {
    toggleWarning(true);
    const root2 = container[MARK] || createRoot(container);
    toggleWarning(false);
    root2.render(node);
    container[MARK] = root2;
  }
  function render(node, container) {
    if (createRoot) {
      concurrentRender(node, container);
      return;
    }
    legacyRender(node, container);
  }
  function legacyUnmount(container) {
    return unmountComponentAtNode(container);
  }
  async function concurrentUnmount(container) {
    return Promise.resolve().then(() => {
      var _a;
      (_a = container[MARK]) == null ? void 0 : _a.unmount();
      delete container[MARK];
    });
  }
  function unmount(container) {
    if (createRoot) {
      return concurrentUnmount(container);
    }
    return legacyUnmount(container);
  }
  const Dialog = Dialog$1;
  Dialog.show = (props) => {
    if (!canUseDom())
      return null;
    const defaultOptions2 = {
      overlay: true,
      closeable: false,
      closeIcon: /* @__PURE__ */ React__default["default"].createElement(SvgCross, null),
      lockScroll: true,
      transition: "rv-dialog-bounce",
      showConfirmButton: true,
      showCancelButton: false,
      closeOnClickOverlay: false
    };
    const _a = props, {
      onClosed,
      onCancel = noop$3,
      onConfirm = noop$3,
      onClose = noop$3,
      cancelProps,
      confirmProps
    } = _a, restProps = __objRest(_a, [
      "onClosed",
      "onCancel",
      "onConfirm",
      "onClose",
      "cancelProps",
      "confirmProps"
    ]);
    const userContainer = resolveContainer(props.teleport);
    const container = document.createElement("div");
    userContainer.appendChild(container);
    let destroy = noop$3;
    const TempDialog = () => {
      const [visible, setVisible] = React.useState(false);
      const [cancelLoading, setCancelLoading] = React.useState(false);
      const [okLoading, setOkLoading] = React.useState(false);
      React.useEffect(() => {
        setVisible(true);
      }, []);
      destroy = () => {
        setVisible(false);
        if (onClose)
          onClose();
      };
      const _afterClose = () => {
        if (onClosed) {
          onClosed();
        }
        const unmountResult = unmount(container);
        if (unmountResult && container.parentNode) {
          container.parentNode.removeChild(container);
        }
      };
      const _onConfirm = async (e2) => {
        const i = setTimeout(() => setOkLoading(true));
        if (await onConfirm(e2) !== false) {
          clearTimeout(i);
          destroy();
        } else {
          clearTimeout(i);
          setOkLoading(false);
        }
      };
      const _onCancel = async (e2, clickOverlay) => {
        if (clickOverlay) {
          destroy();
          return;
        }
        const i = setTimeout(() => setCancelLoading(true));
        if (await onCancel(e2) !== false) {
          clearTimeout(i);
          destroy();
        } else {
          clearTimeout(i);
          setCancelLoading(false);
        }
      };
      return /* @__PURE__ */ React__default["default"].createElement(Dialog$1, __spreadProps(__spreadValues(__spreadValues({}, defaultOptions2), restProps), {
        visible,
        teleport: () => container,
        cancelProps: __spreadValues({ loading: cancelLoading }, cancelProps),
        confirmProps: __spreadValues({ loading: okLoading }, confirmProps),
        onClose: destroy,
        onCancel: _onCancel,
        onConfirm: _onConfirm,
        onClosed: _afterClose
      }));
    };
    render(/* @__PURE__ */ React__default["default"].createElement(TempDialog, null), container);
    return destroy;
  };
  Dialog.alert = (props) => {
    const { onConfirm = noop$3 } = props;
    return new Promise((resolve) => {
      Dialog.show(__spreadProps(__spreadValues({}, props), {
        onConfirm: (e2) => {
          onConfirm(e2);
          resolve(e2);
        }
      }));
    });
  };
  Dialog.confirm = (props) => {
    const { onCancel = noop$3, onConfirm = noop$3 } = props;
    return new Promise((resolve, reject) => {
      Dialog.show(__spreadProps(__spreadValues({
        showCancelButton: true
      }, props), {
        onCancel: (e2) => {
          onCancel(e2);
          reject();
        },
        onConfirm: (e2) => {
          onConfirm(e2);
          resolve(true);
        }
      }));
    });
  };
  const [bem$1q] = createNamespace("input");
  const Input$1 = React.forwardRef((props, ref) => {
    const inputRef = React.useRef();
    const [inputFocus, setInputFocus] = React.useState(false);
    const compositionStartRef = React.useRef(false);
    const [value, setValue2] = usePropsValue(props);
    const {
      className,
      style,
      align,
      type: type2,
      name,
      placeholder,
      disabled,
      readOnly,
      maxLength,
      autoFocus
    } = props;
    const focus = () => {
      if (inputRef == null ? void 0 : inputRef.current) {
        inputRef.current.focus();
      }
    };
    const blur = () => {
      if (inputRef == null ? void 0 : inputRef.current) {
        inputRef.current.blur();
      }
    };
    React.useImperativeHandle(ref, () => ({
      clear: () => {
        setValue2("");
      },
      focus,
      blur,
      get nativeElement() {
        return inputRef.current;
      }
    }));
    const showClear = React.useMemo(() => {
      if (props.clearable && !readOnly) {
        const hasValue = value !== "";
        const trigger = props.clearTrigger === "always" || props.clearTrigger === "focus" && inputFocus;
        return hasValue && trigger;
      }
      return false;
    }, [value, props.clearTrigger, inputFocus]);
    const handleChange = (e2) => {
      var _a, _b;
      const inputValue = (_a = e2 == null ? void 0 : e2.currentTarget) == null ? void 0 : _a.value;
      let finalValue = inputValue;
      if (isDef(maxLength) && finalValue.length > +maxLength) {
        finalValue = finalValue.slice(0, maxLength);
        (_b = props.onOverlimit) == null ? void 0 : _b.call(props);
      }
      if (type2 === "number" || type2 === "digit") {
        const isNumber = type2 === "number";
        finalValue = formatNumber(finalValue, isNumber, isNumber);
      }
      setValue2(finalValue);
    };
    const handleFocus = (e2) => {
      var _a;
      setInputFocus(true);
      (_a = props.onFocus) == null ? void 0 : _a.call(props, e2);
      if (readOnly) {
        blur();
      }
    };
    const handleBulr = (e2) => {
      var _a;
      setInputFocus(false);
      (_a = props.onBlur) == null ? void 0 : _a.call(props, e2);
      resetScroll();
    };
    const handleKeyPress = (e2) => {
      var _a;
      if (e2.key === "Enter" || +e2.charCode === 13) {
        preventDefault(e2);
        if (props.type === "search") {
          blur();
        }
      }
      (_a = props.onKeyPress) == null ? void 0 : _a.call(props, e2);
    };
    const renderInput = () => {
      let inputType = type2;
      let inputMode;
      if (type2 === "number") {
        inputType = "text";
        inputMode = "decimal";
      }
      if (type2 === "digit") {
        inputType = "tel";
        inputMode = "numeric";
      }
      return /* @__PURE__ */ React__default["default"].createElement("input", {
        value,
        type: inputType,
        inputMode,
        ref: inputRef,
        name,
        className: clsx(bem$1q("control")),
        disabled,
        autoFocus,
        readOnly,
        placeholder: placeholder || "",
        onBlur: handleBulr,
        onFocus: handleFocus,
        onChange: handleChange,
        onKeyPress: handleKeyPress,
        autoCapitalize: props.autoCapitalize,
        autoCorrect: props.autoCorrect,
        onKeyDown: props.onKeyDown,
        onKeyUp: props.onKeyUp,
        onCompositionStart: (e2) => {
          var _a;
          compositionStartRef.current = true;
          (_a = props.onCompositionStart) == null ? void 0 : _a.call(props, e2);
        },
        onCompositionEnd: (e2) => {
          var _a;
          compositionStartRef.current = false;
          (_a = props.onCompositionEnd) == null ? void 0 : _a.call(props, e2);
        },
        onClick: props.onClick
      });
    };
    const handleClear = (e2) => {
      var _a;
      setValue2("");
      (_a = props.onClear) == null ? void 0 : _a.call(props, e2);
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$1q([align]), className),
      style
    }, props.prefix && /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$1q("prefix"))
    }, props.prefix), renderInput(), showClear && React__default["default"].cloneElement(props.clearIcon, {
      className: clsx(bem$1q("clear")),
      onTouchStart: handleClear
    }), props.suffix && /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$1q("suffix"))
    }, props.suffix));
  });
  Input$1.defaultProps = {
    clearIcon: /* @__PURE__ */ React__default["default"].createElement(SvgClear, null),
    clearTrigger: "focus",
    defaultValue: ""
  };
  const [bem$1p] = createNamespace("textarea");
  const TextArea = React.forwardRef((props, ref) => {
    const [hasFocus, setHasFocus] = React.useState(false);
    const nativeTextAreaRef = React.useRef();
    const compositionStartRef = React.useRef(false);
    const [value, setValue2] = usePropsValue(props);
    const {
      className,
      style,
      name,
      rows,
      placeholder,
      disabled,
      readOnly,
      maxLength,
      showWordLimit,
      autoFocus
    } = props;
    const focus = () => {
      if (nativeTextAreaRef == null ? void 0 : nativeTextAreaRef.current) {
        nativeTextAreaRef.current.focus();
      }
    };
    const blur = () => {
      if (nativeTextAreaRef == null ? void 0 : nativeTextAreaRef.current) {
        nativeTextAreaRef.current.blur();
      }
    };
    React.useImperativeHandle(ref, () => ({
      clear: () => {
        setValue2("");
      },
      focus,
      blur,
      get nativeElement() {
        return nativeTextAreaRef.current;
      }
    }));
    const adjustSize = () => {
      const input = nativeTextAreaRef.current;
      if (!input)
        return;
      input.style.height = "auto";
      let height = input.scrollHeight;
      if (isObject$1(props.autoSize)) {
        const { maxHeight, minHeight } = props.autoSize;
        if (maxHeight) {
          height = Math.min(height, maxHeight);
        }
        if (minHeight) {
          height = Math.max(height, minHeight);
        }
      }
      if (height) {
        input.style.height = `${height}px`;
      }
    };
    React.useEffect(() => {
      adjustSize();
    }, [value]);
    const controlClass = React__default["default"].useMemo(() => {
      return bem$1p("control", [
        {
          "min-height": !props.autoSize,
          clear: props.clearable
        }
      ]);
    }, [props.autoSize]);
    const handleChange = (e2) => {
      var _a;
      const inputValue = (_a = e2 == null ? void 0 : e2.currentTarget) == null ? void 0 : _a.value;
      let finalValue = inputValue;
      if (isDef(maxLength) && finalValue.length > +maxLength) {
        finalValue = finalValue.slice(0, maxLength);
      }
      setValue2(finalValue);
    };
    const handleFocus = (e2) => {
      var _a;
      setHasFocus(true);
      (_a = props.onFocus) == null ? void 0 : _a.call(props, e2);
      if (readOnly) {
        blur();
      }
    };
    const handleBulr = (e2) => {
      var _a;
      setHasFocus(false);
      (_a = props.onBlur) == null ? void 0 : _a.call(props, e2);
      resetScroll();
    };
    const renderWordLimit = () => {
      if (showWordLimit) {
        const currentCount = (value ? `${value}` : "").length;
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$1p("word-limit"))
        }, typeof showWordLimit === "function" ? showWordLimit({ currentCount, maxLength }) : /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, /* @__PURE__ */ React__default["default"].createElement("span", {
          className: clsx(bem$1p("word-num"))
        }, currentCount), maxLength ? `/${maxLength}` : false));
      }
      return null;
    };
    const handleClear = (e2) => {
      var _a;
      setValue2("");
      (_a = props.onClear) == null ? void 0 : _a.call(props, e2);
    };
    const showClear = React.useMemo(() => {
      if (props.clearable && !readOnly) {
        const hasValue = value !== "";
        const trigger = props.clearTrigger === "always" || props.clearTrigger === "focus" && hasFocus;
        return hasValue && trigger;
      }
      return false;
    }, [value, props.clearTrigger, hasFocus]);
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$1p(), className),
      style
    }, /* @__PURE__ */ React__default["default"].createElement("textarea", {
      ref: nativeTextAreaRef,
      name,
      rows,
      className: clsx(controlClass),
      value,
      disabled,
      autoFocus,
      readOnly,
      placeholder: placeholder || "",
      onBlur: handleBulr,
      onFocus: handleFocus,
      onChange: handleChange,
      onKeyPress: props.onKeyPress,
      onKeyDown: props.onKeyDown,
      onKeyUp: props.onKeyUp,
      autoComplete: props.autoComplete,
      onCompositionStart: (e2) => {
        var _a;
        compositionStartRef.current = true;
        (_a = props.onCompositionStart) == null ? void 0 : _a.call(props, e2);
      },
      onCompositionEnd: (e2) => {
        var _a;
        compositionStartRef.current = false;
        (_a = props.onCompositionEnd) == null ? void 0 : _a.call(props, e2);
      },
      onClick: props.onClick
    }), showClear && React__default["default"].cloneElement(props.clearIcon, {
      className: clsx(bem$1p("clear")),
      onTouchStart: handleClear
    }), renderWordLimit());
  });
  TextArea.defaultProps = {
    rows: 2,
    clearIcon: /* @__PURE__ */ React__default["default"].createElement(SvgClear, null),
    clearTrigger: "focus",
    defaultValue: ""
  };
  var index$W = "";
  var index$V = "";
  const Input = Object.assign(Input$1, { TextArea });
  const [bem$1o] = createNamespace("field");
  const Field$1 = React.forwardRef((props, ref) => {
    var _a;
    const inputRef = React.useRef(null);
    const textareaRef = React.useRef(null);
    const elementRef = props.type === "textarea" ? textareaRef : inputRef;
    const focus = () => {
      if (elementRef.current) {
        elementRef.current.focus();
      }
    };
    const blur = () => {
      if (elementRef.current) {
        elementRef.current.blur();
      }
    };
    const clear2 = () => {
      if (elementRef.current) {
        elementRef.current.clear();
      }
    };
    React.useImperativeHandle(ref, () => ({
      focus,
      blur,
      clear: clear2,
      get nativeElement() {
        return elementRef.current.nativeElement;
      }
    }));
    const getProp = (key) => {
      if (isDef(props[key])) {
        return props[key];
      }
      return null;
    };
    const labelStyle = () => {
      const labelW = getProp("labelWidth");
      if (labelW) {
        return { width: addUnit$1(labelW) };
      }
      return {};
    };
    const formatValue2 = (inputValue, trigger = "onChange") => {
      const { formatTrigger, formatter } = props;
      if (formatter && trigger === formatTrigger) {
        return formatter(inputValue);
      }
      return inputValue;
    };
    const onChange = (val) => {
      var _a2;
      (_a2 = props.onChange) == null ? void 0 : _a2.call(props, formatValue2(val));
    };
    const renderInput = () => {
      const {
        value,
        defaultValue,
        align,
        type: type2,
        placeholder,
        name,
        maxLength,
        disabled: disabled2,
        readOnly,
        clearable,
        clearIcon,
        clearTrigger,
        autoFocus,
        onClear,
        onBlur,
        onFocus,
        onKeyPress,
        onOverlimit
      } = props;
      if (props.children) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$1o("children"))
        }, props.children);
      }
      const commonProps = {
        value,
        onChange,
        placeholder,
        name,
        defaultValue,
        disabled: disabled2,
        clearable,
        clearIcon,
        clearTrigger,
        onClear,
        onBlur,
        onFocus,
        onKeyPress,
        onOverlimit,
        autoFocus,
        readOnly,
        maxLength,
        onClick: props.onClickInput
      };
      if (type2 === "textarea") {
        return /* @__PURE__ */ React__default["default"].createElement(Input.TextArea, __spreadValues({
          ref: textareaRef,
          autoSize: props.autoSize,
          showWordLimit: props.showWordLimit,
          rows: props.rows
        }, commonProps));
      }
      return /* @__PURE__ */ React__default["default"].createElement(Input, __spreadValues({
        ref: inputRef,
        type: type2,
        align
      }, commonProps));
    };
    const renderLeftIcon = () => {
      const { leftIcon, onClickLeftIcon } = props;
      if (!leftIcon)
        return null;
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$1o("left-icon")),
        onClick: onClickLeftIcon
      }, leftIcon);
    };
    const renderRightIcon = () => {
      const { rightIcon, onClickRightIcon } = props;
      if (!rightIcon)
        return null;
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$1o("right-icon")),
        onClick: onClickRightIcon
      }, rightIcon);
    };
    const renderMessage = () => {
      const message = props.errorMessage;
      if (message) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$1o("error-message"))
        }, message);
      }
      return null;
    };
    const renderIntro = () => {
      if (props.intro) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$1o("intro"))
        }, props.intro);
      }
      return null;
    };
    const renderTooltip = () => {
      const { tooltip } = props;
      if (tooltip) {
        let icon = /* @__PURE__ */ React__default["default"].createElement(SvgQuestionO, null);
        let dialogProps = { message: tooltip };
        if (!(React__default["default"].isValidElement(tooltip) || typeof tooltip === "string")) {
          const _a2 = tooltip, { icon: customIcon } = _a2, customDialogProps = __objRest(_a2, ["icon"]);
          icon = customIcon || icon;
          dialogProps = customDialogProps;
        }
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$1o("tooltip")),
          onClick: () => Dialog.show(dialogProps)
        }, icon);
      }
      return null;
    };
    const renderLabel = () => {
      const { label, colon } = props;
      if (label) {
        return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, label, !!colon && ":", renderTooltip());
      }
      return null;
    };
    const {
      size,
      center,
      border,
      isLink,
      required: required2,
      clickable,
      labelAlign,
      className,
      labelClass,
      valueClass,
      controlAlign,
      arrowDirection,
      disabled,
      titleStyle,
      error
    } = props;
    const suffix = (_a = props.suffix) != null ? _a : props.button;
    return /* @__PURE__ */ React__default["default"].createElement(Cell, {
      title: renderLabel(),
      size,
      icon: renderLeftIcon(),
      center,
      border,
      isLink,
      required: required2,
      clickable,
      extra: props.extra,
      titleStyle: __spreadValues(__spreadValues({}, labelStyle()), titleStyle),
      valueClass: clsx(bem$1o("value", [controlAlign]), valueClass),
      titleClass: clsx(bem$1o("label", labelAlign), labelClass),
      arrowDirection,
      onClick: props.onClick,
      style: props.style,
      className: clsx(bem$1o({
        error,
        disabled,
        [`label-${labelAlign}`]: labelAlign
      }), className)
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$1o("body"))
    }, props.prefix && /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$1o("prefix"))
    }, props.prefix), /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$1o("control-wrapper"))
    }, renderInput()), renderRightIcon(), suffix && /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$1o("suffix"))
    }, suffix)), renderMessage(), renderIntro());
  });
  Field$1.defaultProps = {
    clearIcon: /* @__PURE__ */ React__default["default"].createElement(SvgClear, null),
    clearTrigger: "focus",
    formatTrigger: "onChange",
    defaultValue: ""
  };
  const FIELD_KEY = Symbol("field");
  const FieldNamespace = Object.assign(Field$1, { [COMPONENT_TYPE_KEY]: FIELD_KEY });
  var index$U = "";
  const FlexContext = React.createContext({});
  const [bem$1n] = createNamespace("flexbox");
  const Flex$1 = (props) => {
    const _a = props, {
      direction,
      wrap,
      justify,
      align,
      gutter,
      style,
      className,
      children
    } = _a, rest = __objRest(_a, [
      "direction",
      "wrap",
      "justify",
      "align",
      "gutter",
      "style",
      "className",
      "children"
    ]);
    const getGutter = React.useMemo(() => Array.isArray(gutter) ? gutter : [gutter, 0], [gutter]);
    const rowStyle = __spreadValues(__spreadValues(__spreadValues({}, getGutter[0] > 0 ? {
      marginLeft: getGutter[0] / -2,
      marginRight: getGutter[0] / -2
    } : {}), getGutter[1] > 0 ? {
      marginTop: getGutter[1] / -2,
      marginBottom: getGutter[1] / 2
    } : {}), style);
    const wrapCls = clsx(className, bem$1n([
      direction,
      wrap,
      justify ? `justify-${justify}` : false,
      align ? `align-${align}` : false
    ]));
    return /* @__PURE__ */ React__default["default"].createElement(FlexContext.Provider, {
      value: { gutter: getGutter }
    }, /* @__PURE__ */ React__default["default"].createElement("div", __spreadValues({
      className: wrapCls,
      style: rowStyle
    }, rest), children));
  };
  Flex$1.defaultProps = {
    gutter: 0
  };
  const [bem$1m] = createNamespace("flexitem");
  const FlexItem = (props) => {
    const _a = props, { style, className, span, children, flex } = _a, others = __objRest(_a, ["style", "className", "span", "children", "flex"]);
    const classes = clsx(bem$1m([span == null ? void 0 : span.toString()]), className);
    const parseFlex = (_flex) => {
      if (typeof _flex === "number") {
        return `${_flex} ${_flex} auto`;
      }
      if (/^\d+(\.\d+)?(px|em|rem|%)$/.test(_flex)) {
        return `0 0 ${_flex}`;
      }
      return _flex;
    };
    return /* @__PURE__ */ React__default["default"].createElement(FlexContext.Consumer, null, ({ gutter }) => {
      let mergedStyle = __spreadValues({}, style);
      if (gutter) {
        mergedStyle = __spreadValues(__spreadValues(__spreadValues({}, gutter[0] > 0 ? {
          paddingLeft: gutter[0] / 2,
          paddingRight: gutter[0] / 2
        } : {}), gutter[1] > 0 ? {
          paddingTop: gutter[1] / 2,
          paddingBottom: gutter[1] / 2
        } : {}), mergedStyle);
      }
      if (flex) {
        mergedStyle.flex = parseFlex(flex);
      }
      return /* @__PURE__ */ React__default["default"].createElement("div", __spreadProps(__spreadValues({}, others), {
        style: mergedStyle,
        className: classes
      }), children);
    });
  };
  const Flex = Object.assign(Flex$1, { Item: FlexItem });
  var index$T = "";
  const formatGap = (gap) => typeof gap === "number" ? `${gap}px` : gap;
  const [bem$1l] = createNamespace("space");
  const Space = (props) => {
    const { wrap, block, direction, align, justify } = props;
    const style = React__default["default"].useMemo(() => {
      if (props.gap) {
        if (Array.isArray(props.gap)) {
          const [gapV, gapH] = props.gap;
          return __spreadProps(__spreadValues({}, props.style), {
            "--gap": `${formatGap(gapV)} ${formatGap(gapH)}`
          });
        }
        return __spreadProps(__spreadValues({}, props.style), {
          "--gap": formatGap(props.gap)
        });
      }
      return props.style;
    }, [props.style, props.gap]);
    const childList = React.useMemo(() => React__default["default"].Children.map(props.children, (c6) => c6).filter((c6) => c6 !== null && c6 !== void 0), [props.children]);
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, bem$1l({
        wrap,
        block,
        [`${direction}`]: !!direction,
        [`align-${align}`]: !!align,
        [`justify-${justify}`]: !!justify
      })),
      style,
      onClick: props.onClick
    }, childList.map((child, idx) => {
      return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, {
        key: idx
      }, /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$1l("item"))
      }, child), !!props.divider && idx !== childList.length - 1 && /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$1l("item-divider"))
      }, props.divider));
    }));
  };
  Space.defaultProps = {
    direction: "horizontal"
  };
  var index$S = "";
  const CheckMark = React.memo(() => {
    return /* @__PURE__ */ React__default["default"].createElement("svg", {
      width: "17px",
      height: "13px",
      viewBox: "0 0 17 13",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg"
    }, /* @__PURE__ */ React__default["default"].createElement("g", {
      stroke: "none",
      strokeWidth: "1",
      fill: "none",
      fillRule: "evenodd",
      strokeLinecap: "round",
      strokeLinejoin: "round"
    }, /* @__PURE__ */ React__default["default"].createElement("g", {
      transform: "translate(-2832.000000, -1103.000000)",
      stroke: "#FFFFFF",
      strokeWidth: "3"
    }, /* @__PURE__ */ React__default["default"].createElement("g", {
      transform: "translate(2610.000000, 955.000000)"
    }, /* @__PURE__ */ React__default["default"].createElement("g", {
      transform: "translate(24.000000, 91.000000)"
    }, /* @__PURE__ */ React__default["default"].createElement("g", {
      transform: "translate(179.177408, 36.687816)"
    }, /* @__PURE__ */ React__default["default"].createElement("polyline", {
      points: "34.2767388 22 24.797043 31.4796958 21 27.6826527"
    })))))));
  });
  const [bem$1k] = createNamespace("selector");
  const defaultProps = {
    multiple: false,
    defaultValue: [],
    showCheckMark: true
  };
  const Selector = (p2) => {
    const props = __spreadValues(__spreadValues({}, defaultProps), p2);
    const [value, setValue2] = usePropsValue({
      value: props.value,
      defaultValue: props.defaultValue,
      onChange: (val) => {
        var _a;
        const extend2 = {
          get items() {
            return props.options.filter((option) => val.includes(option.value));
          }
        };
        (_a = props.onChange) == null ? void 0 : _a.call(props, val, extend2);
      }
    });
    const items = props.options.map((option) => {
      const active = (value || []).includes(option.value);
      const disabled = option.disabled || props.disabled;
      const itemCls = clsx(bem$1k("item", {
        active: active && !props.multiple,
        "multiple-active": active && props.multiple,
        disabled
      }));
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        key: option.value,
        className: itemCls,
        onClick: () => {
          if (disabled) {
            return;
          }
          if (props.multiple) {
            const val = active ? value.filter((v2) => v2 !== option.value) : [...value, option.value];
            setValue2(val);
          } else {
            const val = active ? [] : [option.value];
            setValue2(val);
          }
        }
      }, option.label, option.description && /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$1k("item-description"))
      }, option.description), active && props.showCheckMark && /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$1k("check-mark-wrapper"))
      }, /* @__PURE__ */ React__default["default"].createElement(CheckMark, null)));
    });
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$1k(), props.className),
      style: props.style
    }, items);
  };
  var index$R = "";
  function useResizeEffect(effect3, targetRef) {
    const fn = useMemoizedFn(effect3);
    useIsomorphicLayoutEffect(() => {
      const target = targetRef.current;
      if (!target)
        return;
      if (window.ResizeObserver) {
        const observer = new ResizeObserver(() => {
          fn(target);
        });
        observer.observe(target);
        return () => {
          observer.disconnect();
        };
      } else {
        fn(target);
      }
    }, [targetRef]);
  }
  const Ellipsis = (props) => {
    const rootRef = React.useRef(null);
    const [ellipsised, setEllipsised] = React.useState({});
    const [expanded, setExpanded] = React.useState(false);
    const [exceeded, setExceeded] = React.useState(false);
    const suffixStr = React.useMemo(() => {
      if (props.suffixText)
        return props.suffixText;
      if (props.suffixCount > 0) {
        return props.children.slice(-props.suffixCount).trim();
      }
      return "";
    }, [props.suffixCount, props.suffixText]);
    function calcEllipsised() {
      const root2 = rootRef.current;
      if (!root2)
        return;
      const originStyle = window.getComputedStyle(root2);
      const container = document.createElement("div");
      const styleNames = Array.prototype.slice.apply(originStyle);
      styleNames.forEach((name) => {
        container.style.setProperty(name, originStyle.getPropertyValue(name));
      });
      container.style.position = "fixed";
      container.style.left = "999999px";
      container.style.top = "999999px";
      container.style.zIndex = "-1000";
      container.style.height = "auto";
      container.style.minHeight = "auto";
      container.style.maxHeight = "auto";
      container.style.textOverflow = "clip";
      container.style.whiteSpace = "normal";
      container.style.webkitLineClamp = "unset";
      container.style.display = "block";
      const lineHeight = pxToNumber(originStyle.lineHeight);
      const maxHeight = Math.floor(lineHeight * (props.rows + 0.5) + pxToNumber(originStyle.paddingTop) + pxToNumber(originStyle.paddingBottom));
      container.innerHTML = props.children;
      document.body.appendChild(container);
      if (container.offsetHeight <= maxHeight) {
        setExceeded(false);
      } else {
        let check = function(left2, right2) {
          if (right2 - left2 <= 1) {
            return {
              leading: props.children.slice(0, left2) + props.symbol
            };
          }
          const middle = Math.round((left2 + right2) / 2);
          container.innerHTML = props.children.slice(0, middle) + props.symbol + suffixStr + actionText;
          if (container.offsetHeight <= maxHeight) {
            return check(middle, right2);
          }
          return check(left2, middle);
        };
        setExceeded(true);
        const end2 = props.children.length;
        const actionText = expanded ? props.collapseText : props.expandText;
        const ellipsised2 = check(0, end2);
        setEllipsised(ellipsised2);
      }
      document.body.removeChild(container);
    }
    useResizeEffect(calcEllipsised, rootRef);
    useIsomorphicLayoutEffect(() => {
      calcEllipsised();
    }, [
      props.children,
      props.rows,
      suffixStr,
      props.expandText,
      props.collapseText
    ]);
    const onExpandClick = (isExpend) => {
      var _a;
      (_a = props.onExpend) == null ? void 0 : _a.call(props, isExpend);
      setExpanded(isExpend);
    };
    const expandActionElement = exceeded && props.expandText ? withStopPropagation(props.stopPropagationForActionButtons, /* @__PURE__ */ React__default["default"].createElement("a", {
      onClick: () => {
        onExpandClick(true);
      }
    }, props.expandText)) : null;
    const collapseActionElement = exceeded && props.expandText ? withStopPropagation(props.stopPropagationForActionButtons, /* @__PURE__ */ React__default["default"].createElement("a", {
      onClick: () => {
        onExpandClick(false);
      }
    }, props.collapseText)) : null;
    const renderContent = () => {
      if (!exceeded) {
        return props.children;
      }
      if (expanded) {
        return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, props.children, collapseActionElement);
      } else {
        return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, ellipsised.leading, suffixStr, expandActionElement);
      }
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      ref: rootRef,
      className: clsx("rv-typography__ellipsis", props.className),
      style: props.style
    }, renderContent());
  };
  function pxToNumber(value) {
    if (!value)
      return 0;
    const match = value.match(/^\d*(\.\d*)?/);
    return match ? Number(match[0]) : 0;
  }
  Ellipsis.defaultProps = {
    rows: 1,
    expandText: "",
    collapseText: "",
    suffixText: "",
    symbol: "...",
    stopPropagationForActionButtons: []
  };
  const [bem$1j] = createNamespace("typography");
  const ellipsisDefaultValue = {
    rows: 1
  };
  const TypographyBase = (_c) => {
    var _d = _c, {
      tag = "div",
      type: type2,
      size = "md",
      level = 5,
      center,
      ellipsis,
      className,
      children,
      strong,
      underline,
      disabled,
      renderType,
      delete: del,
      onClick
    } = _d, props = __objRest(_d, [
      "tag",
      "type",
      "size",
      "level",
      "center",
      "ellipsis",
      "className",
      "children",
      "strong",
      "underline",
      "disabled",
      "renderType",
      "delete",
      "onClick"
    ]);
    const internalClick = (e2) => {
      if (disabled) {
        e2.stopPropagation();
      }
      onClick == null ? void 0 : onClick(e2);
    };
    const ellipsisNumber = React.useMemo(() => {
      if (typeof ellipsis === "boolean" && ellipsis)
        return 1;
      if (typeof ellipsis === "number")
        return ellipsis;
      if (isObject$1(ellipsis) && ellipsis.rows)
        return ellipsis.rows;
      return 0;
    }, [ellipsis]);
    const isEllipsis = !!ellipsis;
    const isCssEllipsis = React.useMemo(() => {
      if (typeof ellipsis === "boolean")
        return true;
      if (typeof ellipsis === "number")
        return true;
      if (isObject$1(ellipsis)) {
        const p2 = __spreadValues(__spreadValues({}, ellipsisDefaultValue), ellipsis);
        if (!p2.collapseText && !p2.expandText && !p2.suffixCount && !p2.suffixText && !p2.symbol)
          return true;
      }
      return false;
    }, [ellipsis]);
    const isEnhanceEllipsis = isEllipsis && !isCssEllipsis;
    const TagElement = React.useMemo(() => {
      if (renderType === "title") {
        if (level === 1)
          return "h1";
        if (level === 2)
          return "h2";
        if (level === 3)
          return "h3";
        if (level === 4)
          return "h4";
        if (level === 5)
          return "h5";
        return "h6";
      }
      return tag;
    }, [tag]);
    const measureStyle = React.useMemo(() => {
      const propsStyle = __spreadProps(__spreadValues({}, props.style), { "--rv-typography-color": props.color });
      if (isEllipsis && isCssEllipsis && ellipsisNumber > 1) {
        return __spreadProps(__spreadValues({}, propsStyle), { "--line-clamp": ellipsisNumber });
      }
      return propsStyle;
    }, [props.style, isCssEllipsis]);
    const renderContent = () => {
      if (isEnhanceEllipsis)
        return /* @__PURE__ */ React__default["default"].createElement(Ellipsis, __spreadProps(__spreadValues(__spreadValues({
          onContentClick: internalClick,
          className: clsx(className, `rv-typography__${renderType}`, bem$1j([
            type2,
            size,
            {
              center,
              strong,
              underline,
              disabled,
              delete: del,
              [`l${level}`]: renderType === "title" && level
            }
          ]))
        }, props), ellipsis), {
          style: measureStyle
        }), children);
      return /* @__PURE__ */ React__default["default"].createElement(TagElement, __spreadProps(__spreadValues({
        className: clsx(className, `rv-typography__${renderType}`, bem$1j([
          type2,
          size,
          {
            center,
            strong,
            underline,
            disabled,
            delete: del,
            [`l${level}`]: renderType === "title" && level
          }
        ]), {
          "rv-ellipsis": isEllipsis && isCssEllipsis && ellipsisNumber === 1,
          "rv-typography__ellipsis--multi": isEllipsis && isCssEllipsis && ellipsisNumber > 1
        })
      }, props), {
        onClick: internalClick,
        style: measureStyle
      }), children);
    };
    return renderContent();
  };
  const Text = (props) => /* @__PURE__ */ React__default["default"].createElement(TypographyBase, __spreadValues({
    renderType: "text",
    tag: "span"
  }, props));
  const Title = (props) => /* @__PURE__ */ React__default["default"].createElement(TypographyBase, __spreadValues({
    renderType: "title",
    tag: "h1"
  }, props));
  const Link = (props) => /* @__PURE__ */ React__default["default"].createElement(TypographyBase, __spreadValues({
    renderType: "link",
    tag: "a"
  }, props));
  const TypographyNamespace = Object.assign(TypographyBase, { Text, Title, Link });
  var index$Q = "";
  function parseFormat(format2, currentTime) {
    const { days } = currentTime;
    let { hours, minutes, seconds, milliseconds } = currentTime;
    if (format2.includes("DD")) {
      format2 = format2.replace("DD", padZero(days));
    } else {
      hours += days * 24;
    }
    if (format2.includes("HH")) {
      format2 = format2.replace("HH", padZero(hours));
    } else {
      minutes += hours * 60;
    }
    if (format2.includes("mm")) {
      format2 = format2.replace("mm", padZero(minutes));
    } else {
      seconds += minutes * 60;
    }
    if (format2.includes("ss")) {
      format2 = format2.replace("ss", padZero(seconds));
    } else {
      milliseconds += seconds * 1e3;
    }
    if (format2.includes("S")) {
      const ms = padZero(milliseconds, 3);
      if (format2.includes("SSS")) {
        format2 = format2.replace("SSS", ms);
      } else if (format2.includes("SS")) {
        format2 = format2.replace("SS", ms.slice(0, 2));
      } else {
        format2 = format2.replace("S", ms.charAt(0));
      }
    }
    return format2;
  }
  const [bem$1i] = createNamespace("count-down");
  const CountDown = React.forwardRef((props, ref) => {
    const { start: start2, pause, reset, current } = useCountDown({
      time: +props.time,
      millisecond: props.millisecond,
      onChange: props.onChange,
      onFinish: props.onFinish
    });
    const timeText = React.useMemo(() => parseFormat(props.format, current), [current]);
    const resetTime = () => {
      reset(+props.time);
      if (props.autoStart) {
        start2();
      }
    };
    React.useEffect(() => {
      resetTime();
      return () => {
        pause();
      };
    }, [props.time]);
    React.useImperativeHandle(ref, () => ({
      start: start2,
      pause,
      reset: resetTime
    }));
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, bem$1i()),
      style: props.style
    }, props.children ? props.children(current) : timeText);
  });
  CountDown.defaultProps = {
    autoStart: true,
    time: 0,
    format: "HH:mm:ss",
    onChange: noop$3,
    onFinish: noop$3
  };
  var index$P = "";
  const [bem$1h] = createNamespace("divider");
  const Divider = (_e) => {
    var _f = _e, {
      children,
      className,
      hairline,
      dashed,
      type: type2,
      contentPosition
    } = _f, props = __objRest(_f, [
      "children",
      "className",
      "hairline",
      "dashed",
      "type",
      "contentPosition"
    ]);
    return /* @__PURE__ */ React__default["default"].createElement("div", __spreadValues({
      role: "separator",
      className: clsx(className, bem$1h({
        dashed,
        hairline,
        "vertical": type2 === "vertical",
        [`content-${contentPosition}`]: !!children
      }))
    }, props), children);
  };
  Divider.defaultProps = {
    hairline: true,
    type: "horizontal",
    contentPosition: "center"
  };
  var index$O = "";
  const [bem$1g] = createNamespace("image");
  const Image$1 = (props) => {
    const [status, setStatus] = useSetState({ loading: true, error: false });
    const imgRef = React.useRef(null);
    const { fit, errorIcon, loadingIcon, showError, showLoading, block } = props;
    const style = React.useMemo(() => {
      const internalStyle = __spreadValues({}, props.style);
      if (isDef(props.width)) {
        internalStyle.width = addUnit$1(props.width);
      }
      if (isDef(props.height)) {
        internalStyle.height = addUnit$1(props.height);
      }
      if (isDef(props.radius)) {
        internalStyle.overflow = "hidden";
        internalStyle.borderRadius = addUnit$1(props.radius);
      }
      return internalStyle;
    }, [props.style]);
    React.useEffect(() => {
      const payload = { error: false, loading: true };
      if (imgRef.current) {
        if (imgRef.current.complete) {
          payload.loading = false;
        } else {
          payload.loading = true;
        }
      }
      setStatus(payload);
    }, [props.src]);
    const onLoad = (e2) => {
      var _a;
      setStatus({ loading: false });
      (_a = props.onLoad) == null ? void 0 : _a.call(props, e2);
    };
    const onError = (e2) => {
      var _a;
      setStatus({ error: true, loading: false });
      (_a = props.onLoad) == null ? void 0 : _a.call(props, e2);
    };
    const renderLoadingIcon = () => {
      if (loadingIcon)
        return React__default["default"].cloneElement(loadingIcon, {
          className: clsx(bem$1g("loading-icon")),
          fontSize: props.iconSize
        });
      return null;
    };
    const renderErrorIcon = () => {
      if (errorIcon) {
        return React__default["default"].cloneElement(errorIcon, {
          className: clsx(bem$1g("error-icon")),
          fontSize: props.iconSize
        });
      }
      return null;
    };
    const renderPlaceholder = () => {
      if (status.loading && showLoading) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$1g("loading")),
          onClick: props.onClick
        }, renderLoadingIcon());
      }
      if (status.error && showError) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$1g("error")),
          onClick: props.onClick
        }, renderErrorIcon());
      }
      return null;
    };
    const renderImage = () => {
      if (status.error || !props.src) {
        return null;
      }
      const attrs = {
        className: clsx(bem$1g("img")),
        style: {
          objectFit: fit
        }
      };
      return /* @__PURE__ */ React__default["default"].createElement("img", __spreadValues({
        ref: imgRef,
        alt: props.alt || "img",
        src: props.src,
        onLoad,
        onError
      }, attrs));
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, bem$1g({
        block,
        round: props.round
      })),
      style,
      onClick: props.onClick
    }, renderImage(), renderPlaceholder(), props.children);
  };
  var index$N = "";
  var index$M = "";
  const DEFAULT_ROW_WIDTH = "100%";
  const DEFAULT_LAST_ROW_WIDTH = "60%";
  const [bem$1f] = createNamespace("skeleton");
  const Skeleton = (_g) => {
    var _h = _g, {
      children,
      className,
      style
    } = _h, props = __objRest(_h, [
      "children",
      "className",
      "style"
    ]);
    const getRowWidth = (index2) => {
      const { rowWidth } = props;
      if (rowWidth === DEFAULT_ROW_WIDTH && index2 === +props.row - 1 && index2 !== 0) {
        return DEFAULT_LAST_ROW_WIDTH;
      }
      if (Array.isArray(rowWidth)) {
        return rowWidth[index2];
      }
      return rowWidth;
    };
    const getRowHeight = (index2) => {
      const { rowHeight } = props;
      if (Array.isArray(rowHeight)) {
        return rowHeight[index2];
      }
      return rowHeight;
    };
    const renderAvatar = () => {
      if (props.avatar) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$1f("avatar", props.avatarShape)),
          style: getSizeStyle(props.avatarSize)
        });
      }
      return null;
    };
    const renderTitle = () => {
      if (props.title) {
        const width = addUnit$1(props.titleWidth);
        const height = addUnit$1(getRowHeight(0));
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$1f("title")),
          style: { width, height }
        });
      }
      return null;
    };
    const renderRows = () => Array(props.row).fill("").map((_, i) => {
      const width = addUnit$1(getRowWidth(i));
      const height = addUnit$1(getRowHeight(i));
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        key: i,
        className: clsx(bem$1f("row")),
        style: { width, height }
      });
    });
    if (!props.loading)
      return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, children);
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(className, bem$1f({ animate: props.animate, round: props.round })),
      style
    }, renderAvatar(), /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$1f("content"))
    }, renderTitle(), renderRows()));
  };
  Skeleton.defaultProps = {
    loading: true,
    animate: true,
    round: true,
    row: 3,
    avatarShape: "round",
    rowWidth: DEFAULT_ROW_WIDTH
  };
  const [bem$1e] = createNamespace("lazyload");
  const Lazyload = (props) => {
    const ref = React.useRef();
    const [inViewPort] = useInViewport(ref);
    const { height, placeholder, children, className, style } = props;
    return inViewPort ? /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, children) : /* @__PURE__ */ React__default["default"].createElement("div", {
      ref,
      className: clsx(bem$1e(), className),
      style: __spreadValues({ height }, style)
    }, placeholder);
  };
  Lazyload.defaultProps = {
    placeholder: /* @__PURE__ */ React__default["default"].createElement(Skeleton, {
      title: true
    })
  };
  const getLazyImagePlaceholder = (bem2) => /* @__PURE__ */ React__default["default"].createElement("div", {
    className: clsx(bem2("loading"))
  }, /* @__PURE__ */ React__default["default"].createElement(SvgPhoto, {
    className: clsx(bem2("loading-icon"))
  }));
  const [bem$1d] = createNamespace("image");
  const LazyImage = (props) => {
    const _a = props, { lazyload } = _a, imageProps = __objRest(_a, ["lazyload"]);
    const renderPlaceholder = () => {
      if (typeof lazyload === "boolean")
        return getLazyImagePlaceholder(bem$1d);
      return lazyload.placeholder || getLazyImagePlaceholder(bem$1d);
    };
    if (lazyload) {
      const { className, style, height, width } = imageProps;
      const attrs = {
        className: clsx(className, bem$1d({ block: imageProps.block })),
        style: __spreadProps(__spreadValues({}, style), { height, width })
      };
      return /* @__PURE__ */ React__default["default"].createElement(Lazyload, __spreadProps(__spreadValues({}, attrs), {
        placeholder: renderPlaceholder()
      }), /* @__PURE__ */ React__default["default"].createElement(Image$1, __spreadValues({}, imageProps)));
    }
    return /* @__PURE__ */ React__default["default"].createElement(Image$1, __spreadValues({}, imageProps));
  };
  LazyImage.defaultProps = {
    fit: "fill",
    errorIcon: /* @__PURE__ */ React__default["default"].createElement(SvgPhotoFail, null),
    loadingIcon: /* @__PURE__ */ React__default["default"].createElement(SvgPhoto, null),
    showError: true,
    showLoading: true,
    block: true
  };
  const IMAGE_KEY = Symbol("image");
  const ImageNamespace = Object.assign(LazyImage, {
    [COMPONENT_TYPE_KEY]: IMAGE_KEY
  });
  var index$L = "";
  function clamp(v2, min, max) {
    return Math.max(min, Math.min(v2, max));
  }
  const V = {
    toVector(v2, fallback) {
      if (v2 === void 0)
        v2 = fallback;
      return Array.isArray(v2) ? v2 : [v2, v2];
    },
    add(v1, v2) {
      return [v1[0] + v2[0], v1[1] + v2[1]];
    },
    sub(v1, v2) {
      return [v1[0] - v2[0], v1[1] - v2[1]];
    },
    addTo(v1, v2) {
      v1[0] += v2[0];
      v1[1] += v2[1];
    },
    subTo(v1, v2) {
      v1[0] -= v2[0];
      v1[1] -= v2[1];
    }
  };
  function rubberband$1(distance, dimension, constant) {
    if (dimension === 0 || Math.abs(dimension) === Infinity)
      return Math.pow(distance, constant * 5);
    return distance * dimension * constant / (dimension + constant * distance);
  }
  function rubberbandIfOutOfBounds$1(position, min, max, constant = 0.15) {
    if (constant === 0)
      return clamp(position, min, max);
    if (position < min)
      return -rubberband$1(min - position, max - min, constant) + min;
    if (position > max)
      return +rubberband$1(position - max, max - min, constant) + max;
    return position;
  }
  function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
    const [[X0, X1], [Y0, Y1]] = bounds;
    return [rubberbandIfOutOfBounds$1(Vx, X0, X1, Rx), rubberbandIfOutOfBounds$1(Vy, Y0, Y1, Ry)];
  }
  function _defineProperty$1(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function ownKeys$1(object2, enumerableOnly) {
    var keys = Object.keys(object2);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object2);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2$1(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  const EVENT_TYPE_MAP = {
    pointer: {
      start: "down",
      change: "move",
      end: "up"
    },
    mouse: {
      start: "down",
      change: "move",
      end: "up"
    },
    touch: {
      start: "start",
      change: "move",
      end: "end"
    },
    gesture: {
      start: "start",
      change: "change",
      end: "end"
    }
  };
  function capitalize(string2) {
    if (!string2)
      return "";
    return string2[0].toUpperCase() + string2.slice(1);
  }
  const actionsWithoutCaptureSupported = ["enter", "leave"];
  function hasCapture(capture = false, actionKey) {
    return capture && !actionsWithoutCaptureSupported.includes(actionKey);
  }
  function toHandlerProp(device, action = "", capture = false) {
    const deviceProps = EVENT_TYPE_MAP[device];
    const actionKey = deviceProps ? deviceProps[action] || action : action;
    return "on" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? "Capture" : "");
  }
  const pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
  function parseProp(prop) {
    let eventKey = prop.substring(2).toLowerCase();
    const passive2 = !!~eventKey.indexOf("passive");
    if (passive2)
      eventKey = eventKey.replace("passive", "");
    const captureKey = pointerCaptureEvents.includes(eventKey) ? "capturecapture" : "capture";
    const capture = !!~eventKey.indexOf(captureKey);
    if (capture)
      eventKey = eventKey.replace("capture", "");
    return {
      device: eventKey,
      capture,
      passive: passive2
    };
  }
  function toDomEventType(device, action = "") {
    const deviceProps = EVENT_TYPE_MAP[device];
    const actionKey = deviceProps ? deviceProps[action] || action : action;
    return device + actionKey;
  }
  function isTouch(event) {
    return "touches" in event;
  }
  function getPointerType(event) {
    if (isTouch(event))
      return "touch";
    if ("pointerType" in event)
      return event.pointerType;
    return "mouse";
  }
  function getCurrentTargetTouchList(event) {
    return Array.from(event.touches).filter((e2) => {
      var _event$currentTarget, _event$currentTarget$;
      return e2.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e2.target));
    });
  }
  function getTouchList(event) {
    return event.type === "touchend" || event.type === "touchcancel" ? event.changedTouches : event.targetTouches;
  }
  function getValueEvent(event) {
    return isTouch(event) ? getTouchList(event)[0] : event;
  }
  function distanceAngle(P1, P2) {
    const dx = P2.clientX - P1.clientX;
    const dy = P2.clientY - P1.clientY;
    const cx = (P2.clientX + P1.clientX) / 2;
    const cy = (P2.clientY + P1.clientY) / 2;
    const distance = Math.hypot(dx, dy);
    const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;
    const origin = [cx, cy];
    return {
      angle,
      distance,
      origin
    };
  }
  function touchIds(event) {
    return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
  }
  function touchDistanceAngle(event, ids) {
    const [P1, P2] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));
    return distanceAngle(P1, P2);
  }
  function pointerId(event) {
    const valueEvent = getValueEvent(event);
    return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;
  }
  function pointerValues(event) {
    const valueEvent = getValueEvent(event);
    return [valueEvent.clientX, valueEvent.clientY];
  }
  const LINE_HEIGHT = 40;
  const PAGE_HEIGHT = 800;
  function wheelValues(event) {
    let {
      deltaX,
      deltaY,
      deltaMode
    } = event;
    if (deltaMode === 1) {
      deltaX *= LINE_HEIGHT;
      deltaY *= LINE_HEIGHT;
    } else if (deltaMode === 2) {
      deltaX *= PAGE_HEIGHT;
      deltaY *= PAGE_HEIGHT;
    }
    return [deltaX, deltaY];
  }
  function getEventDetails(event) {
    const payload = {};
    if ("buttons" in event)
      payload.buttons = event.buttons;
    if ("shiftKey" in event) {
      const {
        shiftKey,
        altKey,
        metaKey,
        ctrlKey
      } = event;
      Object.assign(payload, {
        shiftKey,
        altKey,
        metaKey,
        ctrlKey
      });
    }
    return payload;
  }
  function call$2(v2, ...args) {
    if (typeof v2 === "function") {
      return v2(...args);
    } else {
      return v2;
    }
  }
  function noop$1() {
  }
  function chain(...fns) {
    if (fns.length === 0)
      return noop$1;
    if (fns.length === 1)
      return fns[0];
    return function() {
      let result;
      for (const fn of fns) {
        result = fn.apply(this, arguments) || result;
      }
      return result;
    };
  }
  function assignDefault(value, fallback) {
    return Object.assign({}, fallback, value || {});
  }
  const BEFORE_LAST_KINEMATICS_DELAY = 32;
  class Engine {
    constructor(ctrl, args, key) {
      this.ctrl = ctrl;
      this.args = args;
      this.key = key;
      if (!this.state) {
        this.state = {};
        this.computeValues([0, 0]);
        this.computeInitial();
        if (this.init)
          this.init();
        this.reset();
      }
    }
    get state() {
      return this.ctrl.state[this.key];
    }
    set state(state) {
      this.ctrl.state[this.key] = state;
    }
    get shared() {
      return this.ctrl.state.shared;
    }
    get eventStore() {
      return this.ctrl.gestureEventStores[this.key];
    }
    get timeoutStore() {
      return this.ctrl.gestureTimeoutStores[this.key];
    }
    get config() {
      return this.ctrl.config[this.key];
    }
    get sharedConfig() {
      return this.ctrl.config.shared;
    }
    get handler() {
      return this.ctrl.handlers[this.key];
    }
    reset() {
      const {
        state,
        shared,
        ingKey,
        args
      } = this;
      shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
      state._step = [false, false];
      state.intentional = false;
      state._movement = [0, 0];
      state._distance = [0, 0];
      state._direction = [0, 0];
      state._delta = [0, 0];
      state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
      state.args = args;
      state.axis = void 0;
      state.memo = void 0;
      state.elapsedTime = 0;
      state.direction = [0, 0];
      state.distance = [0, 0];
      state.overflow = [0, 0];
      state._movementBound = [false, false];
      state.velocity = [0, 0];
      state.movement = [0, 0];
      state.delta = [0, 0];
      state.timeStamp = 0;
    }
    start(event) {
      const state = this.state;
      const config2 = this.config;
      if (!state._active) {
        this.reset();
        this.computeInitial();
        state._active = true;
        state.target = event.target;
        state.currentTarget = event.currentTarget;
        state.lastOffset = config2.from ? call$2(config2.from, state) : state.offset;
        state.offset = state.lastOffset;
      }
      state.startTime = state.timeStamp = event.timeStamp;
    }
    computeValues(values) {
      const state = this.state;
      state._values = values;
      state.values = this.config.transform(values);
    }
    computeInitial() {
      const state = this.state;
      state._initial = state._values;
      state.initial = state.values;
    }
    compute(event) {
      const {
        state,
        config: config2,
        shared
      } = this;
      state.args = this.args;
      let dt = 0;
      if (event) {
        state.event = event;
        if (config2.preventDefault && event.cancelable)
          state.event.preventDefault();
        state.type = event.type;
        shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
        shared.locked = !!document.pointerLockElement;
        Object.assign(shared, getEventDetails(event));
        shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
        dt = event.timeStamp - state.timeStamp;
        state.timeStamp = event.timeStamp;
        state.elapsedTime = state.timeStamp - state.startTime;
      }
      if (state._active) {
        const _absoluteDelta = state._delta.map(Math.abs);
        V.addTo(state._distance, _absoluteDelta);
      }
      if (this.axisIntent)
        this.axisIntent(event);
      const [_m0, _m1] = state._movement;
      const [t0, t1] = config2.threshold;
      const {
        _step,
        values
      } = state;
      if (config2.hasCustomTransform) {
        if (_step[0] === false)
          _step[0] = Math.abs(_m0) >= t0 && values[0];
        if (_step[1] === false)
          _step[1] = Math.abs(_m1) >= t1 && values[1];
      } else {
        if (_step[0] === false)
          _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
        if (_step[1] === false)
          _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
      }
      state.intentional = _step[0] !== false || _step[1] !== false;
      if (!state.intentional)
        return;
      const movement = [0, 0];
      if (config2.hasCustomTransform) {
        const [v0, v1] = values;
        movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
        movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
      } else {
        movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
        movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
      }
      if (this.restrictToAxis && !state._blocked)
        this.restrictToAxis(movement);
      const previousOffset = state.offset;
      const gestureIsActive = state._active && !state._blocked || state.active;
      if (gestureIsActive) {
        state.first = state._active && !state.active;
        state.last = !state._active && state.active;
        state.active = shared[this.ingKey] = state._active;
        if (event) {
          if (state.first) {
            if ("bounds" in config2)
              state._bounds = call$2(config2.bounds, state);
            if (this.setup)
              this.setup();
          }
          state.movement = movement;
          this.computeOffset();
        }
      }
      const [ox, oy] = state.offset;
      const [[x0, x1], [y0, y1]] = state._bounds;
      state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
      state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
      state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
      const rubberband2 = state._active ? config2.rubberband || [0, 0] : [0, 0];
      state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
      state.delta = V.sub(state.offset, previousOffset);
      this.computeMovement();
      if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {
        state.delta = V.sub(state.offset, previousOffset);
        const absoluteDelta = state.delta.map(Math.abs);
        V.addTo(state.distance, absoluteDelta);
        state.direction = state.delta.map(Math.sign);
        state._direction = state._delta.map(Math.sign);
        if (!state.first && dt > 0) {
          state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
        }
      }
    }
    emit() {
      const state = this.state;
      const shared = this.shared;
      const config2 = this.config;
      if (!state._active)
        this.clean();
      if ((state._blocked || !state.intentional) && !state._force && !config2.triggerAllEvents)
        return;
      const memo = this.handler(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({}, shared), state), {}, {
        [this.aliasKey]: state.values
      }));
      if (memo !== void 0)
        state.memo = memo;
    }
    clean() {
      this.eventStore.clean();
      this.timeoutStore.clean();
    }
  }
  function selectAxis([dx, dy], threshold) {
    const absDx = Math.abs(dx);
    const absDy = Math.abs(dy);
    if (absDx > absDy && absDx > threshold) {
      return "x";
    }
    if (absDy > absDx && absDy > threshold) {
      return "y";
    }
    return void 0;
  }
  class CoordinatesEngine extends Engine {
    constructor(...args) {
      super(...args);
      _defineProperty$1(this, "aliasKey", "xy");
    }
    reset() {
      super.reset();
      this.state.axis = void 0;
    }
    init() {
      this.state.offset = [0, 0];
      this.state.lastOffset = [0, 0];
    }
    computeOffset() {
      this.state.offset = V.add(this.state.lastOffset, this.state.movement);
    }
    computeMovement() {
      this.state.movement = V.sub(this.state.offset, this.state.lastOffset);
    }
    axisIntent(event) {
      const state = this.state;
      const config2 = this.config;
      if (!state.axis && event) {
        const threshold = typeof config2.axisThreshold === "object" ? config2.axisThreshold[getPointerType(event)] : config2.axisThreshold;
        state.axis = selectAxis(state._movement, threshold);
      }
      state._blocked = (config2.lockDirection || !!config2.axis) && !state.axis || !!config2.axis && config2.axis !== state.axis;
    }
    restrictToAxis(v2) {
      if (this.config.axis || this.config.lockDirection) {
        switch (this.state.axis) {
          case "x":
            v2[1] = 0;
            break;
          case "y":
            v2[0] = 0;
            break;
        }
      }
    }
  }
  const identity = (v2) => v2;
  const DEFAULT_RUBBERBAND = 0.15;
  const commonConfigResolver = {
    enabled(value = true) {
      return value;
    },
    eventOptions(value, _k, config2) {
      return _objectSpread2$1(_objectSpread2$1({}, config2.shared.eventOptions), value);
    },
    preventDefault(value = false) {
      return value;
    },
    triggerAllEvents(value = false) {
      return value;
    },
    rubberband(value = 0) {
      switch (value) {
        case true:
          return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
        case false:
          return [0, 0];
        default:
          return V.toVector(value);
      }
    },
    from(value) {
      if (typeof value === "function")
        return value;
      if (value != null)
        return V.toVector(value);
    },
    transform(value, _k, config2) {
      const transform = value || config2.shared.transform;
      this.hasCustomTransform = !!transform;
      return transform || identity;
    },
    threshold(value) {
      return V.toVector(value, 0);
    }
  };
  const DEFAULT_AXIS_THRESHOLD = 0;
  const coordinatesConfigResolver = _objectSpread2$1(_objectSpread2$1({}, commonConfigResolver), {}, {
    axis(_v, _k, {
      axis
    }) {
      this.lockDirection = axis === "lock";
      if (!this.lockDirection)
        return axis;
    },
    axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {
      return value;
    },
    bounds(value = {}) {
      if (typeof value === "function") {
        return (state) => coordinatesConfigResolver.bounds(value(state));
      }
      if ("current" in value) {
        return () => value.current;
      }
      if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
        return value;
      }
      const {
        left: left2 = -Infinity,
        right: right2 = Infinity,
        top: top2 = -Infinity,
        bottom: bottom2 = Infinity
      } = value;
      return [[left2, right2], [top2, bottom2]];
    }
  });
  const DISPLACEMENT = 10;
  const KEYS_DELTA_MAP = {
    ArrowRight: (factor = 1) => [DISPLACEMENT * factor, 0],
    ArrowLeft: (factor = 1) => [-DISPLACEMENT * factor, 0],
    ArrowUp: (factor = 1) => [0, -DISPLACEMENT * factor],
    ArrowDown: (factor = 1) => [0, DISPLACEMENT * factor]
  };
  class DragEngine extends CoordinatesEngine {
    constructor(...args) {
      super(...args);
      _defineProperty$1(this, "ingKey", "dragging");
    }
    reset() {
      super.reset();
      const state = this.state;
      state._pointerId = void 0;
      state._pointerActive = false;
      state._keyboardActive = false;
      state._preventScroll = false;
      state._delayed = false;
      state.swipe = [0, 0];
      state.tap = false;
      state.canceled = false;
      state.cancel = this.cancel.bind(this);
    }
    setup() {
      const state = this.state;
      if (state._bounds instanceof HTMLElement) {
        const boundRect = state._bounds.getBoundingClientRect();
        const targetRect = state.currentTarget.getBoundingClientRect();
        const _bounds = {
          left: boundRect.left - targetRect.left + state.offset[0],
          right: boundRect.right - targetRect.right + state.offset[0],
          top: boundRect.top - targetRect.top + state.offset[1],
          bottom: boundRect.bottom - targetRect.bottom + state.offset[1]
        };
        state._bounds = coordinatesConfigResolver.bounds(_bounds);
      }
    }
    cancel() {
      const state = this.state;
      if (state.canceled)
        return;
      state.canceled = true;
      state._active = false;
      setTimeout(() => {
        this.compute();
        this.emit();
      }, 0);
    }
    setActive() {
      this.state._active = this.state._pointerActive || this.state._keyboardActive;
    }
    clean() {
      this.pointerClean();
      this.state._pointerActive = false;
      this.state._keyboardActive = false;
      super.clean();
    }
    pointerDown(event) {
      const config2 = this.config;
      const state = this.state;
      if (event.buttons != null && (Array.isArray(config2.pointerButtons) ? !config2.pointerButtons.includes(event.buttons) : config2.pointerButtons !== -1 && config2.pointerButtons !== event.buttons))
        return;
      const ctrlIds = this.ctrl.setEventIds(event);
      if (config2.pointerCapture) {
        event.target.setPointerCapture(event.pointerId);
      }
      if (ctrlIds && ctrlIds.size > 1 && state._pointerActive)
        return;
      this.start(event);
      this.setupPointer(event);
      state._pointerId = pointerId(event);
      state._pointerActive = true;
      this.computeValues(pointerValues(event));
      this.computeInitial();
      if (config2.preventScrollAxis && getPointerType(event) !== "mouse") {
        state._active = false;
        this.setupScrollPrevention(event);
      } else if (config2.delay > 0) {
        this.setupDelayTrigger(event);
        if (config2.triggerAllEvents) {
          this.compute(event);
          this.emit();
        }
      } else {
        this.startPointerDrag(event);
      }
    }
    startPointerDrag(event) {
      const state = this.state;
      state._active = true;
      state._preventScroll = true;
      state._delayed = false;
      this.compute(event);
      this.emit();
    }
    pointerMove(event) {
      const state = this.state;
      const config2 = this.config;
      if (!state._pointerActive)
        return;
      if (state.type === event.type && event.timeStamp === state.timeStamp)
        return;
      const id = pointerId(event);
      if (state._pointerId !== void 0 && id !== state._pointerId)
        return;
      const _values = pointerValues(event);
      if (document.pointerLockElement === event.target) {
        state._delta = [event.movementX, event.movementY];
      } else {
        state._delta = V.sub(_values, state._values);
        this.computeValues(_values);
      }
      V.addTo(state._movement, state._delta);
      this.compute(event);
      if (state._delayed && state.intentional) {
        this.timeoutStore.remove("dragDelay");
        state.active = false;
        this.startPointerDrag(event);
        return;
      }
      if (config2.preventScrollAxis && !state._preventScroll) {
        if (state.axis) {
          if (state.axis === config2.preventScrollAxis || config2.preventScrollAxis === "xy") {
            state._active = false;
            this.clean();
            return;
          } else {
            this.timeoutStore.remove("startPointerDrag");
            this.startPointerDrag(event);
            return;
          }
        } else {
          return;
        }
      }
      this.emit();
    }
    pointerUp(event) {
      this.ctrl.setEventIds(event);
      try {
        if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {
          ;
          event.target.releasePointerCapture(event.pointerId);
        }
      } catch (_unused) {
      }
      const state = this.state;
      const config2 = this.config;
      if (!state._active || !state._pointerActive)
        return;
      const id = pointerId(event);
      if (state._pointerId !== void 0 && id !== state._pointerId)
        return;
      this.state._pointerActive = false;
      this.setActive();
      this.compute(event);
      const [dx, dy] = state._distance;
      state.tap = dx <= config2.tapsThreshold && dy <= config2.tapsThreshold;
      if (state.tap && config2.filterTaps) {
        state._force = true;
      } else {
        const [dirx, diry] = state.direction;
        const [vx, vy] = state.velocity;
        const [mx, my] = state.movement;
        const [svx, svy] = config2.swipe.velocity;
        const [sx, sy] = config2.swipe.distance;
        const sdt = config2.swipe.duration;
        if (state.elapsedTime < sdt) {
          if (Math.abs(vx) > svx && Math.abs(mx) > sx)
            state.swipe[0] = dirx;
          if (Math.abs(vy) > svy && Math.abs(my) > sy)
            state.swipe[1] = diry;
        }
      }
      this.emit();
    }
    pointerClick(event) {
      if (!this.state.tap) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
    setupPointer(event) {
      const config2 = this.config;
      const device = config2.device;
      if (config2.pointerLock) {
        event.currentTarget.requestPointerLock();
      }
      if (!config2.pointerCapture) {
        this.eventStore.add(this.sharedConfig.window, device, "change", this.pointerMove.bind(this));
        this.eventStore.add(this.sharedConfig.window, device, "end", this.pointerUp.bind(this));
        this.eventStore.add(this.sharedConfig.window, device, "cancel", this.pointerUp.bind(this));
      }
    }
    pointerClean() {
      if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {
        document.exitPointerLock();
      }
    }
    preventScroll(event) {
      if (this.state._preventScroll && event.cancelable) {
        event.preventDefault();
      }
    }
    setupScrollPrevention(event) {
      this.state._preventScroll = false;
      persistEvent(event);
      const remove = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
        passive: false
      });
      this.eventStore.add(this.sharedConfig.window, "touch", "end", remove);
      this.eventStore.add(this.sharedConfig.window, "touch", "cancel", remove);
      this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);
    }
    setupDelayTrigger(event) {
      this.state._delayed = true;
      this.timeoutStore.add("dragDelay", () => {
        this.state._step = [0, 0];
        this.startPointerDrag(event);
      }, this.config.delay);
    }
    keyDown(event) {
      const deltaFn = KEYS_DELTA_MAP[event.key];
      if (deltaFn) {
        const state = this.state;
        const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;
        this.start(event);
        state._delta = deltaFn(factor);
        state._keyboardActive = true;
        V.addTo(state._movement, state._delta);
        this.compute(event);
        this.emit();
      }
    }
    keyUp(event) {
      if (!(event.key in KEYS_DELTA_MAP))
        return;
      this.state._keyboardActive = false;
      this.setActive();
      this.compute(event);
      this.emit();
    }
    bind(bindFunction) {
      const device = this.config.device;
      bindFunction(device, "start", this.pointerDown.bind(this));
      if (this.config.pointerCapture) {
        bindFunction(device, "change", this.pointerMove.bind(this));
        bindFunction(device, "end", this.pointerUp.bind(this));
        bindFunction(device, "cancel", this.pointerUp.bind(this));
        bindFunction("lostPointerCapture", "", this.pointerUp.bind(this));
      }
      if (this.config.keys) {
        bindFunction("key", "down", this.keyDown.bind(this));
        bindFunction("key", "up", this.keyUp.bind(this));
      }
      if (this.config.filterTaps) {
        bindFunction("click", "", this.pointerClick.bind(this), {
          capture: true,
          passive: false
        });
      }
    }
  }
  function persistEvent(event) {
    "persist" in event && typeof event.persist === "function" && event.persist();
  }
  const isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
  function supportsTouchEvents() {
    return isBrowser && "ontouchstart" in window;
  }
  function isTouchScreen() {
    return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
  }
  function supportsPointerEvents() {
    return isBrowser && "onpointerdown" in window;
  }
  function supportsPointerLock() {
    return isBrowser && "exitPointerLock" in window.document;
  }
  function supportsGestureEvents() {
    try {
      return "constructor" in GestureEvent;
    } catch (e2) {
      return false;
    }
  }
  const SUPPORT = {
    isBrowser,
    gesture: supportsGestureEvents(),
    touch: isTouchScreen(),
    touchscreen: isTouchScreen(),
    pointer: supportsPointerEvents(),
    pointerLock: supportsPointerLock()
  };
  const DEFAULT_PREVENT_SCROLL_DELAY = 250;
  const DEFAULT_DRAG_DELAY = 180;
  const DEFAULT_SWIPE_VELOCITY = 0.5;
  const DEFAULT_SWIPE_DISTANCE = 50;
  const DEFAULT_SWIPE_DURATION = 250;
  const DEFAULT_DRAG_AXIS_THRESHOLD = {
    mouse: 0,
    touch: 0,
    pen: 8
  };
  const dragConfigResolver = _objectSpread2$1(_objectSpread2$1({}, coordinatesConfigResolver), {}, {
    device(_v, _k, {
      pointer: {
        touch = false,
        lock = false,
        mouse = false
      } = {}
    }) {
      this.pointerLock = lock && SUPPORT.pointerLock;
      if (SUPPORT.touch && touch)
        return "touch";
      if (this.pointerLock)
        return "mouse";
      if (SUPPORT.pointer && !mouse)
        return "pointer";
      if (SUPPORT.touch)
        return "touch";
      return "mouse";
    },
    preventScrollAxis(value, _k, {
      preventScroll
    }) {
      this.preventScrollDelay = typeof preventScroll === "number" ? preventScroll : preventScroll || preventScroll === void 0 && value ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;
      if (!SUPPORT.touchscreen || preventScroll === false)
        return void 0;
      return value ? value : preventScroll !== void 0 ? "y" : void 0;
    },
    pointerCapture(_v, _k, {
      pointer: {
        capture = true,
        buttons = 1
      } = {}
    }) {
      this.pointerButtons = buttons;
      return !this.pointerLock && this.device === "pointer" && capture;
    },
    keys(value = true) {
      return value;
    },
    threshold(value, _k, {
      filterTaps = false,
      tapsThreshold = 3,
      axis = void 0
    }) {
      const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
      this.filterTaps = filterTaps;
      this.tapsThreshold = tapsThreshold;
      return threshold;
    },
    swipe({
      velocity = DEFAULT_SWIPE_VELOCITY,
      distance = DEFAULT_SWIPE_DISTANCE,
      duration = DEFAULT_SWIPE_DURATION
    } = {}) {
      return {
        velocity: this.transform(V.toVector(velocity)),
        distance: this.transform(V.toVector(distance)),
        duration
      };
    },
    delay(value = 0) {
      switch (value) {
        case true:
          return DEFAULT_DRAG_DELAY;
        case false:
          return 0;
        default:
          return value;
      }
    },
    axisThreshold(value) {
      if (!value)
        return DEFAULT_DRAG_AXIS_THRESHOLD;
      return _objectSpread2$1(_objectSpread2$1({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);
    }
  });
  const SCALE_ANGLE_RATIO_INTENT_DEG = 30;
  const PINCH_WHEEL_RATIO = 100;
  class PinchEngine extends Engine {
    constructor(...args) {
      super(...args);
      _defineProperty$1(this, "ingKey", "pinching");
      _defineProperty$1(this, "aliasKey", "da");
    }
    init() {
      this.state.offset = [1, 0];
      this.state.lastOffset = [1, 0];
      this.state._pointerEvents = /* @__PURE__ */ new Map();
    }
    reset() {
      super.reset();
      const state = this.state;
      state._touchIds = [];
      state.canceled = false;
      state.cancel = this.cancel.bind(this);
      state.turns = 0;
    }
    computeOffset() {
      const {
        type: type2,
        movement,
        lastOffset
      } = this.state;
      if (type2 === "wheel") {
        this.state.offset = V.add(movement, lastOffset);
      } else {
        this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];
      }
    }
    computeMovement() {
      const {
        offset: offset2,
        lastOffset
      } = this.state;
      this.state.movement = [offset2[0] / lastOffset[0], offset2[1] - lastOffset[1]];
    }
    axisIntent() {
      const state = this.state;
      const [_m0, _m1] = state._movement;
      if (!state.axis) {
        const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);
        if (axisMovementDifference < 0)
          state.axis = "angle";
        else if (axisMovementDifference > 0)
          state.axis = "scale";
      }
    }
    restrictToAxis(v2) {
      if (this.config.lockDirection) {
        if (this.state.axis === "scale")
          v2[1] = 0;
        else if (this.state.axis === "angle")
          v2[0] = 0;
      }
    }
    cancel() {
      const state = this.state;
      if (state.canceled)
        return;
      setTimeout(() => {
        state.canceled = true;
        state._active = false;
        this.compute();
        this.emit();
      }, 0);
    }
    touchStart(event) {
      this.ctrl.setEventIds(event);
      const state = this.state;
      const ctrlTouchIds = this.ctrl.touchIds;
      if (state._active) {
        if (state._touchIds.every((id) => ctrlTouchIds.has(id)))
          return;
      }
      if (ctrlTouchIds.size < 2)
        return;
      this.start(event);
      state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);
      const payload = touchDistanceAngle(event, state._touchIds);
      this.pinchStart(event, payload);
    }
    pointerStart(event) {
      if (event.buttons != null && event.buttons % 2 !== 1)
        return;
      this.ctrl.setEventIds(event);
      event.target.setPointerCapture(event.pointerId);
      const state = this.state;
      const _pointerEvents = state._pointerEvents;
      const ctrlPointerIds = this.ctrl.pointerIds;
      if (state._active) {
        if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id)))
          return;
      }
      if (_pointerEvents.size < 2) {
        _pointerEvents.set(event.pointerId, event);
      }
      if (state._pointerEvents.size < 2)
        return;
      this.start(event);
      const payload = distanceAngle(...Array.from(_pointerEvents.values()));
      this.pinchStart(event, payload);
    }
    pinchStart(event, payload) {
      const state = this.state;
      state.origin = payload.origin;
      this.computeValues([payload.distance, payload.angle]);
      this.computeInitial();
      this.compute(event);
      this.emit();
    }
    touchMove(event) {
      if (!this.state._active)
        return;
      const payload = touchDistanceAngle(event, this.state._touchIds);
      this.pinchMove(event, payload);
    }
    pointerMove(event) {
      const _pointerEvents = this.state._pointerEvents;
      if (_pointerEvents.has(event.pointerId)) {
        _pointerEvents.set(event.pointerId, event);
      }
      if (!this.state._active)
        return;
      const payload = distanceAngle(...Array.from(_pointerEvents.values()));
      this.pinchMove(event, payload);
    }
    pinchMove(event, payload) {
      const state = this.state;
      const prev_a = state._values[1];
      const delta_a = payload.angle - prev_a;
      let delta_turns = 0;
      if (Math.abs(delta_a) > 270)
        delta_turns += Math.sign(delta_a);
      this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);
      state.origin = payload.origin;
      state.turns = delta_turns;
      state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];
      this.compute(event);
      this.emit();
    }
    touchEnd(event) {
      this.ctrl.setEventIds(event);
      if (!this.state._active)
        return;
      if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {
        this.state._active = false;
        this.compute(event);
        this.emit();
      }
    }
    pointerEnd(event) {
      const state = this.state;
      this.ctrl.setEventIds(event);
      try {
        event.target.releasePointerCapture(event.pointerId);
      } catch (_unused) {
      }
      if (state._pointerEvents.has(event.pointerId)) {
        state._pointerEvents.delete(event.pointerId);
      }
      if (!state._active)
        return;
      if (state._pointerEvents.size < 2) {
        state._active = false;
        this.compute(event);
        this.emit();
      }
    }
    gestureStart(event) {
      if (event.cancelable)
        event.preventDefault();
      const state = this.state;
      if (state._active)
        return;
      this.start(event);
      this.computeValues([event.scale, event.rotation]);
      state.origin = [event.clientX, event.clientY];
      this.compute(event);
      this.emit();
    }
    gestureMove(event) {
      if (event.cancelable)
        event.preventDefault();
      if (!this.state._active)
        return;
      const state = this.state;
      this.computeValues([event.scale, event.rotation]);
      state.origin = [event.clientX, event.clientY];
      const _previousMovement = state._movement;
      state._movement = [event.scale - 1, event.rotation];
      state._delta = V.sub(state._movement, _previousMovement);
      this.compute(event);
      this.emit();
    }
    gestureEnd(event) {
      if (!this.state._active)
        return;
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
    wheel(event) {
      const modifierKey = this.config.modifierKey;
      if (modifierKey && !event[modifierKey])
        return;
      if (!this.state._active)
        this.wheelStart(event);
      else
        this.wheelChange(event);
      this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
    }
    wheelStart(event) {
      this.start(event);
      this.wheelChange(event);
    }
    wheelChange(event) {
      const isR3f = "uv" in event;
      if (!isR3f) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
      const state = this.state;
      state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];
      V.addTo(state._movement, state._delta);
      this.state.origin = [event.clientX, event.clientY];
      this.compute(event);
      this.emit();
    }
    wheelEnd() {
      if (!this.state._active)
        return;
      this.state._active = false;
      this.compute();
      this.emit();
    }
    bind(bindFunction) {
      const device = this.config.device;
      if (!!device) {
        bindFunction(device, "start", this[device + "Start"].bind(this));
        bindFunction(device, "change", this[device + "Move"].bind(this));
        bindFunction(device, "end", this[device + "End"].bind(this));
        bindFunction(device, "cancel", this[device + "End"].bind(this));
      }
      bindFunction("wheel", "", this.wheel.bind(this), {
        passive: false
      });
    }
  }
  const pinchConfigResolver = _objectSpread2$1(_objectSpread2$1({}, commonConfigResolver), {}, {
    device(_v, _k, {
      shared,
      pointer: {
        touch = false
      } = {}
    }) {
      const sharedConfig = shared;
      if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture)
        return "gesture";
      if (SUPPORT.touch && touch)
        return "touch";
      if (SUPPORT.touchscreen) {
        if (SUPPORT.pointer)
          return "pointer";
        if (SUPPORT.touch)
          return "touch";
      }
    },
    bounds(_v, _k, {
      scaleBounds = {},
      angleBounds = {}
    }) {
      const _scaleBounds = (state) => {
        const D = assignDefault(call$2(scaleBounds, state), {
          min: -Infinity,
          max: Infinity
        });
        return [D.min, D.max];
      };
      const _angleBounds = (state) => {
        const A2 = assignDefault(call$2(angleBounds, state), {
          min: -Infinity,
          max: Infinity
        });
        return [A2.min, A2.max];
      };
      if (typeof scaleBounds !== "function" && typeof angleBounds !== "function")
        return [_scaleBounds(), _angleBounds()];
      return (state) => [_scaleBounds(state), _angleBounds(state)];
    },
    threshold(value, _k, config2) {
      this.lockDirection = config2.axis === "lock";
      const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
      return threshold;
    },
    modifierKey(value) {
      if (value === void 0)
        return "ctrlKey";
      return value;
    }
  });
  _objectSpread2$1(_objectSpread2$1({}, coordinatesConfigResolver), {}, {
    mouseOnly: (value = true) => value
  });
  _objectSpread2$1(_objectSpread2$1({}, coordinatesConfigResolver), {}, {
    mouseOnly: (value = true) => value
  });
  const EngineMap = /* @__PURE__ */ new Map();
  const ConfigResolverMap = /* @__PURE__ */ new Map();
  function registerAction(action) {
    EngineMap.set(action.key, action.engine);
    ConfigResolverMap.set(action.key, action.resolver);
  }
  const dragAction = {
    key: "drag",
    engine: DragEngine,
    resolver: dragConfigResolver
  };
  const pinchAction = {
    key: "pinch",
    engine: PinchEngine,
    resolver: pinchConfigResolver
  };
  function _objectWithoutPropertiesLoose$2(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties$1(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose$2(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  const sharedConfigResolver = {
    target(value) {
      if (value) {
        return () => "current" in value ? value.current : value;
      }
      return void 0;
    },
    enabled(value = true) {
      return value;
    },
    window(value = SUPPORT.isBrowser ? window : void 0) {
      return value;
    },
    eventOptions({
      passive: passive2 = true,
      capture = false
    } = {}) {
      return {
        passive: passive2,
        capture
      };
    },
    transform(value) {
      return value;
    }
  };
  const _excluded$4 = ["target", "eventOptions", "window", "enabled", "transform"];
  function resolveWith(config2 = {}, resolvers) {
    const result = {};
    for (const [key, resolver] of Object.entries(resolvers)) {
      switch (typeof resolver) {
        case "function":
          {
            result[key] = resolver.call(result, config2[key], key, config2);
          }
          break;
        case "object":
          result[key] = resolveWith(config2[key], resolver);
          break;
        case "boolean":
          if (resolver)
            result[key] = config2[key];
          break;
      }
    }
    return result;
  }
  function parse(config2, gestureKey) {
    const _ref = config2, {
      target,
      eventOptions,
      window: window2,
      enabled,
      transform
    } = _ref, rest = _objectWithoutProperties$1(_ref, _excluded$4);
    const _config = {
      shared: resolveWith({
        target,
        eventOptions,
        window: window2,
        enabled,
        transform
      }, sharedConfigResolver)
    };
    if (gestureKey) {
      const resolver = ConfigResolverMap.get(gestureKey);
      _config[gestureKey] = resolveWith(_objectSpread2$1({
        shared: _config.shared
      }, rest), resolver);
    } else {
      for (const key in rest) {
        const resolver = ConfigResolverMap.get(key);
        if (resolver) {
          _config[key] = resolveWith(_objectSpread2$1({
            shared: _config.shared
          }, rest[key]), resolver);
        }
      }
    }
    return _config;
  }
  class EventStore {
    constructor(ctrl, gestureKey) {
      _defineProperty$1(this, "_listeners", /* @__PURE__ */ new Set());
      this._ctrl = ctrl;
      this._gestureKey = gestureKey;
    }
    add(element, device, action, handler, options) {
      const listeners = this._listeners;
      const type2 = toDomEventType(device, action);
      const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};
      const eventOptions = _objectSpread2$1(_objectSpread2$1({}, _options), options);
      element.addEventListener(type2, handler, eventOptions);
      const remove = () => {
        element.removeEventListener(type2, handler, eventOptions);
        listeners.delete(remove);
      };
      listeners.add(remove);
      return remove;
    }
    clean() {
      this._listeners.forEach((remove) => remove());
      this._listeners.clear();
    }
  }
  class TimeoutStore {
    constructor() {
      _defineProperty$1(this, "_timeouts", /* @__PURE__ */ new Map());
    }
    add(key, callback, ms = 140, ...args) {
      this.remove(key);
      this._timeouts.set(key, window.setTimeout(callback, ms, ...args));
    }
    remove(key) {
      const timeout = this._timeouts.get(key);
      if (timeout)
        window.clearTimeout(timeout);
    }
    clean() {
      this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));
      this._timeouts.clear();
    }
  }
  class Controller$1 {
    constructor(handlers) {
      _defineProperty$1(this, "gestures", /* @__PURE__ */ new Set());
      _defineProperty$1(this, "_targetEventStore", new EventStore(this));
      _defineProperty$1(this, "gestureEventStores", {});
      _defineProperty$1(this, "gestureTimeoutStores", {});
      _defineProperty$1(this, "handlers", {});
      _defineProperty$1(this, "config", {});
      _defineProperty$1(this, "pointerIds", /* @__PURE__ */ new Set());
      _defineProperty$1(this, "touchIds", /* @__PURE__ */ new Set());
      _defineProperty$1(this, "state", {
        shared: {
          shiftKey: false,
          metaKey: false,
          ctrlKey: false,
          altKey: false
        }
      });
      resolveGestures(this, handlers);
    }
    setEventIds(event) {
      if (isTouch(event)) {
        this.touchIds = new Set(touchIds(event));
        return this.touchIds;
      } else if ("pointerId" in event) {
        if (event.type === "pointerup" || event.type === "pointercancel")
          this.pointerIds.delete(event.pointerId);
        else if (event.type === "pointerdown")
          this.pointerIds.add(event.pointerId);
        return this.pointerIds;
      }
    }
    applyHandlers(handlers, nativeHandlers) {
      this.handlers = handlers;
      this.nativeHandlers = nativeHandlers;
    }
    applyConfig(config2, gestureKey) {
      this.config = parse(config2, gestureKey);
    }
    clean() {
      this._targetEventStore.clean();
      for (const key of this.gestures) {
        this.gestureEventStores[key].clean();
        this.gestureTimeoutStores[key].clean();
      }
    }
    effect() {
      if (this.config.shared.target)
        this.bind();
      return () => this._targetEventStore.clean();
    }
    bind(...args) {
      const sharedConfig = this.config.shared;
      const props = {};
      let target;
      if (sharedConfig.target) {
        target = sharedConfig.target();
        if (!target)
          return;
      }
      if (sharedConfig.enabled) {
        for (const gestureKey of this.gestures) {
          const gestureConfig = this.config[gestureKey];
          const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);
          if (gestureConfig.enabled) {
            const Engine2 = EngineMap.get(gestureKey);
            new Engine2(this, args, gestureKey).bind(bindFunction);
          }
        }
        const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);
        for (const eventKey in this.nativeHandlers) {
          nativeBindFunction(eventKey, "", (event) => this.nativeHandlers[eventKey](_objectSpread2$1(_objectSpread2$1({}, this.state.shared), {}, {
            event,
            args
          })), void 0, true);
        }
      }
      for (const handlerProp in props) {
        props[handlerProp] = chain(...props[handlerProp]);
      }
      if (!target)
        return props;
      for (const handlerProp in props) {
        const {
          device,
          capture,
          passive: passive2
        } = parseProp(handlerProp);
        this._targetEventStore.add(target, device, "", props[handlerProp], {
          capture,
          passive: passive2
        });
      }
    }
  }
  function setupGesture(ctrl, gestureKey) {
    ctrl.gestures.add(gestureKey);
    ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
    ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
  }
  function resolveGestures(ctrl, internalHandlers) {
    if (internalHandlers.drag)
      setupGesture(ctrl, "drag");
    if (internalHandlers.wheel)
      setupGesture(ctrl, "wheel");
    if (internalHandlers.scroll)
      setupGesture(ctrl, "scroll");
    if (internalHandlers.move)
      setupGesture(ctrl, "move");
    if (internalHandlers.pinch)
      setupGesture(ctrl, "pinch");
    if (internalHandlers.hover)
      setupGesture(ctrl, "hover");
  }
  const bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {
    var _options$capture, _options$passive;
    const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
    const passive2 = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
    let handlerProp = isNative ? device : toHandlerProp(device, action, capture);
    if (withPassiveOption && passive2)
      handlerProp += "Passive";
    props[handlerProp] = props[handlerProp] || [];
    props[handlerProp].push(handler);
  };
  const RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
  function sortHandlers(_handlers) {
    const native = {};
    const handlers = {};
    const actions = /* @__PURE__ */ new Set();
    for (let key in _handlers) {
      if (RE_NOT_NATIVE.test(key)) {
        actions.add(RegExp.lastMatch);
        handlers[key] = _handlers[key];
      } else {
        native[key] = _handlers[key];
      }
    }
    return [handlers, native, actions];
  }
  function registerGesture(actions, handlers, handlerKey, key, internalHandlers, config2) {
    if (!actions.has(handlerKey))
      return;
    if (!EngineMap.has(key)) {
      return;
    }
    const startKey = handlerKey + "Start";
    const endKey = handlerKey + "End";
    const fn = (state) => {
      let memo = void 0;
      if (state.first && startKey in handlers)
        handlers[startKey](state);
      if (handlerKey in handlers)
        memo = handlers[handlerKey](state);
      if (state.last && endKey in handlers)
        handlers[endKey](state);
      return memo;
    };
    internalHandlers[key] = fn;
    config2[key] = config2[key] || {};
  }
  function parseMergedHandlers(mergedHandlers, mergedConfig) {
    const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);
    const internalHandlers = {};
    registerGesture(actions, handlers, "onDrag", "drag", internalHandlers, mergedConfig);
    registerGesture(actions, handlers, "onWheel", "wheel", internalHandlers, mergedConfig);
    registerGesture(actions, handlers, "onScroll", "scroll", internalHandlers, mergedConfig);
    registerGesture(actions, handlers, "onPinch", "pinch", internalHandlers, mergedConfig);
    registerGesture(actions, handlers, "onMove", "move", internalHandlers, mergedConfig);
    registerGesture(actions, handlers, "onHover", "hover", internalHandlers, mergedConfig);
    return {
      handlers: internalHandlers,
      config: mergedConfig,
      nativeHandlers
    };
  }
  function useRecognizers(handlers, config2 = {}, gestureKey, nativeHandlers) {
    const ctrl = React__default["default"].useMemo(() => new Controller$1(handlers), []);
    ctrl.applyHandlers(handlers, nativeHandlers);
    ctrl.applyConfig(config2, gestureKey);
    React__default["default"].useEffect(ctrl.effect.bind(ctrl));
    React__default["default"].useEffect(() => {
      return ctrl.clean.bind(ctrl);
    }, []);
    if (config2.target === void 0) {
      return ctrl.bind.bind(ctrl);
    }
    return void 0;
  }
  function useDrag(handler, config2) {
    registerAction(dragAction);
    return useRecognizers({
      drag: handler
    }, config2 || {}, "drag");
  }
  function createUseGesture(actions) {
    actions.forEach(registerAction);
    return function useGesture(_handlers, _config) {
      const {
        handlers,
        nativeHandlers,
        config: config2
      } = parseMergedHandlers(_handlers, _config || {});
      return useRecognizers(handlers, config2, void 0, nativeHandlers);
    };
  }
  let updateQueue = makeQueue();
  const raf = (fn) => schedule(fn, updateQueue);
  let writeQueue = makeQueue();
  raf.write = (fn) => schedule(fn, writeQueue);
  let onStartQueue = makeQueue();
  raf.onStart = (fn) => schedule(fn, onStartQueue);
  let onFrameQueue = makeQueue();
  raf.onFrame = (fn) => schedule(fn, onFrameQueue);
  let onFinishQueue = makeQueue();
  raf.onFinish = (fn) => schedule(fn, onFinishQueue);
  let timeouts = [];
  raf.setTimeout = (handler, ms) => {
    let time = raf.now() + ms;
    let cancel = () => {
      let i = timeouts.findIndex((t2) => t2.cancel == cancel);
      if (~i)
        timeouts.splice(i, 1);
      pendingCount -= ~i ? 1 : 0;
    };
    let timeout = {
      time,
      handler,
      cancel
    };
    timeouts.splice(findTimeout(time), 0, timeout);
    pendingCount += 1;
    start$1();
    return timeout;
  };
  let findTimeout = (time) => ~(~timeouts.findIndex((t2) => t2.time > time) || ~timeouts.length);
  raf.cancel = (fn) => {
    onStartQueue.delete(fn);
    onFrameQueue.delete(fn);
    updateQueue.delete(fn);
    writeQueue.delete(fn);
    onFinishQueue.delete(fn);
  };
  raf.sync = (fn) => {
    sync = true;
    raf.batchedUpdates(fn);
    sync = false;
  };
  raf.throttle = (fn) => {
    let lastArgs;
    function queuedFn() {
      try {
        fn(...lastArgs);
      } finally {
        lastArgs = null;
      }
    }
    function throttled(...args) {
      lastArgs = args;
      raf.onStart(queuedFn);
    }
    throttled.handler = fn;
    throttled.cancel = () => {
      onStartQueue.delete(queuedFn);
      lastArgs = null;
    };
    return throttled;
  };
  let nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : () => {
  };
  raf.use = (impl) => nativeRaf = impl;
  raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
  raf.batchedUpdates = (fn) => fn();
  raf.catch = console.error;
  raf.frameLoop = "always";
  raf.advance = () => {
    if (raf.frameLoop !== "demand") {
      console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand");
    } else {
      update();
    }
  };
  let ts = -1;
  let pendingCount = 0;
  let sync = false;
  function schedule(fn, queue) {
    if (sync) {
      queue.delete(fn);
      fn(0);
    } else {
      queue.add(fn);
      start$1();
    }
  }
  function start$1() {
    if (ts < 0) {
      ts = 0;
      if (raf.frameLoop !== "demand") {
        nativeRaf(loop);
      }
    }
  }
  function stop() {
    ts = -1;
  }
  function loop() {
    if (~ts) {
      nativeRaf(loop);
      raf.batchedUpdates(update);
    }
  }
  function update() {
    let prevTs = ts;
    ts = raf.now();
    let count = findTimeout(ts);
    if (count) {
      eachSafely(timeouts.splice(0, count), (t2) => t2.handler());
      pendingCount -= count;
    }
    onStartQueue.flush();
    updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
    onFrameQueue.flush();
    writeQueue.flush();
    onFinishQueue.flush();
    if (!pendingCount) {
      stop();
    }
  }
  function makeQueue() {
    let next = /* @__PURE__ */ new Set();
    let current = next;
    return {
      add(fn) {
        pendingCount += current == next && !next.has(fn) ? 1 : 0;
        next.add(fn);
      },
      delete(fn) {
        pendingCount -= current == next && next.has(fn) ? 1 : 0;
        return next.delete(fn);
      },
      flush(arg) {
        if (current.size) {
          next = /* @__PURE__ */ new Set();
          pendingCount -= current.size;
          eachSafely(current, (fn) => fn(arg) && next.add(fn));
          pendingCount += next.size;
          current = next;
        }
      }
    };
  }
  function eachSafely(values, each2) {
    values.forEach((value) => {
      try {
        each2(value);
      } catch (e2) {
        raf.catch(e2);
      }
    });
  }
  function noop() {
  }
  const defineHidden = (obj, key, value) => Object.defineProperty(obj, key, {
    value,
    writable: true,
    configurable: true
  });
  const is = {
    arr: Array.isArray,
    obj: (a) => !!a && a.constructor.name === "Object",
    fun: (a) => typeof a === "function",
    str: (a) => typeof a === "string",
    num: (a) => typeof a === "number",
    und: (a) => a === void 0
  };
  function isEqual(a, b2) {
    if (is.arr(a)) {
      if (!is.arr(b2) || a.length !== b2.length)
        return false;
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b2[i])
          return false;
      }
      return true;
    }
    return a === b2;
  }
  const each = (obj, fn) => obj.forEach(fn);
  function eachProp(obj, fn, ctx2) {
    if (is.arr(obj)) {
      for (let i = 0; i < obj.length; i++) {
        fn.call(ctx2, obj[i], `${i}`);
      }
      return;
    }
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        fn.call(ctx2, obj[key], key);
      }
    }
  }
  const toArray$3 = (a) => is.und(a) ? [] : is.arr(a) ? a : [a];
  function flush(queue, iterator) {
    if (queue.size) {
      const items = Array.from(queue);
      queue.clear();
      each(items, iterator);
    }
  }
  const flushCalls = (queue, ...args) => flush(queue, (fn) => fn(...args));
  const isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
  let createStringInterpolator$1;
  let to;
  let colors$1 = null;
  let skipAnimation = false;
  let willAdvance = noop;
  const assign = (globals2) => {
    if (globals2.to)
      to = globals2.to;
    if (globals2.now)
      raf.now = globals2.now;
    if (globals2.colors !== void 0)
      colors$1 = globals2.colors;
    if (globals2.skipAnimation != null)
      skipAnimation = globals2.skipAnimation;
    if (globals2.createStringInterpolator)
      createStringInterpolator$1 = globals2.createStringInterpolator;
    if (globals2.requestAnimationFrame)
      raf.use(globals2.requestAnimationFrame);
    if (globals2.batchedUpdates)
      raf.batchedUpdates = globals2.batchedUpdates;
    if (globals2.willAdvance)
      willAdvance = globals2.willAdvance;
    if (globals2.frameLoop)
      raf.frameLoop = globals2.frameLoop;
  };
  var globals = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    get createStringInterpolator() {
      return createStringInterpolator$1;
    },
    get to() {
      return to;
    },
    get colors() {
      return colors$1;
    },
    get skipAnimation() {
      return skipAnimation;
    },
    get willAdvance() {
      return willAdvance;
    },
    assign
  });
  const startQueue = /* @__PURE__ */ new Set();
  let currentFrame = [];
  let prevFrame = [];
  let priority = 0;
  const frameLoop = {
    get idle() {
      return !startQueue.size && !currentFrame.length;
    },
    start(animation) {
      if (priority > animation.priority) {
        startQueue.add(animation);
        raf.onStart(flushStartQueue);
      } else {
        startSafely(animation);
        raf(advance);
      }
    },
    advance,
    sort(animation) {
      if (priority) {
        raf.onFrame(() => frameLoop.sort(animation));
      } else {
        const prevIndex = currentFrame.indexOf(animation);
        if (~prevIndex) {
          currentFrame.splice(prevIndex, 1);
          startUnsafely(animation);
        }
      }
    },
    clear() {
      currentFrame = [];
      startQueue.clear();
    }
  };
  function flushStartQueue() {
    startQueue.forEach(startSafely);
    startQueue.clear();
    raf(advance);
  }
  function startSafely(animation) {
    if (!currentFrame.includes(animation))
      startUnsafely(animation);
  }
  function startUnsafely(animation) {
    currentFrame.splice(findIndex(currentFrame, (other) => other.priority > animation.priority), 0, animation);
  }
  function advance(dt) {
    const nextFrame = prevFrame;
    for (let i = 0; i < currentFrame.length; i++) {
      const animation = currentFrame[i];
      priority = animation.priority;
      if (!animation.idle) {
        willAdvance(animation);
        animation.advance(dt);
        if (!animation.idle) {
          nextFrame.push(animation);
        }
      }
    }
    priority = 0;
    prevFrame = currentFrame;
    prevFrame.length = 0;
    currentFrame = nextFrame;
    return currentFrame.length > 0;
  }
  function findIndex(arr, test) {
    const index2 = arr.findIndex(test);
    return index2 < 0 ? arr.length : index2;
  }
  const colors = {
    transparent: 0,
    aliceblue: 4042850303,
    antiquewhite: 4209760255,
    aqua: 16777215,
    aquamarine: 2147472639,
    azure: 4043309055,
    beige: 4126530815,
    bisque: 4293182719,
    black: 255,
    blanchedalmond: 4293643775,
    blue: 65535,
    blueviolet: 2318131967,
    brown: 2771004159,
    burlywood: 3736635391,
    burntsienna: 3934150143,
    cadetblue: 1604231423,
    chartreuse: 2147418367,
    chocolate: 3530104575,
    coral: 4286533887,
    cornflowerblue: 1687547391,
    cornsilk: 4294499583,
    crimson: 3692313855,
    cyan: 16777215,
    darkblue: 35839,
    darkcyan: 9145343,
    darkgoldenrod: 3095792639,
    darkgray: 2846468607,
    darkgreen: 6553855,
    darkgrey: 2846468607,
    darkkhaki: 3182914559,
    darkmagenta: 2332068863,
    darkolivegreen: 1433087999,
    darkorange: 4287365375,
    darkorchid: 2570243327,
    darkred: 2332033279,
    darksalmon: 3918953215,
    darkseagreen: 2411499519,
    darkslateblue: 1211993087,
    darkslategray: 793726975,
    darkslategrey: 793726975,
    darkturquoise: 13554175,
    darkviolet: 2483082239,
    deeppink: 4279538687,
    deepskyblue: 12582911,
    dimgray: 1768516095,
    dimgrey: 1768516095,
    dodgerblue: 512819199,
    firebrick: 2988581631,
    floralwhite: 4294635775,
    forestgreen: 579543807,
    fuchsia: 4278255615,
    gainsboro: 3705462015,
    ghostwhite: 4177068031,
    gold: 4292280575,
    goldenrod: 3668254975,
    gray: 2155905279,
    green: 8388863,
    greenyellow: 2919182335,
    grey: 2155905279,
    honeydew: 4043305215,
    hotpink: 4285117695,
    indianred: 3445382399,
    indigo: 1258324735,
    ivory: 4294963455,
    khaki: 4041641215,
    lavender: 3873897215,
    lavenderblush: 4293981695,
    lawngreen: 2096890111,
    lemonchiffon: 4294626815,
    lightblue: 2916673279,
    lightcoral: 4034953471,
    lightcyan: 3774873599,
    lightgoldenrodyellow: 4210742015,
    lightgray: 3553874943,
    lightgreen: 2431553791,
    lightgrey: 3553874943,
    lightpink: 4290167295,
    lightsalmon: 4288707327,
    lightseagreen: 548580095,
    lightskyblue: 2278488831,
    lightslategray: 2005441023,
    lightslategrey: 2005441023,
    lightsteelblue: 2965692159,
    lightyellow: 4294959359,
    lime: 16711935,
    limegreen: 852308735,
    linen: 4210091775,
    magenta: 4278255615,
    maroon: 2147483903,
    mediumaquamarine: 1724754687,
    mediumblue: 52735,
    mediumorchid: 3126187007,
    mediumpurple: 2473647103,
    mediumseagreen: 1018393087,
    mediumslateblue: 2070474495,
    mediumspringgreen: 16423679,
    mediumturquoise: 1221709055,
    mediumvioletred: 3340076543,
    midnightblue: 421097727,
    mintcream: 4127193855,
    mistyrose: 4293190143,
    moccasin: 4293178879,
    navajowhite: 4292783615,
    navy: 33023,
    oldlace: 4260751103,
    olive: 2155872511,
    olivedrab: 1804477439,
    orange: 4289003775,
    orangered: 4282712319,
    orchid: 3664828159,
    palegoldenrod: 4008225535,
    palegreen: 2566625535,
    paleturquoise: 2951671551,
    palevioletred: 3681588223,
    papayawhip: 4293907967,
    peachpuff: 4292524543,
    peru: 3448061951,
    pink: 4290825215,
    plum: 3718307327,
    powderblue: 2967529215,
    purple: 2147516671,
    rebeccapurple: 1714657791,
    red: 4278190335,
    rosybrown: 3163525119,
    royalblue: 1097458175,
    saddlebrown: 2336560127,
    salmon: 4202722047,
    sandybrown: 4104413439,
    seagreen: 780883967,
    seashell: 4294307583,
    sienna: 2689740287,
    silver: 3233857791,
    skyblue: 2278484991,
    slateblue: 1784335871,
    slategray: 1887473919,
    slategrey: 1887473919,
    snow: 4294638335,
    springgreen: 16744447,
    steelblue: 1182971135,
    tan: 3535047935,
    teal: 8421631,
    thistle: 3636451583,
    tomato: 4284696575,
    turquoise: 1088475391,
    violet: 4001558271,
    wheat: 4125012991,
    white: 4294967295,
    whitesmoke: 4126537215,
    yellow: 4294902015,
    yellowgreen: 2597139199
  };
  const NUMBER = "[-+]?\\d*\\.?\\d+";
  const PERCENTAGE = NUMBER + "%";
  function call$1(...parts) {
    return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
  }
  const rgb = new RegExp("rgb" + call$1(NUMBER, NUMBER, NUMBER));
  const rgba = new RegExp("rgba" + call$1(NUMBER, NUMBER, NUMBER, NUMBER));
  const hsl = new RegExp("hsl" + call$1(NUMBER, PERCENTAGE, PERCENTAGE));
  const hsla = new RegExp("hsla" + call$1(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
  const hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
  const hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
  const hex6 = /^#([0-9a-fA-F]{6})$/;
  const hex8 = /^#([0-9a-fA-F]{8})$/;
  function normalizeColor(color) {
    let match;
    if (typeof color === "number") {
      return color >>> 0 === color && color >= 0 && color <= 4294967295 ? color : null;
    }
    if (match = hex6.exec(color))
      return parseInt(match[1] + "ff", 16) >>> 0;
    if (colors$1 && colors$1[color] !== void 0) {
      return colors$1[color];
    }
    if (match = rgb.exec(color)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;
    }
    if (match = rgba.exec(color)) {
      return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;
    }
    if (match = hex3.exec(color)) {
      return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + "ff", 16) >>> 0;
    }
    if (match = hex8.exec(color))
      return parseInt(match[1], 16) >>> 0;
    if (match = hex4.exec(color)) {
      return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;
    }
    if (match = hsl.exec(color)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;
    }
    if (match = hsla.exec(color)) {
      return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;
    }
    return null;
  }
  function hue2rgb(p2, q2, t2) {
    if (t2 < 0)
      t2 += 1;
    if (t2 > 1)
      t2 -= 1;
    if (t2 < 1 / 6)
      return p2 + (q2 - p2) * 6 * t2;
    if (t2 < 1 / 2)
      return q2;
    if (t2 < 2 / 3)
      return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
    return p2;
  }
  function hslToRgb(h2, s, l2) {
    const q2 = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
    const p2 = 2 * l2 - q2;
    const r2 = hue2rgb(p2, q2, h2 + 1 / 3);
    const g2 = hue2rgb(p2, q2, h2);
    const b2 = hue2rgb(p2, q2, h2 - 1 / 3);
    return Math.round(r2 * 255) << 24 | Math.round(g2 * 255) << 16 | Math.round(b2 * 255) << 8;
  }
  function parse255(str) {
    const int = parseInt(str, 10);
    if (int < 0)
      return 0;
    if (int > 255)
      return 255;
    return int;
  }
  function parse360(str) {
    const int = parseFloat(str);
    return (int % 360 + 360) % 360 / 360;
  }
  function parse1(str) {
    const num = parseFloat(str);
    if (num < 0)
      return 0;
    if (num > 1)
      return 255;
    return Math.round(num * 255);
  }
  function parsePercentage(str) {
    const int = parseFloat(str);
    if (int < 0)
      return 0;
    if (int > 100)
      return 1;
    return int / 100;
  }
  function colorToRgba(input) {
    let int32Color = normalizeColor(input);
    if (int32Color === null)
      return input;
    int32Color = int32Color || 0;
    let r2 = (int32Color & 4278190080) >>> 24;
    let g2 = (int32Color & 16711680) >>> 16;
    let b2 = (int32Color & 65280) >>> 8;
    let a = (int32Color & 255) / 255;
    return `rgba(${r2}, ${g2}, ${b2}, ${a})`;
  }
  const createInterpolator = (range2, output, extrapolate) => {
    if (is.fun(range2)) {
      return range2;
    }
    if (is.arr(range2)) {
      return createInterpolator({
        range: range2,
        output,
        extrapolate
      });
    }
    if (is.str(range2.output[0])) {
      return createStringInterpolator$1(range2);
    }
    const config2 = range2;
    const outputRange = config2.output;
    const inputRange = config2.range || [0, 1];
    const extrapolateLeft = config2.extrapolateLeft || config2.extrapolate || "extend";
    const extrapolateRight = config2.extrapolateRight || config2.extrapolate || "extend";
    const easing = config2.easing || ((t2) => t2);
    return (input) => {
      const range3 = findRange(input, inputRange);
      return interpolate(input, inputRange[range3], inputRange[range3 + 1], outputRange[range3], outputRange[range3 + 1], easing, extrapolateLeft, extrapolateRight, config2.map);
    };
  };
  function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
    let result = map ? map(input) : input;
    if (result < inputMin) {
      if (extrapolateLeft === "identity")
        return result;
      else if (extrapolateLeft === "clamp")
        result = inputMin;
    }
    if (result > inputMax) {
      if (extrapolateRight === "identity")
        return result;
      else if (extrapolateRight === "clamp")
        result = inputMax;
    }
    if (outputMin === outputMax)
      return outputMin;
    if (inputMin === inputMax)
      return input <= inputMin ? outputMin : outputMax;
    if (inputMin === -Infinity)
      result = -result;
    else if (inputMax === Infinity)
      result = result - inputMin;
    else
      result = (result - inputMin) / (inputMax - inputMin);
    result = easing(result);
    if (outputMin === -Infinity)
      result = -result;
    else if (outputMax === Infinity)
      result = result + outputMin;
    else
      result = result * (outputMax - outputMin) + outputMin;
    return result;
  }
  function findRange(input, inputRange) {
    for (var i = 1; i < inputRange.length - 1; ++i)
      if (inputRange[i] >= input)
        break;
    return i - 1;
  }
  function _extends$3() {
    _extends$3 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$3.apply(this, arguments);
  }
  const $get = Symbol.for("FluidValue.get");
  const $observers = Symbol.for("FluidValue.observers");
  const hasFluidValue = (arg) => Boolean(arg && arg[$get]);
  const getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
  const getFluidObservers = (target) => target[$observers] || null;
  function callFluidObserver(observer, event) {
    if (observer.eventObserved) {
      observer.eventObserved(event);
    } else {
      observer(event);
    }
  }
  function callFluidObservers(target, event) {
    let observers = target[$observers];
    if (observers) {
      observers.forEach((observer) => {
        callFluidObserver(observer, event);
      });
    }
  }
  class FluidValue {
    constructor(get2) {
      this[$get] = void 0;
      this[$observers] = void 0;
      if (!get2 && !(get2 = this.get)) {
        throw Error("Unknown getter");
      }
      setFluidGetter(this, get2);
    }
  }
  const setFluidGetter = (target, get2) => setHidden(target, $get, get2);
  function addFluidObserver(target, observer) {
    if (target[$get]) {
      let observers = target[$observers];
      if (!observers) {
        setHidden(target, $observers, observers = /* @__PURE__ */ new Set());
      }
      if (!observers.has(observer)) {
        observers.add(observer);
        if (target.observerAdded) {
          target.observerAdded(observers.size, observer);
        }
      }
    }
    return observer;
  }
  function removeFluidObserver(target, observer) {
    let observers = target[$observers];
    if (observers && observers.has(observer)) {
      const count = observers.size - 1;
      if (count) {
        observers.delete(observer);
      } else {
        target[$observers] = null;
      }
      if (target.observerRemoved) {
        target.observerRemoved(count, observer);
      }
    }
  }
  const setHidden = (target, key, value) => Object.defineProperty(target, key, {
    value,
    writable: true,
    configurable: true
  });
  const numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
  const colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
  const unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
  const rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
  const cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
  const variableToRgba = (input) => {
    const [token, fallback] = parseCSSVariable(input);
    if (!token || isSSR()) {
      return input;
    }
    const value = window.getComputedStyle(document.documentElement).getPropertyValue(token);
    if (value) {
      return value.trim();
    } else if (fallback && fallback.startsWith("--")) {
      const _value = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
      if (_value) {
        return _value;
      } else {
        return input;
      }
    } else if (fallback && cssVariableRegex.test(fallback)) {
      return variableToRgba(fallback);
    } else if (fallback) {
      return fallback;
    }
    return input;
  };
  const parseCSSVariable = (current) => {
    const match = cssVariableRegex.exec(current);
    if (!match)
      return [,];
    const [, token, fallback] = match;
    return [token, fallback];
  };
  let namedColorRegex;
  const rgbaRound = (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`;
  const createStringInterpolator = (config2) => {
    if (!namedColorRegex)
      namedColorRegex = colors$1 ? new RegExp(`(${Object.keys(colors$1).join("|")})(?!\\w)`, "g") : /^\b$/;
    const output = config2.output.map((value) => {
      return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
    });
    const keyframes = output.map((value) => value.match(numberRegex).map(Number));
    const outputRanges = keyframes[0].map((_, i) => keyframes.map((values) => {
      if (!(i in values)) {
        throw Error('The arity of each "output" value must be equal');
      }
      return values[i];
    }));
    const interpolators = outputRanges.map((output2) => createInterpolator(_extends$3({}, config2, {
      output: output2
    })));
    return (input) => {
      var _output$find;
      const missingUnit = !unitRegex.test(output[0]) && ((_output$find = output.find((value) => unitRegex.test(value))) == null ? void 0 : _output$find.replace(numberRegex, ""));
      let i = 0;
      return output[0].replace(numberRegex, () => `${interpolators[i++](input)}${missingUnit || ""}`).replace(rgbaRegex, rgbaRound);
    };
  };
  const prefix$1 = "react-spring: ";
  const once = (fn) => {
    const func = fn;
    let called = false;
    if (typeof func != "function") {
      throw new TypeError(`${prefix$1}once requires a function parameter`);
    }
    return (...args) => {
      if (!called) {
        func(...args);
        called = true;
      }
    };
  };
  const warnInterpolate = once(console.warn);
  function deprecateInterpolate() {
    warnInterpolate(`${prefix$1}The "interpolate" function is deprecated in v9 (use "to" instead)`);
  }
  const warnDirectCall = once(console.warn);
  function deprecateDirectCall() {
    warnDirectCall(`${prefix$1}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`);
  }
  function isAnimatedString(value) {
    return is.str(value) && (value[0] == "#" || /\d/.test(value) || !isSSR() && cssVariableRegex.test(value) || value in (colors$1 || {}));
  }
  const useLayoutEffect = typeof window !== "undefined" && window.document && window.document.createElement ? React__namespace.useLayoutEffect : React__namespace.useEffect;
  const useIsMounted = () => {
    const isMounted = React.useRef(false);
    useLayoutEffect(() => {
      isMounted.current = true;
      return () => {
        isMounted.current = false;
      };
    }, []);
    return isMounted;
  };
  function useForceUpdate() {
    const update2 = React.useState()[1];
    const isMounted = useIsMounted();
    return () => {
      if (isMounted.current) {
        update2(Math.random());
      }
    };
  }
  function useMemoOne(getResult, inputs) {
    const [initial] = React.useState(() => ({
      inputs,
      result: getResult()
    }));
    const committed = React.useRef();
    const prevCache = committed.current;
    let cache = prevCache;
    if (cache) {
      const useCache = Boolean(inputs && cache.inputs && areInputsEqual(inputs, cache.inputs));
      if (!useCache) {
        cache = {
          inputs,
          result: getResult()
        };
      }
    } else {
      cache = initial;
    }
    React.useEffect(() => {
      committed.current = cache;
      if (prevCache == initial) {
        initial.inputs = initial.result = void 0;
      }
    }, [cache]);
    return cache.result;
  }
  function areInputsEqual(next, prev2) {
    if (next.length !== prev2.length) {
      return false;
    }
    for (let i = 0; i < next.length; i++) {
      if (next[i] !== prev2[i]) {
        return false;
      }
    }
    return true;
  }
  const useOnce = (effect3) => React.useEffect(effect3, emptyDeps);
  const emptyDeps = [];
  function usePrev(value) {
    const prevRef = React.useRef();
    React.useEffect(() => {
      prevRef.current = value;
    });
    return prevRef.current;
  }
  const $node = Symbol.for("Animated:node");
  const isAnimated = (value) => !!value && value[$node] === value;
  const getAnimated = (owner) => owner && owner[$node];
  const setAnimated = (owner, node) => defineHidden(owner, $node, node);
  const getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
  class Animated {
    constructor() {
      this.payload = void 0;
      setAnimated(this, this);
    }
    getPayload() {
      return this.payload || [];
    }
  }
  class AnimatedValue extends Animated {
    constructor(_value) {
      super();
      this.done = true;
      this.elapsedTime = void 0;
      this.lastPosition = void 0;
      this.lastVelocity = void 0;
      this.v0 = void 0;
      this.durationProgress = 0;
      this._value = _value;
      if (is.num(this._value)) {
        this.lastPosition = this._value;
      }
    }
    static create(value) {
      return new AnimatedValue(value);
    }
    getPayload() {
      return [this];
    }
    getValue() {
      return this._value;
    }
    setValue(value, step) {
      if (is.num(value)) {
        this.lastPosition = value;
        if (step) {
          value = Math.round(value / step) * step;
          if (this.done) {
            this.lastPosition = value;
          }
        }
      }
      if (this._value === value) {
        return false;
      }
      this._value = value;
      return true;
    }
    reset() {
      const {
        done
      } = this;
      this.done = false;
      if (is.num(this._value)) {
        this.elapsedTime = 0;
        this.durationProgress = 0;
        this.lastPosition = this._value;
        if (done)
          this.lastVelocity = null;
        this.v0 = null;
      }
    }
  }
  class AnimatedString extends AnimatedValue {
    constructor(value) {
      super(0);
      this._string = null;
      this._toString = void 0;
      this._toString = createInterpolator({
        output: [value, value]
      });
    }
    static create(value) {
      return new AnimatedString(value);
    }
    getValue() {
      let value = this._string;
      return value == null ? this._string = this._toString(this._value) : value;
    }
    setValue(value) {
      if (is.str(value)) {
        if (value == this._string) {
          return false;
        }
        this._string = value;
        this._value = 1;
      } else if (super.setValue(value)) {
        this._string = null;
      } else {
        return false;
      }
      return true;
    }
    reset(goal) {
      if (goal) {
        this._toString = createInterpolator({
          output: [this.getValue(), goal]
        });
      }
      this._value = 0;
      super.reset();
    }
  }
  const TreeContext = {
    dependencies: null
  };
  class AnimatedObject extends Animated {
    constructor(source) {
      super();
      this.source = source;
      this.setValue(source);
    }
    getValue(animated2) {
      const values = {};
      eachProp(this.source, (source, key) => {
        if (isAnimated(source)) {
          values[key] = source.getValue(animated2);
        } else if (hasFluidValue(source)) {
          values[key] = getFluidValue(source);
        } else if (!animated2) {
          values[key] = source;
        }
      });
      return values;
    }
    setValue(source) {
      this.source = source;
      this.payload = this._makePayload(source);
    }
    reset() {
      if (this.payload) {
        each(this.payload, (node) => node.reset());
      }
    }
    _makePayload(source) {
      if (source) {
        const payload = /* @__PURE__ */ new Set();
        eachProp(source, this._addToPayload, payload);
        return Array.from(payload);
      }
    }
    _addToPayload(source) {
      if (TreeContext.dependencies && hasFluidValue(source)) {
        TreeContext.dependencies.add(source);
      }
      const payload = getPayload(source);
      if (payload) {
        each(payload, (node) => this.add(node));
      }
    }
  }
  class AnimatedArray extends AnimatedObject {
    constructor(source) {
      super(source);
    }
    static create(source) {
      return new AnimatedArray(source);
    }
    getValue() {
      return this.source.map((node) => node.getValue());
    }
    setValue(source) {
      const payload = this.getPayload();
      if (source.length == payload.length) {
        return payload.map((node, i) => node.setValue(source[i])).some(Boolean);
      }
      super.setValue(source.map(makeAnimated));
      return true;
    }
  }
  function makeAnimated(value) {
    const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;
    return nodeType.create(value);
  }
  function getAnimatedType(value) {
    const parentNode = getAnimated(value);
    return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;
  }
  function _extends$2() {
    _extends$2 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$2.apply(this, arguments);
  }
  const withAnimated = (Component, host2) => {
    const hasInstance = !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;
    return React.forwardRef((givenProps, givenRef) => {
      const instanceRef = React.useRef(null);
      const ref = hasInstance && React.useCallback((value) => {
        instanceRef.current = updateRef(givenRef, value);
      }, [givenRef]);
      const [props, deps] = getAnimatedState(givenProps, host2);
      const forceUpdate = useForceUpdate();
      const callback = () => {
        const instance = instanceRef.current;
        if (hasInstance && !instance) {
          return;
        }
        const didUpdate = instance ? host2.applyAnimatedValues(instance, props.getValue(true)) : false;
        if (didUpdate === false) {
          forceUpdate();
        }
      };
      const observer = new PropsObserver(callback, deps);
      const observerRef = React.useRef();
      useLayoutEffect(() => {
        observerRef.current = observer;
        each(deps, (dep) => addFluidObserver(dep, observer));
        return () => {
          if (observerRef.current) {
            each(observerRef.current.deps, (dep) => removeFluidObserver(dep, observerRef.current));
            raf.cancel(observerRef.current.update);
          }
        };
      });
      React.useEffect(callback, []);
      useOnce(() => () => {
        const observer2 = observerRef.current;
        each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));
      });
      const usedProps = host2.getComponentProps(props.getValue());
      return React__namespace.createElement(Component, _extends$2({}, usedProps, {
        ref
      }));
    });
  };
  class PropsObserver {
    constructor(update2, deps) {
      this.update = update2;
      this.deps = deps;
    }
    eventObserved(event) {
      if (event.type == "change") {
        raf.write(this.update);
      }
    }
  }
  function getAnimatedState(props, host2) {
    const dependencies = /* @__PURE__ */ new Set();
    TreeContext.dependencies = dependencies;
    if (props.style)
      props = _extends$2({}, props, {
        style: host2.createAnimatedStyle(props.style)
      });
    props = new AnimatedObject(props);
    TreeContext.dependencies = null;
    return [props, dependencies];
  }
  function updateRef(ref, value) {
    if (ref) {
      if (is.fun(ref))
        ref(value);
      else
        ref.current = value;
    }
    return value;
  }
  const cacheKey = Symbol.for("AnimatedComponent");
  const createHost = (components, {
    applyAnimatedValues: _applyAnimatedValues = () => false,
    createAnimatedStyle: _createAnimatedStyle = (style) => new AnimatedObject(style),
    getComponentProps: _getComponentProps = (props) => props
  } = {}) => {
    const hostConfig = {
      applyAnimatedValues: _applyAnimatedValues,
      createAnimatedStyle: _createAnimatedStyle,
      getComponentProps: _getComponentProps
    };
    const animated2 = (Component) => {
      const displayName = getDisplayName(Component) || "Anonymous";
      if (is.str(Component)) {
        Component = animated2[Component] || (animated2[Component] = withAnimated(Component, hostConfig));
      } else {
        Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
      }
      Component.displayName = `Animated(${displayName})`;
      return Component;
    };
    eachProp(components, (Component, key) => {
      if (is.arr(components)) {
        key = getDisplayName(Component);
      }
      animated2[key] = animated2(Component);
    });
    return {
      animated: animated2
    };
  };
  const getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;
  function _extends$1() {
    _extends$1 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$1.apply(this, arguments);
  }
  function callProp(value, ...args) {
    return is.fun(value) ? value(...args) : value;
  }
  const matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray$3(value).includes(key)));
  const resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;
  const getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
  const noopTransform = (value) => value;
  const getDefaultProps = (props, transform = noopTransform) => {
    let keys = DEFAULT_PROPS;
    if (props.default && props.default !== true) {
      props = props.default;
      keys = Object.keys(props);
    }
    const defaults2 = {};
    for (const key of keys) {
      const value = transform(props[key], key);
      if (!is.und(value)) {
        defaults2[key] = value;
      }
    }
    return defaults2;
  };
  const DEFAULT_PROPS = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"];
  const RESERVED_PROPS = {
    config: 1,
    from: 1,
    to: 1,
    ref: 1,
    loop: 1,
    reset: 1,
    pause: 1,
    cancel: 1,
    reverse: 1,
    immediate: 1,
    default: 1,
    delay: 1,
    onProps: 1,
    onStart: 1,
    onChange: 1,
    onPause: 1,
    onResume: 1,
    onRest: 1,
    onResolve: 1,
    items: 1,
    trail: 1,
    sort: 1,
    expires: 1,
    initial: 1,
    enter: 1,
    update: 1,
    leave: 1,
    children: 1,
    onDestroyed: 1,
    keys: 1,
    callId: 1,
    parentId: 1
  };
  function getForwardProps(props) {
    const forward = {};
    let count = 0;
    eachProp(props, (value, prop) => {
      if (!RESERVED_PROPS[prop]) {
        forward[prop] = value;
        count++;
      }
    });
    if (count) {
      return forward;
    }
  }
  function inferTo(props) {
    const to2 = getForwardProps(props);
    if (to2) {
      const out = {
        to: to2
      };
      eachProp(props, (val, key) => key in to2 || (out[key] = val));
      return out;
    }
    return _extends$1({}, props);
  }
  function computeGoal(value) {
    value = getFluidValue(value);
    return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? globals.createStringInterpolator({
      range: [0, 1],
      output: [value, value]
    })(1) : value;
  }
  function hasProps(props) {
    for (const _ in props)
      return true;
    return false;
  }
  function isAsyncTo(to2) {
    return is.fun(to2) || is.arr(to2) && is.obj(to2[0]);
  }
  function detachRefs(ctrl, ref) {
    var _ctrl$ref;
    (_ctrl$ref = ctrl.ref) == null ? void 0 : _ctrl$ref.delete(ctrl);
    ref == null ? void 0 : ref.delete(ctrl);
  }
  function replaceRef(ctrl, ref) {
    if (ref && ctrl.ref !== ref) {
      var _ctrl$ref2;
      (_ctrl$ref2 = ctrl.ref) == null ? void 0 : _ctrl$ref2.delete(ctrl);
      ref.add(ctrl);
      ctrl.ref = ref;
    }
  }
  const config = {
    default: {
      tension: 170,
      friction: 26
    },
    gentle: {
      tension: 120,
      friction: 14
    },
    wobbly: {
      tension: 180,
      friction: 12
    },
    stiff: {
      tension: 210,
      friction: 20
    },
    slow: {
      tension: 280,
      friction: 60
    },
    molasses: {
      tension: 280,
      friction: 120
    }
  };
  const c1 = 1.70158;
  const c2 = c1 * 1.525;
  const c3 = c1 + 1;
  const c4 = 2 * Math.PI / 3;
  const c5 = 2 * Math.PI / 4.5;
  const bounceOut = (x2) => {
    const n1 = 7.5625;
    const d1 = 2.75;
    if (x2 < 1 / d1) {
      return n1 * x2 * x2;
    } else if (x2 < 2 / d1) {
      return n1 * (x2 -= 1.5 / d1) * x2 + 0.75;
    } else if (x2 < 2.5 / d1) {
      return n1 * (x2 -= 2.25 / d1) * x2 + 0.9375;
    } else {
      return n1 * (x2 -= 2.625 / d1) * x2 + 0.984375;
    }
  };
  const easings = {
    linear: (x2) => x2,
    easeInQuad: (x2) => x2 * x2,
    easeOutQuad: (x2) => 1 - (1 - x2) * (1 - x2),
    easeInOutQuad: (x2) => x2 < 0.5 ? 2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 2) / 2,
    easeInCubic: (x2) => x2 * x2 * x2,
    easeOutCubic: (x2) => 1 - Math.pow(1 - x2, 3),
    easeInOutCubic: (x2) => x2 < 0.5 ? 4 * x2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 3) / 2,
    easeInQuart: (x2) => x2 * x2 * x2 * x2,
    easeOutQuart: (x2) => 1 - Math.pow(1 - x2, 4),
    easeInOutQuart: (x2) => x2 < 0.5 ? 8 * x2 * x2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 4) / 2,
    easeInQuint: (x2) => x2 * x2 * x2 * x2 * x2,
    easeOutQuint: (x2) => 1 - Math.pow(1 - x2, 5),
    easeInOutQuint: (x2) => x2 < 0.5 ? 16 * x2 * x2 * x2 * x2 * x2 : 1 - Math.pow(-2 * x2 + 2, 5) / 2,
    easeInSine: (x2) => 1 - Math.cos(x2 * Math.PI / 2),
    easeOutSine: (x2) => Math.sin(x2 * Math.PI / 2),
    easeInOutSine: (x2) => -(Math.cos(Math.PI * x2) - 1) / 2,
    easeInExpo: (x2) => x2 === 0 ? 0 : Math.pow(2, 10 * x2 - 10),
    easeOutExpo: (x2) => x2 === 1 ? 1 : 1 - Math.pow(2, -10 * x2),
    easeInOutExpo: (x2) => x2 === 0 ? 0 : x2 === 1 ? 1 : x2 < 0.5 ? Math.pow(2, 20 * x2 - 10) / 2 : (2 - Math.pow(2, -20 * x2 + 10)) / 2,
    easeInCirc: (x2) => 1 - Math.sqrt(1 - Math.pow(x2, 2)),
    easeOutCirc: (x2) => Math.sqrt(1 - Math.pow(x2 - 1, 2)),
    easeInOutCirc: (x2) => x2 < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x2, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x2 + 2, 2)) + 1) / 2,
    easeInBack: (x2) => c3 * x2 * x2 * x2 - c1 * x2 * x2,
    easeOutBack: (x2) => 1 + c3 * Math.pow(x2 - 1, 3) + c1 * Math.pow(x2 - 1, 2),
    easeInOutBack: (x2) => x2 < 0.5 ? Math.pow(2 * x2, 2) * ((c2 + 1) * 2 * x2 - c2) / 2 : (Math.pow(2 * x2 - 2, 2) * ((c2 + 1) * (x2 * 2 - 2) + c2) + 2) / 2,
    easeInElastic: (x2) => x2 === 0 ? 0 : x2 === 1 ? 1 : -Math.pow(2, 10 * x2 - 10) * Math.sin((x2 * 10 - 10.75) * c4),
    easeOutElastic: (x2) => x2 === 0 ? 0 : x2 === 1 ? 1 : Math.pow(2, -10 * x2) * Math.sin((x2 * 10 - 0.75) * c4) + 1,
    easeInOutElastic: (x2) => x2 === 0 ? 0 : x2 === 1 ? 1 : x2 < 0.5 ? -(Math.pow(2, 20 * x2 - 10) * Math.sin((20 * x2 - 11.125) * c5)) / 2 : Math.pow(2, -20 * x2 + 10) * Math.sin((20 * x2 - 11.125) * c5) / 2 + 1,
    easeInBounce: (x2) => 1 - bounceOut(1 - x2),
    easeOutBounce: bounceOut,
    easeInOutBounce: (x2) => x2 < 0.5 ? (1 - bounceOut(1 - 2 * x2)) / 2 : (1 + bounceOut(2 * x2 - 1)) / 2
  };
  const defaults = _extends$1({}, config.default, {
    mass: 1,
    damping: 1,
    easing: easings.linear,
    clamp: false
  });
  class AnimationConfig {
    constructor() {
      this.tension = void 0;
      this.friction = void 0;
      this.frequency = void 0;
      this.damping = void 0;
      this.mass = void 0;
      this.velocity = 0;
      this.restVelocity = void 0;
      this.precision = void 0;
      this.progress = void 0;
      this.duration = void 0;
      this.easing = void 0;
      this.clamp = void 0;
      this.bounce = void 0;
      this.decay = void 0;
      this.round = void 0;
      Object.assign(this, defaults);
    }
  }
  function mergeConfig(config2, newConfig, defaultConfig2) {
    if (defaultConfig2) {
      defaultConfig2 = _extends$1({}, defaultConfig2);
      sanitizeConfig(defaultConfig2, newConfig);
      newConfig = _extends$1({}, defaultConfig2, newConfig);
    }
    sanitizeConfig(config2, newConfig);
    Object.assign(config2, newConfig);
    for (const key in defaults) {
      if (config2[key] == null) {
        config2[key] = defaults[key];
      }
    }
    let {
      mass,
      frequency,
      damping
    } = config2;
    if (!is.und(frequency)) {
      if (frequency < 0.01)
        frequency = 0.01;
      if (damping < 0)
        damping = 0;
      config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
      config2.friction = 4 * Math.PI * damping * mass / frequency;
    }
    return config2;
  }
  function sanitizeConfig(config2, props) {
    if (!is.und(props.decay)) {
      config2.duration = void 0;
    } else {
      const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);
      if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {
        config2.duration = void 0;
        config2.decay = void 0;
      }
      if (isTensionConfig) {
        config2.frequency = void 0;
      }
    }
  }
  const emptyArray = [];
  class Animation {
    constructor() {
      this.changed = false;
      this.values = emptyArray;
      this.toValues = null;
      this.fromValues = emptyArray;
      this.to = void 0;
      this.from = void 0;
      this.config = new AnimationConfig();
      this.immediate = false;
    }
  }
  function scheduleProps(callId, {
    key,
    props,
    defaultProps: defaultProps2,
    state,
    actions
  }) {
    return new Promise((resolve, reject) => {
      var _props$cancel;
      let delay;
      let timeout;
      let cancel = matchProp((_props$cancel = props.cancel) != null ? _props$cancel : defaultProps2 == null ? void 0 : defaultProps2.cancel, key);
      if (cancel) {
        onStart();
      } else {
        if (!is.und(props.pause)) {
          state.paused = matchProp(props.pause, key);
        }
        let pause = defaultProps2 == null ? void 0 : defaultProps2.pause;
        if (pause !== true) {
          pause = state.paused || matchProp(pause, key);
        }
        delay = callProp(props.delay || 0, key);
        if (pause) {
          state.resumeQueue.add(onResume);
          actions.pause();
        } else {
          actions.resume();
          onResume();
        }
      }
      function onPause() {
        state.resumeQueue.add(onResume);
        state.timeouts.delete(timeout);
        timeout.cancel();
        delay = timeout.time - raf.now();
      }
      function onResume() {
        if (delay > 0 && !globals.skipAnimation) {
          state.delayed = true;
          timeout = raf.setTimeout(onStart, delay);
          state.pauseQueue.add(onPause);
          state.timeouts.add(timeout);
        } else {
          onStart();
        }
      }
      function onStart() {
        if (state.delayed) {
          state.delayed = false;
        }
        state.pauseQueue.delete(onPause);
        state.timeouts.delete(timeout);
        if (callId <= (state.cancelId || 0)) {
          cancel = true;
        }
        try {
          actions.start(_extends$1({}, props, {
            callId,
            cancel
          }), resolve);
        } catch (err) {
          reject(err);
        }
      }
    });
  }
  const getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(target.get(), results.every((result) => result.finished));
  const getNoopResult = (value) => ({
    value,
    noop: true,
    finished: true,
    cancelled: false
  });
  const getFinishedResult = (value, finished, cancelled = false) => ({
    value,
    finished,
    cancelled
  });
  const getCancelledResult = (value) => ({
    value,
    cancelled: true,
    finished: false
  });
  function runAsync(to2, props, state, target) {
    const {
      callId,
      parentId,
      onRest
    } = props;
    const {
      asyncTo: prevTo,
      promise: prevPromise
    } = state;
    if (!parentId && to2 === prevTo && !props.reset) {
      return prevPromise;
    }
    return state.promise = (async () => {
      state.asyncId = callId;
      state.asyncTo = to2;
      const defaultProps2 = getDefaultProps(props, (value, key) => key === "onRest" ? void 0 : value);
      let preventBail;
      let bail;
      const bailPromise = new Promise((resolve, reject) => (preventBail = resolve, bail = reject));
      const bailIfEnded = (bailSignal) => {
        const bailResult = callId <= (state.cancelId || 0) && getCancelledResult(target) || callId !== state.asyncId && getFinishedResult(target, false);
        if (bailResult) {
          bailSignal.result = bailResult;
          bail(bailSignal);
          throw bailSignal;
        }
      };
      const animate = (arg1, arg2) => {
        const bailSignal = new BailSignal();
        const skipAnimationSignal = new SkipAniamtionSignal();
        return (async () => {
          if (globals.skipAnimation) {
            stopAsync(state);
            skipAnimationSignal.result = getFinishedResult(target, false);
            bail(skipAnimationSignal);
            throw skipAnimationSignal;
          }
          bailIfEnded(bailSignal);
          const props2 = is.obj(arg1) ? _extends$1({}, arg1) : _extends$1({}, arg2, {
            to: arg1
          });
          props2.parentId = callId;
          eachProp(defaultProps2, (value, key) => {
            if (is.und(props2[key])) {
              props2[key] = value;
            }
          });
          const result2 = await target.start(props2);
          bailIfEnded(bailSignal);
          if (state.paused) {
            await new Promise((resume) => {
              state.resumeQueue.add(resume);
            });
          }
          return result2;
        })();
      };
      let result;
      if (globals.skipAnimation) {
        stopAsync(state);
        return getFinishedResult(target, false);
      }
      try {
        let animating;
        if (is.arr(to2)) {
          animating = (async (queue) => {
            for (const props2 of queue) {
              await animate(props2);
            }
          })(to2);
        } else {
          animating = Promise.resolve(to2(animate, target.stop.bind(target)));
        }
        await Promise.all([animating.then(preventBail), bailPromise]);
        result = getFinishedResult(target.get(), true, false);
      } catch (err) {
        if (err instanceof BailSignal) {
          result = err.result;
        } else if (err instanceof SkipAniamtionSignal) {
          result = err.result;
        } else {
          throw err;
        }
      } finally {
        if (callId == state.asyncId) {
          state.asyncId = parentId;
          state.asyncTo = parentId ? prevTo : void 0;
          state.promise = parentId ? prevPromise : void 0;
        }
      }
      if (is.fun(onRest)) {
        raf.batchedUpdates(() => {
          onRest(result, target, target.item);
        });
      }
      return result;
    })();
  }
  function stopAsync(state, cancelId) {
    flush(state.timeouts, (t2) => t2.cancel());
    state.pauseQueue.clear();
    state.resumeQueue.clear();
    state.asyncId = state.asyncTo = state.promise = void 0;
    if (cancelId)
      state.cancelId = cancelId;
  }
  class BailSignal extends Error {
    constructor() {
      super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.");
      this.result = void 0;
    }
  }
  class SkipAniamtionSignal extends Error {
    constructor() {
      super("SkipAnimationSignal");
      this.result = void 0;
    }
  }
  const isFrameValue = (value) => value instanceof FrameValue;
  let nextId$1 = 1;
  class FrameValue extends FluidValue {
    constructor(...args) {
      super(...args);
      this.id = nextId$1++;
      this.key = void 0;
      this._priority = 0;
    }
    get priority() {
      return this._priority;
    }
    set priority(priority2) {
      if (this._priority != priority2) {
        this._priority = priority2;
        this._onPriorityChange(priority2);
      }
    }
    get() {
      const node = getAnimated(this);
      return node && node.getValue();
    }
    to(...args) {
      return globals.to(this, args);
    }
    interpolate(...args) {
      deprecateInterpolate();
      return globals.to(this, args);
    }
    toJSON() {
      return this.get();
    }
    observerAdded(count) {
      if (count == 1)
        this._attach();
    }
    observerRemoved(count) {
      if (count == 0)
        this._detach();
    }
    _attach() {
    }
    _detach() {
    }
    _onChange(value, idle = false) {
      callFluidObservers(this, {
        type: "change",
        parent: this,
        value,
        idle
      });
    }
    _onPriorityChange(priority2) {
      if (!this.idle) {
        frameLoop.sort(this);
      }
      callFluidObservers(this, {
        type: "priority",
        parent: this,
        priority: priority2
      });
    }
  }
  const $P = Symbol.for("SpringPhase");
  const HAS_ANIMATED = 1;
  const IS_ANIMATING = 2;
  const IS_PAUSED = 4;
  const hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
  const isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
  const isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
  const setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;
  const setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;
  class SpringValue extends FrameValue {
    constructor(arg1, arg2) {
      super();
      this.key = void 0;
      this.animation = new Animation();
      this.queue = void 0;
      this.defaultProps = {};
      this._state = {
        paused: false,
        delayed: false,
        pauseQueue: /* @__PURE__ */ new Set(),
        resumeQueue: /* @__PURE__ */ new Set(),
        timeouts: /* @__PURE__ */ new Set()
      };
      this._pendingCalls = /* @__PURE__ */ new Set();
      this._lastCallId = 0;
      this._lastToId = 0;
      this._memoizedDuration = 0;
      if (!is.und(arg1) || !is.und(arg2)) {
        const props = is.obj(arg1) ? _extends$1({}, arg1) : _extends$1({}, arg2, {
          from: arg1
        });
        if (is.und(props.default)) {
          props.default = true;
        }
        this.start(props);
      }
    }
    get idle() {
      return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
    }
    get goal() {
      return getFluidValue(this.animation.to);
    }
    get velocity() {
      const node = getAnimated(this);
      return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);
    }
    get hasAnimated() {
      return hasAnimated(this);
    }
    get isAnimating() {
      return isAnimating(this);
    }
    get isPaused() {
      return isPaused(this);
    }
    get isDelayed() {
      return this._state.delayed;
    }
    advance(dt) {
      let idle = true;
      let changed = false;
      const anim = this.animation;
      let {
        config: config2,
        toValues
      } = anim;
      const payload = getPayload(anim.to);
      if (!payload && hasFluidValue(anim.to)) {
        toValues = toArray$3(getFluidValue(anim.to));
      }
      anim.values.forEach((node2, i) => {
        if (node2.done)
          return;
        const to2 = node2.constructor == AnimatedString ? 1 : payload ? payload[i].lastPosition : toValues[i];
        let finished = anim.immediate;
        let position = to2;
        if (!finished) {
          position = node2.lastPosition;
          if (config2.tension <= 0) {
            node2.done = true;
            return;
          }
          let elapsed = node2.elapsedTime += dt;
          const from = anim.fromValues[i];
          const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config2.velocity) ? config2.velocity[i] : config2.velocity;
          let velocity;
          if (!is.und(config2.duration)) {
            let p2 = 1;
            if (config2.duration > 0) {
              if (this._memoizedDuration !== config2.duration) {
                this._memoizedDuration = config2.duration;
                if (node2.durationProgress > 0) {
                  node2.elapsedTime = config2.duration * node2.durationProgress;
                  elapsed = node2.elapsedTime += dt;
                }
              }
              p2 = (config2.progress || 0) + elapsed / this._memoizedDuration;
              p2 = p2 > 1 ? 1 : p2 < 0 ? 0 : p2;
              node2.durationProgress = p2;
            }
            position = from + config2.easing(p2) * (to2 - from);
            velocity = (position - node2.lastPosition) / dt;
            finished = p2 == 1;
          } else if (config2.decay) {
            const decay = config2.decay === true ? 0.998 : config2.decay;
            const e2 = Math.exp(-(1 - decay) * elapsed);
            position = from + v0 / (1 - decay) * (1 - e2);
            finished = Math.abs(node2.lastPosition - position) < 0.1;
            velocity = v0 * e2;
          } else {
            velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;
            const precision = config2.precision || (from == to2 ? 5e-3 : Math.min(1, Math.abs(to2 - from) * 1e-3));
            const restVelocity = config2.restVelocity || precision / 10;
            const bounceFactor = config2.clamp ? 0 : config2.bounce;
            const canBounce = !is.und(bounceFactor);
            const isGrowing = from == to2 ? node2.v0 > 0 : from < to2;
            let isMoving;
            let isBouncing = false;
            const step = 1;
            const numSteps = Math.ceil(dt / step);
            for (let n2 = 0; n2 < numSteps; ++n2) {
              isMoving = Math.abs(velocity) > restVelocity;
              if (!isMoving) {
                finished = Math.abs(to2 - position) <= precision;
                if (finished) {
                  break;
                }
              }
              if (canBounce) {
                isBouncing = position == to2 || position > to2 == isGrowing;
                if (isBouncing) {
                  velocity = -velocity * bounceFactor;
                  position = to2;
                }
              }
              const springForce = -config2.tension * 1e-6 * (position - to2);
              const dampingForce = -config2.friction * 1e-3 * velocity;
              const acceleration = (springForce + dampingForce) / config2.mass;
              velocity = velocity + acceleration * step;
              position = position + velocity * step;
            }
          }
          node2.lastVelocity = velocity;
          if (Number.isNaN(position)) {
            console.warn(`Got NaN while animating:`, this);
            finished = true;
          }
        }
        if (payload && !payload[i].done) {
          finished = false;
        }
        if (finished) {
          node2.done = true;
        } else {
          idle = false;
        }
        if (node2.setValue(position, config2.round)) {
          changed = true;
        }
      });
      const node = getAnimated(this);
      const currVal = node.getValue();
      if (idle) {
        const finalVal = getFluidValue(anim.to);
        if ((currVal !== finalVal || changed) && !config2.decay) {
          node.setValue(finalVal);
          this._onChange(finalVal);
        } else if (changed && config2.decay) {
          this._onChange(currVal);
        }
        this._stop();
      } else if (changed) {
        this._onChange(currVal);
      }
    }
    set(value) {
      raf.batchedUpdates(() => {
        this._stop();
        this._focus(value);
        this._set(value);
      });
      return this;
    }
    pause() {
      this._update({
        pause: true
      });
    }
    resume() {
      this._update({
        pause: false
      });
    }
    finish() {
      if (isAnimating(this)) {
        const {
          to: to2,
          config: config2
        } = this.animation;
        raf.batchedUpdates(() => {
          this._onStart();
          if (!config2.decay) {
            this._set(to2, false);
          }
          this._stop();
        });
      }
      return this;
    }
    update(props) {
      const queue = this.queue || (this.queue = []);
      queue.push(props);
      return this;
    }
    start(to2, arg2) {
      let queue;
      if (!is.und(to2)) {
        queue = [is.obj(to2) ? to2 : _extends$1({}, arg2, {
          to: to2
        })];
      } else {
        queue = this.queue || [];
        this.queue = [];
      }
      return Promise.all(queue.map((props) => {
        const up = this._update(props);
        return up;
      })).then((results) => getCombinedResult(this, results));
    }
    stop(cancel) {
      const {
        to: to2
      } = this.animation;
      this._focus(this.get());
      stopAsync(this._state, cancel && this._lastCallId);
      raf.batchedUpdates(() => this._stop(to2, cancel));
      return this;
    }
    reset() {
      this._update({
        reset: true
      });
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._start();
      } else if (event.type == "priority") {
        this.priority = event.priority + 1;
      }
    }
    _prepareNode(props) {
      const key = this.key || "";
      let {
        to: to2,
        from
      } = props;
      to2 = is.obj(to2) ? to2[key] : to2;
      if (to2 == null || isAsyncTo(to2)) {
        to2 = void 0;
      }
      from = is.obj(from) ? from[key] : from;
      if (from == null) {
        from = void 0;
      }
      const range2 = {
        to: to2,
        from
      };
      if (!hasAnimated(this)) {
        if (props.reverse)
          [to2, from] = [from, to2];
        from = getFluidValue(from);
        if (!is.und(from)) {
          this._set(from);
        } else if (!getAnimated(this)) {
          this._set(to2);
        }
      }
      return range2;
    }
    _update(_ref, isLoop) {
      let props = _extends$1({}, _ref);
      const {
        key,
        defaultProps: defaultProps2
      } = this;
      if (props.default)
        Object.assign(defaultProps2, getDefaultProps(props, (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value));
      mergeActiveFn(this, props, "onProps");
      sendEvent(this, "onProps", props, this);
      const range2 = this._prepareNode(props);
      if (Object.isFrozen(this)) {
        throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
      }
      const state = this._state;
      return scheduleProps(++this._lastCallId, {
        key,
        props,
        defaultProps: defaultProps2,
        state,
        actions: {
          pause: () => {
            if (!isPaused(this)) {
              setPausedBit(this, true);
              flushCalls(state.pauseQueue);
              sendEvent(this, "onPause", getFinishedResult(this, checkFinished(this, this.animation.to)), this);
            }
          },
          resume: () => {
            if (isPaused(this)) {
              setPausedBit(this, false);
              if (isAnimating(this)) {
                this._resume();
              }
              flushCalls(state.resumeQueue);
              sendEvent(this, "onResume", getFinishedResult(this, checkFinished(this, this.animation.to)), this);
            }
          },
          start: this._merge.bind(this, range2)
        }
      }).then((result) => {
        if (props.loop && result.finished && !(isLoop && result.noop)) {
          const nextProps = createLoopUpdate(props);
          if (nextProps) {
            return this._update(nextProps, true);
          }
        }
        return result;
      });
    }
    _merge(range2, props, resolve) {
      if (props.cancel) {
        this.stop(true);
        return resolve(getCancelledResult(this));
      }
      const hasToProp = !is.und(range2.to);
      const hasFromProp = !is.und(range2.from);
      if (hasToProp || hasFromProp) {
        if (props.callId > this._lastToId) {
          this._lastToId = props.callId;
        } else {
          return resolve(getCancelledResult(this));
        }
      }
      const {
        key,
        defaultProps: defaultProps2,
        animation: anim
      } = this;
      const {
        to: prevTo,
        from: prevFrom
      } = anim;
      let {
        to: to2 = prevTo,
        from = prevFrom
      } = range2;
      if (hasFromProp && !hasToProp && (!props.default || is.und(to2))) {
        to2 = from;
      }
      if (props.reverse)
        [to2, from] = [from, to2];
      const hasFromChanged = !isEqual(from, prevFrom);
      if (hasFromChanged) {
        anim.from = from;
      }
      from = getFluidValue(from);
      const hasToChanged = !isEqual(to2, prevTo);
      if (hasToChanged) {
        this._focus(to2);
      }
      const hasAsyncTo = isAsyncTo(props.to);
      const {
        config: config2
      } = anim;
      const {
        decay,
        velocity
      } = config2;
      if (hasToProp || hasFromProp) {
        config2.velocity = 0;
      }
      if (props.config && !hasAsyncTo) {
        mergeConfig(config2, callProp(props.config, key), props.config !== defaultProps2.config ? callProp(defaultProps2.config, key) : void 0);
      }
      let node = getAnimated(this);
      if (!node || is.und(to2)) {
        return resolve(getFinishedResult(this, true));
      }
      const reset = is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key);
      const value = reset ? from : this.get();
      const goal = computeGoal(to2);
      const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);
      const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps2.immediate || props.immediate, key));
      if (hasToChanged) {
        const nodeType = getAnimatedType(to2);
        if (nodeType !== node.constructor) {
          if (immediate) {
            node = this._set(goal);
          } else
            throw Error(`Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the "to" prop suggests`);
        }
      }
      const goalType = node.constructor;
      let started = hasFluidValue(to2);
      let finished = false;
      if (!started) {
        const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
        if (hasToChanged || hasValueChanged) {
          finished = isEqual(computeGoal(value), goal);
          started = !finished;
        }
        if (!isEqual(anim.immediate, immediate) && !immediate || !isEqual(config2.decay, decay) || !isEqual(config2.velocity, velocity)) {
          started = true;
        }
      }
      if (finished && isAnimating(this)) {
        if (anim.changed && !reset) {
          started = true;
        } else if (!started) {
          this._stop(prevTo);
        }
      }
      if (!hasAsyncTo) {
        if (started || hasFluidValue(prevTo)) {
          anim.values = node.getPayload();
          anim.toValues = hasFluidValue(to2) ? null : goalType == AnimatedString ? [1] : toArray$3(goal);
        }
        if (anim.immediate != immediate) {
          anim.immediate = immediate;
          if (!immediate && !reset) {
            this._set(prevTo);
          }
        }
        if (started) {
          const {
            onRest
          } = anim;
          each(ACTIVE_EVENTS, (type2) => mergeActiveFn(this, props, type2));
          const result = getFinishedResult(this, checkFinished(this, prevTo));
          flushCalls(this._pendingCalls, result);
          this._pendingCalls.add(resolve);
          if (anim.changed)
            raf.batchedUpdates(() => {
              anim.changed = !reset;
              onRest == null ? void 0 : onRest(result, this);
              if (reset) {
                callProp(defaultProps2.onRest, result);
              } else {
                anim.onStart == null ? void 0 : anim.onStart(result, this);
              }
            });
        }
      }
      if (reset) {
        this._set(value);
      }
      if (hasAsyncTo) {
        resolve(runAsync(props.to, props, this._state, this));
      } else if (started) {
        this._start();
      } else if (isAnimating(this) && !hasToChanged) {
        this._pendingCalls.add(resolve);
      } else {
        resolve(getNoopResult(value));
      }
    }
    _focus(value) {
      const anim = this.animation;
      if (value !== anim.to) {
        if (getFluidObservers(this)) {
          this._detach();
        }
        anim.to = value;
        if (getFluidObservers(this)) {
          this._attach();
        }
      }
    }
    _attach() {
      let priority2 = 0;
      const {
        to: to2
      } = this.animation;
      if (hasFluidValue(to2)) {
        addFluidObserver(to2, this);
        if (isFrameValue(to2)) {
          priority2 = to2.priority + 1;
        }
      }
      this.priority = priority2;
    }
    _detach() {
      const {
        to: to2
      } = this.animation;
      if (hasFluidValue(to2)) {
        removeFluidObserver(to2, this);
      }
    }
    _set(arg, idle = true) {
      const value = getFluidValue(arg);
      if (!is.und(value)) {
        const oldNode = getAnimated(this);
        if (!oldNode || !isEqual(value, oldNode.getValue())) {
          const nodeType = getAnimatedType(value);
          if (!oldNode || oldNode.constructor != nodeType) {
            setAnimated(this, nodeType.create(value));
          } else {
            oldNode.setValue(value);
          }
          if (oldNode) {
            raf.batchedUpdates(() => {
              this._onChange(value, idle);
            });
          }
        }
      }
      return getAnimated(this);
    }
    _onStart() {
      const anim = this.animation;
      if (!anim.changed) {
        anim.changed = true;
        sendEvent(this, "onStart", getFinishedResult(this, checkFinished(this, anim.to)), this);
      }
    }
    _onChange(value, idle) {
      if (!idle) {
        this._onStart();
        callProp(this.animation.onChange, value, this);
      }
      callProp(this.defaultProps.onChange, value, this);
      super._onChange(value, idle);
    }
    _start() {
      const anim = this.animation;
      getAnimated(this).reset(getFluidValue(anim.to));
      if (!anim.immediate) {
        anim.fromValues = anim.values.map((node) => node.lastPosition);
      }
      if (!isAnimating(this)) {
        setActiveBit(this, true);
        if (!isPaused(this)) {
          this._resume();
        }
      }
    }
    _resume() {
      if (globals.skipAnimation) {
        this.finish();
      } else {
        frameLoop.start(this);
      }
    }
    _stop(goal, cancel) {
      if (isAnimating(this)) {
        setActiveBit(this, false);
        const anim = this.animation;
        each(anim.values, (node) => {
          node.done = true;
        });
        if (anim.toValues) {
          anim.onChange = anim.onPause = anim.onResume = void 0;
        }
        callFluidObservers(this, {
          type: "idle",
          parent: this
        });
        const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal != null ? goal : anim.to));
        flushCalls(this._pendingCalls, result);
        if (anim.changed) {
          anim.changed = false;
          sendEvent(this, "onRest", result, this);
        }
      }
    }
  }
  function checkFinished(target, to2) {
    const goal = computeGoal(to2);
    const value = computeGoal(target.get());
    return isEqual(value, goal);
  }
  function createLoopUpdate(props, loop2 = props.loop, to2 = props.to) {
    let loopRet = callProp(loop2);
    if (loopRet) {
      const overrides = loopRet !== true && inferTo(loopRet);
      const reverse = (overrides || props).reverse;
      const reset = !overrides || overrides.reset;
      return createUpdate(_extends$1({}, props, {
        loop: loop2,
        default: false,
        pause: void 0,
        to: !reverse || isAsyncTo(to2) ? to2 : void 0,
        from: reset ? props.from : void 0,
        reset
      }, overrides));
    }
  }
  function createUpdate(props) {
    const {
      to: to2,
      from
    } = props = inferTo(props);
    const keys = /* @__PURE__ */ new Set();
    if (is.obj(to2))
      findDefined(to2, keys);
    if (is.obj(from))
      findDefined(from, keys);
    props.keys = keys.size ? Array.from(keys) : null;
    return props;
  }
  function declareUpdate(props) {
    const update2 = createUpdate(props);
    if (is.und(update2.default)) {
      update2.default = getDefaultProps(update2);
    }
    return update2;
  }
  function findDefined(values, keys) {
    eachProp(values, (value, key) => value != null && keys.add(key));
  }
  const ACTIVE_EVENTS = ["onStart", "onRest", "onChange", "onPause", "onResume"];
  function mergeActiveFn(target, props, type2) {
    target.animation[type2] = props[type2] !== getDefaultProp(props, type2) ? resolveProp(props[type2], target.key) : void 0;
  }
  function sendEvent(target, type2, ...args) {
    var _target$animation$typ, _target$animation, _target$defaultProps$, _target$defaultProps;
    (_target$animation$typ = (_target$animation = target.animation)[type2]) == null ? void 0 : _target$animation$typ.call(_target$animation, ...args);
    (_target$defaultProps$ = (_target$defaultProps = target.defaultProps)[type2]) == null ? void 0 : _target$defaultProps$.call(_target$defaultProps, ...args);
  }
  const BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
  let nextId = 1;
  class Controller {
    constructor(props, flush2) {
      this.id = nextId++;
      this.springs = {};
      this.queue = [];
      this.ref = void 0;
      this._flush = void 0;
      this._initialProps = void 0;
      this._lastAsyncId = 0;
      this._active = /* @__PURE__ */ new Set();
      this._changed = /* @__PURE__ */ new Set();
      this._started = false;
      this._item = void 0;
      this._state = {
        paused: false,
        pauseQueue: /* @__PURE__ */ new Set(),
        resumeQueue: /* @__PURE__ */ new Set(),
        timeouts: /* @__PURE__ */ new Set()
      };
      this._events = {
        onStart: /* @__PURE__ */ new Map(),
        onChange: /* @__PURE__ */ new Map(),
        onRest: /* @__PURE__ */ new Map()
      };
      this._onFrame = this._onFrame.bind(this);
      if (flush2) {
        this._flush = flush2;
      }
      if (props) {
        this.start(_extends$1({
          default: true
        }, props));
      }
    }
    get idle() {
      return !this._state.asyncTo && Object.values(this.springs).every((spring) => {
        return spring.idle && !spring.isDelayed && !spring.isPaused;
      });
    }
    get item() {
      return this._item;
    }
    set item(item) {
      this._item = item;
    }
    get() {
      const values = {};
      this.each((spring, key) => values[key] = spring.get());
      return values;
    }
    set(values) {
      for (const key in values) {
        const value = values[key];
        if (!is.und(value)) {
          this.springs[key].set(value);
        }
      }
    }
    update(props) {
      if (props) {
        this.queue.push(createUpdate(props));
      }
      return this;
    }
    start(props) {
      let {
        queue
      } = this;
      if (props) {
        queue = toArray$3(props).map(createUpdate);
      } else {
        this.queue = [];
      }
      if (this._flush) {
        return this._flush(this, queue);
      }
      prepareKeys(this, queue);
      return flushUpdateQueue(this, queue);
    }
    stop(arg, keys) {
      if (arg !== !!arg) {
        keys = arg;
      }
      if (keys) {
        const springs = this.springs;
        each(toArray$3(keys), (key) => springs[key].stop(!!arg));
      } else {
        stopAsync(this._state, this._lastAsyncId);
        this.each((spring) => spring.stop(!!arg));
      }
      return this;
    }
    pause(keys) {
      if (is.und(keys)) {
        this.start({
          pause: true
        });
      } else {
        const springs = this.springs;
        each(toArray$3(keys), (key) => springs[key].pause());
      }
      return this;
    }
    resume(keys) {
      if (is.und(keys)) {
        this.start({
          pause: false
        });
      } else {
        const springs = this.springs;
        each(toArray$3(keys), (key) => springs[key].resume());
      }
      return this;
    }
    each(iterator) {
      eachProp(this.springs, iterator);
    }
    _onFrame() {
      const {
        onStart,
        onChange,
        onRest
      } = this._events;
      const active = this._active.size > 0;
      const changed = this._changed.size > 0;
      if (active && !this._started || changed && !this._started) {
        this._started = true;
        flush(onStart, ([onStart2, result]) => {
          result.value = this.get();
          onStart2(result, this, this._item);
        });
      }
      const idle = !active && this._started;
      const values = changed || idle && onRest.size ? this.get() : null;
      if (changed && onChange.size) {
        flush(onChange, ([onChange2, result]) => {
          result.value = values;
          onChange2(result, this, this._item);
        });
      }
      if (idle) {
        this._started = false;
        flush(onRest, ([onRest2, result]) => {
          result.value = values;
          onRest2(result, this, this._item);
        });
      }
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._changed.add(event.parent);
        if (!event.idle) {
          this._active.add(event.parent);
        }
      } else if (event.type == "idle") {
        this._active.delete(event.parent);
      } else
        return;
      raf.onFrame(this._onFrame);
    }
  }
  function flushUpdateQueue(ctrl, queue) {
    return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then((results) => getCombinedResult(ctrl, results));
  }
  async function flushUpdate(ctrl, props, isLoop) {
    const {
      keys,
      to: to2,
      from,
      loop: loop2,
      onRest,
      onResolve
    } = props;
    const defaults2 = is.obj(props.default) && props.default;
    if (loop2) {
      props.loop = false;
    }
    if (to2 === false)
      props.to = null;
    if (from === false)
      props.from = null;
    const asyncTo = is.arr(to2) || is.fun(to2) ? to2 : void 0;
    if (asyncTo) {
      props.to = void 0;
      props.onRest = void 0;
      if (defaults2) {
        defaults2.onRest = void 0;
      }
    } else {
      each(BATCHED_EVENTS, (key) => {
        const handler = props[key];
        if (is.fun(handler)) {
          const queue = ctrl["_events"][key];
          props[key] = ({
            finished,
            cancelled
          }) => {
            const result2 = queue.get(handler);
            if (result2) {
              if (!finished)
                result2.finished = false;
              if (cancelled)
                result2.cancelled = true;
            } else {
              queue.set(handler, {
                value: null,
                finished: finished || false,
                cancelled: cancelled || false
              });
            }
          };
          if (defaults2) {
            defaults2[key] = props[key];
          }
        }
      });
    }
    const state = ctrl["_state"];
    if (props.pause === !state.paused) {
      state.paused = props.pause;
      flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
    } else if (state.paused) {
      props.pause = true;
    }
    const promises = (keys || Object.keys(ctrl.springs)).map((key) => ctrl.springs[key].start(props));
    const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
    if (asyncTo || cancel && state.asyncId) {
      promises.push(scheduleProps(++ctrl["_lastAsyncId"], {
        props,
        state,
        actions: {
          pause: noop,
          resume: noop,
          start(props2, resolve) {
            if (cancel) {
              stopAsync(state, ctrl["_lastAsyncId"]);
              resolve(getCancelledResult(ctrl));
            } else {
              props2.onRest = onRest;
              resolve(runAsync(asyncTo, props2, state, ctrl));
            }
          }
        }
      }));
    }
    if (state.paused) {
      await new Promise((resume) => {
        state.resumeQueue.add(resume);
      });
    }
    const result = getCombinedResult(ctrl, await Promise.all(promises));
    if (loop2 && result.finished && !(isLoop && result.noop)) {
      const nextProps = createLoopUpdate(props, loop2, to2);
      if (nextProps) {
        prepareKeys(ctrl, [nextProps]);
        return flushUpdate(ctrl, nextProps, true);
      }
    }
    if (onResolve) {
      raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
    }
    return result;
  }
  function getSprings(ctrl, props) {
    const springs = _extends$1({}, ctrl.springs);
    if (props) {
      each(toArray$3(props), (props2) => {
        if (is.und(props2.keys)) {
          props2 = createUpdate(props2);
        }
        if (!is.obj(props2.to)) {
          props2 = _extends$1({}, props2, {
            to: void 0
          });
        }
        prepareSprings(springs, props2, (key) => {
          return createSpring(key);
        });
      });
    }
    setSprings(ctrl, springs);
    return springs;
  }
  function setSprings(ctrl, springs) {
    eachProp(springs, (spring, key) => {
      if (!ctrl.springs[key]) {
        ctrl.springs[key] = spring;
        addFluidObserver(spring, ctrl);
      }
    });
  }
  function createSpring(key, observer) {
    const spring = new SpringValue();
    spring.key = key;
    if (observer) {
      addFluidObserver(spring, observer);
    }
    return spring;
  }
  function prepareSprings(springs, props, create) {
    if (props.keys) {
      each(props.keys, (key) => {
        const spring = springs[key] || (springs[key] = create(key));
        spring["_prepareNode"](props);
      });
    }
  }
  function prepareKeys(ctrl, queue) {
    each(queue, (props) => {
      prepareSprings(ctrl.springs, props, (key) => {
        return createSpring(key, ctrl);
      });
    });
  }
  function _objectWithoutPropertiesLoose$1(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  const _excluded$3$1 = ["children"];
  const SpringContext = (_ref) => {
    let {
      children
    } = _ref, props = _objectWithoutPropertiesLoose$1(_ref, _excluded$3$1);
    const inherited = React.useContext(ctx);
    const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
    props = useMemoOne(() => ({
      pause,
      immediate
    }), [pause, immediate]);
    const {
      Provider
    } = ctx;
    return React__namespace.createElement(Provider, {
      value: props
    }, children);
  };
  const ctx = makeContext(SpringContext, {});
  SpringContext.Provider = ctx.Provider;
  SpringContext.Consumer = ctx.Consumer;
  function makeContext(target, init) {
    Object.assign(target, React__namespace.createContext(init));
    target.Provider._context = target;
    target.Consumer._context = target;
    return target;
  }
  const SpringRef = () => {
    const current = [];
    const SpringRef2 = function SpringRef3(props) {
      deprecateDirectCall();
      const results = [];
      each(current, (ctrl, i) => {
        if (is.und(props)) {
          results.push(ctrl.start());
        } else {
          const update2 = _getProps(props, ctrl, i);
          if (update2) {
            results.push(ctrl.start(update2));
          }
        }
      });
      return results;
    };
    SpringRef2.current = current;
    SpringRef2.add = function(ctrl) {
      if (!current.includes(ctrl)) {
        current.push(ctrl);
      }
    };
    SpringRef2.delete = function(ctrl) {
      const i = current.indexOf(ctrl);
      if (~i)
        current.splice(i, 1);
    };
    SpringRef2.pause = function() {
      each(current, (ctrl) => ctrl.pause(...arguments));
      return this;
    };
    SpringRef2.resume = function() {
      each(current, (ctrl) => ctrl.resume(...arguments));
      return this;
    };
    SpringRef2.set = function(values) {
      each(current, (ctrl) => ctrl.set(values));
    };
    SpringRef2.start = function(props) {
      const results = [];
      each(current, (ctrl, i) => {
        if (is.und(props)) {
          results.push(ctrl.start());
        } else {
          const update2 = this._getProps(props, ctrl, i);
          if (update2) {
            results.push(ctrl.start(update2));
          }
        }
      });
      return results;
    };
    SpringRef2.stop = function() {
      each(current, (ctrl) => ctrl.stop(...arguments));
      return this;
    };
    SpringRef2.update = function(props) {
      each(current, (ctrl, i) => ctrl.update(this._getProps(props, ctrl, i)));
      return this;
    };
    const _getProps = function _getProps2(arg, ctrl, index2) {
      return is.fun(arg) ? arg(index2, ctrl) : arg;
    };
    SpringRef2._getProps = _getProps;
    return SpringRef2;
  };
  function useSprings(length, props, deps) {
    const propsFn = is.fun(props) && props;
    if (propsFn && !deps)
      deps = [];
    const ref = React.useMemo(() => propsFn || arguments.length == 3 ? SpringRef() : void 0, []);
    const layoutId = React.useRef(0);
    const forceUpdate = useForceUpdate();
    const state = React.useMemo(() => ({
      ctrls: [],
      queue: [],
      flush(ctrl, updates2) {
        const springs2 = getSprings(ctrl, updates2);
        const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);
        return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {
          setSprings(ctrl, springs2);
          state.queue.push(() => {
            resolve(flushUpdateQueue(ctrl, updates2));
          });
          forceUpdate();
        });
      }
    }), []);
    const ctrls = React.useRef([...state.ctrls]);
    const updates = [];
    const prevLength = usePrev(length) || 0;
    React.useMemo(() => {
      each(ctrls.current.slice(length, prevLength), (ctrl) => {
        detachRefs(ctrl, ref);
        ctrl.stop(true);
      });
      ctrls.current.length = length;
      declareUpdates(prevLength, length);
    }, [length]);
    React.useMemo(() => {
      declareUpdates(0, Math.min(prevLength, length));
    }, deps);
    function declareUpdates(startIndex, endIndex) {
      for (let i = startIndex; i < endIndex; i++) {
        const ctrl = ctrls.current[i] || (ctrls.current[i] = new Controller(null, state.flush));
        const update2 = propsFn ? propsFn(i, ctrl) : props[i];
        if (update2) {
          updates[i] = declareUpdate(update2);
        }
      }
    }
    const springs = ctrls.current.map((ctrl, i) => getSprings(ctrl, updates[i]));
    const context = React.useContext(SpringContext);
    const prevContext = usePrev(context);
    const hasContext = context !== prevContext && hasProps(context);
    useLayoutEffect(() => {
      layoutId.current++;
      state.ctrls = ctrls.current;
      const {
        queue
      } = state;
      if (queue.length) {
        state.queue = [];
        each(queue, (cb) => cb());
      }
      each(ctrls.current, (ctrl, i) => {
        ref == null ? void 0 : ref.add(ctrl);
        if (hasContext) {
          ctrl.start({
            default: context
          });
        }
        const update2 = updates[i];
        if (update2) {
          replaceRef(ctrl, update2.ref);
          if (ctrl.ref) {
            ctrl.queue.push(update2);
          } else {
            ctrl.start(update2);
          }
        }
      });
    });
    useOnce(() => () => {
      each(state.ctrls, (ctrl) => ctrl.stop(true));
    });
    const values = springs.map((x2) => _extends$1({}, x2));
    return ref ? [values, ref] : values;
  }
  function useSpring(props, deps) {
    const isFn = is.fun(props);
    const [[values], ref] = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps);
    return isFn || arguments.length == 2 ? [values, ref] : values;
  }
  let TransitionPhase;
  (function(TransitionPhase2) {
    TransitionPhase2["MOUNT"] = "mount";
    TransitionPhase2["ENTER"] = "enter";
    TransitionPhase2["UPDATE"] = "update";
    TransitionPhase2["LEAVE"] = "leave";
  })(TransitionPhase || (TransitionPhase = {}));
  class Interpolation extends FrameValue {
    constructor(source, args) {
      super();
      this.key = void 0;
      this.idle = true;
      this.calc = void 0;
      this._active = /* @__PURE__ */ new Set();
      this.source = source;
      this.calc = createInterpolator(...args);
      const value = this._get();
      const nodeType = getAnimatedType(value);
      setAnimated(this, nodeType.create(value));
    }
    advance(_dt) {
      const value = this._get();
      const oldValue = this.get();
      if (!isEqual(value, oldValue)) {
        getAnimated(this).setValue(value);
        this._onChange(value, this.idle);
      }
      if (!this.idle && checkIdle(this._active)) {
        becomeIdle(this);
      }
    }
    _get() {
      const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray$3(getFluidValue(this.source));
      return this.calc(...inputs);
    }
    _start() {
      if (this.idle && !checkIdle(this._active)) {
        this.idle = false;
        each(getPayload(this), (node) => {
          node.done = false;
        });
        if (globals.skipAnimation) {
          raf.batchedUpdates(() => this.advance());
          becomeIdle(this);
        } else {
          frameLoop.start(this);
        }
      }
    }
    _attach() {
      let priority2 = 1;
      each(toArray$3(this.source), (source) => {
        if (hasFluidValue(source)) {
          addFluidObserver(source, this);
        }
        if (isFrameValue(source)) {
          if (!source.idle) {
            this._active.add(source);
          }
          priority2 = Math.max(priority2, source.priority + 1);
        }
      });
      this.priority = priority2;
      this._start();
    }
    _detach() {
      each(toArray$3(this.source), (source) => {
        if (hasFluidValue(source)) {
          removeFluidObserver(source, this);
        }
      });
      this._active.clear();
      becomeIdle(this);
    }
    eventObserved(event) {
      if (event.type == "change") {
        if (event.idle) {
          this.advance();
        } else {
          this._active.add(event.parent);
          this._start();
        }
      } else if (event.type == "idle") {
        this._active.delete(event.parent);
      } else if (event.type == "priority") {
        this.priority = toArray$3(this.source).reduce((highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1), 0);
      }
    }
  }
  function isIdle(source) {
    return source.idle !== false;
  }
  function checkIdle(active) {
    return !active.size || Array.from(active).every(isIdle);
  }
  function becomeIdle(self2) {
    if (!self2.idle) {
      self2.idle = true;
      each(getPayload(self2), (node) => {
        node.done = true;
      });
      callFluidObservers(self2, {
        type: "idle",
        parent: self2
      });
    }
  }
  globals.assign({
    createStringInterpolator,
    to: (source, args) => new Interpolation(source, args)
  });
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  const _excluded$2$1 = ["style", "children", "scrollTop", "scrollLeft"];
  const isCustomPropRE = /^--/;
  function dangerousStyleValue(name, value) {
    if (value == null || typeof value === "boolean" || value === "")
      return "";
    if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
      return value + "px";
    return ("" + value).trim();
  }
  const attributeCache = {};
  function applyAnimatedValues(instance, props) {
    if (!instance.nodeType || !instance.setAttribute) {
      return false;
    }
    const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
    const _ref = props, {
      style,
      children,
      scrollTop,
      scrollLeft
    } = _ref, attributes = _objectWithoutPropertiesLoose(_ref, _excluded$2$1);
    const values = Object.values(attributes);
    const names = Object.keys(attributes).map((name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, (n2) => "-" + n2.toLowerCase())));
    if (children !== void 0) {
      instance.textContent = children;
    }
    for (let name in style) {
      if (style.hasOwnProperty(name)) {
        const value = dangerousStyleValue(name, style[name]);
        if (isCustomPropRE.test(name)) {
          instance.style.setProperty(name, value);
        } else {
          instance.style[name] = value;
        }
      }
    }
    names.forEach((name, i) => {
      instance.setAttribute(name, values[i]);
    });
    if (scrollTop !== void 0) {
      instance.scrollTop = scrollTop;
    }
    if (scrollLeft !== void 0) {
      instance.scrollLeft = scrollLeft;
    }
  }
  let isUnitlessNumber = {
    animationIterationCount: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  const prefixKey = (prefix2, key) => prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
  const prefixes = ["Webkit", "Ms", "Moz", "O"];
  isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
    prefixes.forEach((prefix2) => acc[prefixKey(prefix2, prop)] = acc[prop]);
    return acc;
  }, isUnitlessNumber);
  const _excluded$1$1 = ["x", "y", "z"];
  const domTransforms = /^(matrix|translate|scale|rotate|skew)/;
  const pxTransforms = /^(translate)/;
  const degTransforms = /^(rotate|skew)/;
  const addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
  const isValueIdentity = (value, id) => is.arr(value) ? value.every((v2) => isValueIdentity(v2, id)) : is.num(value) ? value === id : parseFloat(value) === id;
  class AnimatedStyle extends AnimatedObject {
    constructor(_ref) {
      let {
        x: x2,
        y: y2,
        z: z2
      } = _ref, style = _objectWithoutPropertiesLoose(_ref, _excluded$1$1);
      const inputs = [];
      const transforms = [];
      if (x2 || y2 || z2) {
        inputs.push([x2 || 0, y2 || 0, z2 || 0]);
        transforms.push((xyz) => [`translate3d(${xyz.map((v2) => addUnit(v2, "px")).join(",")})`, isValueIdentity(xyz, 0)]);
      }
      eachProp(style, (value, key) => {
        if (key === "transform") {
          inputs.push([value || ""]);
          transforms.push((transform) => [transform, transform === ""]);
        } else if (domTransforms.test(key)) {
          delete style[key];
          if (is.und(value))
            return;
          const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
          inputs.push(toArray$3(value));
          transforms.push(key === "rotate3d" ? ([x3, y3, z3, deg]) => [`rotate3d(${x3},${y3},${z3},${addUnit(deg, unit)})`, isValueIdentity(deg, 0)] : (input) => [`${key}(${input.map((v2) => addUnit(v2, unit)).join(",")})`, isValueIdentity(input, key.startsWith("scale") ? 1 : 0)]);
        }
      });
      if (inputs.length) {
        style.transform = new FluidTransform(inputs, transforms);
      }
      super(style);
    }
  }
  class FluidTransform extends FluidValue {
    constructor(inputs, transforms) {
      super();
      this._value = null;
      this.inputs = inputs;
      this.transforms = transforms;
    }
    get() {
      return this._value || (this._value = this._get());
    }
    _get() {
      let transform = "";
      let identity2 = true;
      each(this.inputs, (input, i) => {
        const arg1 = getFluidValue(input[0]);
        const [t2, id] = this.transforms[i](is.arr(arg1) ? arg1 : input.map(getFluidValue));
        transform += " " + t2;
        identity2 = identity2 && id;
      });
      return identity2 ? "none" : transform;
    }
    observerAdded(count) {
      if (count == 1)
        each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && addFluidObserver(value, this)));
    }
    observerRemoved(count) {
      if (count == 0)
        each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && removeFluidObserver(value, this)));
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._value = null;
      }
      callFluidObservers(this, event);
    }
  }
  const primitives = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"];
  const _excluded$3 = ["scrollTop", "scrollLeft"];
  globals.assign({
    batchedUpdates: ReactDOM.unstable_batchedUpdates,
    createStringInterpolator,
    colors
  });
  const host = createHost(primitives, {
    applyAnimatedValues,
    createAnimatedStyle: (style) => new AnimatedStyle(style),
    getComponentProps: (_ref) => {
      let props = _objectWithoutPropertiesLoose(_ref, _excluded$3);
      return props;
    }
  });
  const animated = host.animated;
  const useDragAndPinch = createUseGesture([dragAction, pinchAction]);
  function bound(position, min, max) {
    let ret = position;
    if (min !== void 0) {
      ret = Math.max(position, min);
    }
    if (max !== void 0) {
      ret = Math.min(ret, max);
    }
    return ret;
  }
  function rubberband(distance, dimension, constant) {
    return distance * dimension * constant / (dimension + constant * distance);
  }
  function rubberbandIfOutOfBounds(position, min, max, dimension, constant = 0.15) {
    if (constant === 0)
      return bound(position, min, max);
    if (position < min)
      return -rubberband(min - position, dimension, constant) + min;
    if (position > max)
      return +rubberband(position - max, dimension, constant) + max;
    return position;
  }
  const [bem$1c] = createNamespace("image-preview");
  const Slide = (props) => {
    const { dragLockRef } = props;
    const controlRef = React.useRef(null);
    const imgRef = React.useRef(null);
    const [{ zoom, x: x2, y: y2 }, api] = useSpring(() => ({
      zoom: 1,
      x: 0,
      y: 0,
      config: { tension: 200 }
    }));
    const pinchLockRef = React.useRef(false);
    function boundXY([x22, y22], rubberband2) {
      const currentZoom = zoom.get();
      let xOffset = 0, yOffset = 0;
      if (imgRef.current && controlRef.current) {
        xOffset = ((currentZoom * imgRef.current.width || 0) - controlRef.current.clientWidth) / 2;
        yOffset = ((currentZoom * imgRef.current.height || 0) - controlRef.current.clientHeight) / 2;
      }
      xOffset = xOffset > 0 ? xOffset : 0;
      yOffset = yOffset > 0 ? yOffset : 0;
      const bounds = {
        left: -xOffset,
        right: xOffset,
        top: -yOffset,
        bottom: yOffset
      };
      if (rubberband2) {
        return [
          rubberbandIfOutOfBounds(x22, bounds.left, bounds.right, currentZoom * 50),
          rubberbandIfOutOfBounds(y22, bounds.top, bounds.bottom, currentZoom * 50)
        ];
      } else {
        return [
          bound(x22, bounds.left, bounds.right),
          bound(y22, bounds.top, bounds.bottom)
        ];
      }
    }
    useDragAndPinch({
      onDrag: (state) => {
        if (state.tap && state.elapsedTime > 0 && state.elapsedTime < 1e3) {
          props.onTap();
          return;
        }
        const currentZoom = zoom.get();
        if (dragLockRef) {
          dragLockRef.current = currentZoom !== 1;
        }
        if (!pinchLockRef.current && currentZoom <= 1) {
          api.start({
            x: 0,
            y: 0
          });
        } else {
          if (state.last) {
            const [x22, y22] = boundXY([
              state.offset[0] + state.velocity[0] * state.direction[0] * 200,
              state.offset[1] + state.velocity[1] * state.direction[1] * 200
            ], false);
            api.start({
              x: x22,
              y: y22
            });
          } else {
            const [x22, y22] = boundXY(state.offset, true);
            api.start({
              x: x22,
              y: y22,
              immediate: true
            });
          }
        }
      },
      onPinch: (state) => {
        var _a;
        pinchLockRef.current = !state.last;
        const [d2] = state.offset;
        if (d2 < 0)
          return;
        const nextZoom = state.last ? bound(d2, 1, props.maxZoom) : d2;
        api.start({
          zoom: nextZoom,
          immediate: !state.last
        });
        (_a = props.onZoomChange) == null ? void 0 : _a.call(props, nextZoom);
        if (state.last && nextZoom <= 1) {
          api.start({
            x: 0,
            y: 0
          });
          if (dragLockRef) {
            dragLockRef.current = false;
          }
        } else {
          if (dragLockRef) {
            dragLockRef.current = true;
          }
        }
      }
    }, {
      target: controlRef,
      drag: {
        from: () => [x2.get(), y2.get()],
        pointer: { touch: true }
      },
      pinch: {
        from: () => [zoom.get(), 0],
        pointer: { touch: true }
      }
    });
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$1c("slide")),
      onPointerMove: (e2) => {
        if (zoom.get() !== 1) {
          e2.stopPropagation();
        }
      }
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$1c("control")),
      ref: controlRef
    }, /* @__PURE__ */ React__default["default"].createElement(animated.div, {
      className: clsx(bem$1c("image-wrapper")),
      style: {
        translateX: x2,
        translateY: y2,
        scale: zoom
      }
    }, /* @__PURE__ */ React__default["default"].createElement("img", {
      ref: imgRef,
      src: props.image,
      draggable: false,
      alt: props.image
    }))));
  };
  const [bem$1b] = createNamespace("image-preview");
  const Slides = React.forwardRef((props, ref) => {
    const slideWidth = window.innerWidth + unitToPx(16);
    const [{ x: x2 }, api] = useSpring(() => ({
      x: props.defaultIndex * slideWidth,
      config: { tension: 250, clamp: true }
    }));
    const count = props.images.length;
    useUpdateEffect(() => {
      swipeTo(props.defaultIndex, true);
    }, [props.defaultIndex]);
    function swipeTo(index2, immediate = false) {
      var _a;
      const i = bound(index2, 0, count - 1);
      (_a = props.onIndexChange) == null ? void 0 : _a.call(props, i);
      api.start({
        x: i * slideWidth,
        immediate
      });
    }
    React.useImperativeHandle(ref, () => ({
      swipeTo
    }));
    const dragLockRef = React.useRef(false);
    const bind = useDrag((state) => {
      if (dragLockRef.current)
        return;
      const [offsetX] = state.offset;
      if (state.last) {
        const minIndex = Math.floor(offsetX / slideWidth);
        const maxIndex = minIndex + 1;
        const velocityOffset = Math.min(state.velocity[0] * 2e3, slideWidth) * state.direction[0];
        swipeTo(bound(Math.round((offsetX + velocityOffset) / slideWidth), minIndex, maxIndex));
      } else {
        api.start({
          x: offsetX,
          immediate: true
        });
      }
    }, {
      transform: ([x22, y2]) => [-x22, y2],
      from: () => [x2.get(), 0],
      bounds: () => {
        return {
          left: 0,
          right: (count - 1) * slideWidth
        };
      },
      rubberband: true,
      axis: "x",
      pointer: { touch: true }
    });
    return /* @__PURE__ */ React__default["default"].createElement("div", __spreadValues({
      className: clsx(bem$1b("slides"))
    }, bind()), /* @__PURE__ */ React__default["default"].createElement(animated.div, {
      className: clsx(bem$1b("slides-inner")),
      style: { x: x2.to((x22) => -x22) }
    }, props.images.map((image, idx) => /* @__PURE__ */ React__default["default"].createElement(Slide, {
      key: `${image}${idx}`,
      image,
      onTap: props.onTap,
      maxZoom: props.maxZoom,
      onZoomChange: (zoom) => {
        if (zoom !== 1) {
          const index2 = Math.round(x2.get() / slideWidth);
          api.start({
            x: index2 * slideWidth
          });
        }
      },
      dragLockRef
    }))));
  });
  const [bem$1a] = createNamespace("indicator");
  const SwiperPagIndicator = React__default["default"].memo((_i) => {
    var _j = _i, { vertical } = _j, props = __objRest(_j, ["vertical"]);
    const dots = [];
    for (let i = 0; i < props.total; i++) {
      dots.push(/* @__PURE__ */ React__default["default"].createElement("div", {
        key: i,
        className: clsx(bem$1a("dot", {
          active: props.current === i
        }))
      }));
    }
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, bem$1a({ vertical })),
      style: props.style
    }, dots);
  });
  const [bem$19] = createNamespace("image-preview");
  const ImagePreview$1 = React__default["default"].forwardRef((props, ref) => {
    const slidesRef = React.useRef(null);
    const [active, setActive] = React.useState(() => props.startPosition);
    const currentImage = React__default["default"].useMemo(() => props.images[active], [active, props.images]);
    const onSwipeChange = (idx) => {
      var _a;
      if (active !== idx) {
        setActive(idx);
        (_a = props.onChange) == null ? void 0 : _a.call(props, idx);
      }
    };
    const onClose = () => {
      var _a;
      (_a = props.onClose) == null ? void 0 : _a.call(props, { url: currentImage, index: active });
    };
    const renderContent = () => /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$19("content"))
    }, props.images && /* @__PURE__ */ React__default["default"].createElement(Slides, {
      ref: slidesRef,
      defaultIndex: props.startPosition,
      onIndexChange: onSwipeChange,
      images: props.images,
      onTap: () => {
        if (!props.closeOnlyClickCloseIcon) {
          onClose();
        }
      },
      maxZoom: props.maxZoom
    }));
    const renderClose = () => {
      if (props.closeable) {
        return React__default["default"].cloneElement(props.closeIcon, {
          className: clsx(bem$19("close-icon", props.closeIconPosition)),
          onClick: onClose
        });
      }
      return null;
    };
    const renderIndex = () => {
      if (props.showIndex) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$19("index"))
        }, props.indexRender ? props.indexRender({ index: active, len: props.images.length }) : `${active + 1} / ${props.images.length}`);
      }
      return null;
    };
    const renderIndicator = () => {
      if (props.showIndicators) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$19("indicator"))
        }, /* @__PURE__ */ React__default["default"].createElement(SwiperPagIndicator, {
          total: props.images.length,
          current: active
        }));
      }
      return null;
    };
    React__default["default"].useImperativeHandle(ref, () => ({
      swipeTo: (index2, immediate) => {
        var _a;
        setActive(index2);
        (_a = slidesRef.current) == null ? void 0 : _a.swipeTo(index2, immediate);
      }
    }));
    return /* @__PURE__ */ React__default["default"].createElement(Popup, __spreadValues({
      className: clsx(bem$19(), props.className),
      overlayClass: clsx(bem$19("overlay"))
    }, pick(props, [
      "visible",
      "overlayStyle",
      "closeOnPopstate",
      "onClosed",
      "beforeClose",
      "teleport"
    ])), renderClose(), renderContent(), renderIndex(), renderIndicator());
  });
  ImagePreview$1.defaultProps = {
    overlay: true,
    showIndex: true,
    images: [],
    swipeDuration: 300,
    startPosition: 0,
    closeIconPosition: "top-right",
    showIndicators: false,
    closeOnlyClickCloseIcon: false,
    maxZoom: 3
  };
  const defaultConfig = {
    images: [],
    className: "",
    showIndex: true,
    closeable: false,
    closeIcon: /* @__PURE__ */ React__default["default"].createElement(SvgClear, null),
    startPosition: 0,
    swipeDuration: 300,
    closeOnPopstate: true,
    closeIconPosition: "top-right"
  };
  const open = (props) => {
    if (!canUseDom())
      return null;
    const _a = props, { onClose = noop$3, beforeClose } = _a, restProps = __objRest(_a, ["onClose", "beforeClose"]);
    const userContainer = resolveContainer(props.teleport);
    const container = document.createElement("div");
    userContainer.appendChild(container);
    let destroy = noop$3;
    const TempDialog = () => {
      const [visible, setVisible] = React.useState(false);
      React.useEffect(() => {
        setVisible(true);
      }, []);
      destroy = (p2) => {
        setVisible(false);
        if (onClose)
          onClose(p2);
      };
      const _afterClose = async (p2) => {
        if (await (beforeClose == null ? void 0 : beforeClose(0)) !== false) {
          destroy(p2);
          const unmountResult = unmount(container);
          if (unmountResult && container.parentNode) {
            container.parentNode.removeChild(container);
          }
          return true;
        }
        return false;
      };
      return /* @__PURE__ */ React__default["default"].createElement(ImagePreview$1, __spreadProps(__spreadValues(__spreadValues({}, defaultConfig), restProps), {
        visible,
        teleport: () => container,
        onClose: destroy,
        beforeClose: _afterClose
      }));
    };
    render(/* @__PURE__ */ React__default["default"].createElement(TempDialog, null), container);
    return destroy;
  };
  const ImagePreview = Object.assign(ImagePreview$1, {
    open
  });
  var index$K = "";
  const prefix = "rv-empty-network-";
  const renderStop = (color, offset2, opacity) => /* @__PURE__ */ React__default["default"].createElement("stop", {
    stopColor: color,
    offset: `${offset2}%`,
    stopOpacity: opacity
  });
  const Network = /* @__PURE__ */ React__default["default"].createElement("svg", {
    viewBox: "0 0 160 160"
  }, /* @__PURE__ */ React__default["default"].createElement("defs", null, /* @__PURE__ */ React__default["default"].createElement("linearGradient", {
    id: `${prefix}1`,
    x1: "64.022%",
    y1: "100%",
    x2: "64.022%",
    y2: "0%"
  }, renderStop("#FFF", 0, 0.5), renderStop("#F2F3F5", 100)), /* @__PURE__ */ React__default["default"].createElement("linearGradient", {
    id: `${prefix}2`,
    x1: "50%",
    y1: "0%",
    x2: "50%",
    y2: "84.459%"
  }, renderStop("#EBEDF0", 0), renderStop("#DCDEE0", 100, 0)), /* @__PURE__ */ React__default["default"].createElement("linearGradient", {
    id: `${prefix}3`,
    x1: "100%",
    y1: "0%",
    x2: "100%",
    y2: "100%"
  }, renderStop("#EAEDF0", 0), renderStop("#DCDEE0", 100)), /* @__PURE__ */ React__default["default"].createElement("linearGradient", {
    id: `${prefix}4`,
    x1: "100%",
    y1: "100%",
    x2: "100%",
    y2: "0%"
  }, renderStop("#EAEDF0", 0), renderStop("#DCDEE0", 100)), /* @__PURE__ */ React__default["default"].createElement("linearGradient", {
    id: `${prefix}5`,
    x1: "0%",
    y1: "43.982%",
    x2: "100%",
    y2: "54.703%"
  }, renderStop("#EAEDF0", 0), renderStop("#DCDEE0", 100)), /* @__PURE__ */ React__default["default"].createElement("linearGradient", {
    id: `${prefix}6`,
    x1: "94.535%",
    y1: "43.837%",
    x2: "5.465%",
    y2: "54.948%"
  }, renderStop("#EAEDF0", 0), renderStop("#DCDEE0", 100)), /* @__PURE__ */ React__default["default"].createElement("radialGradient", {
    id: `${prefix}7`,
    cx: "50%",
    cy: "0%",
    fx: "50%",
    fy: "0%",
    r: "100%",
    gradientTransform: "matrix(0 1 -.54835 0 .5 -.5)"
  }, renderStop("#EBEDF0", 0), renderStop("#FFF", 100, 0))), /* @__PURE__ */ React__default["default"].createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ React__default["default"].createElement("g", {
    opacity: ".8"
  }, /* @__PURE__ */ React__default["default"].createElement("path", {
    d: "M0 124V46h20v20h14v58H0z",
    fill: `url(#${prefix}1)`,
    transform: "matrix(-1 0 0 1 36 7)"
  }), /* @__PURE__ */ React__default["default"].createElement("path", {
    d: "M121 8h22.231v14H152v77.37h-31V8z",
    fill: `url(#${prefix}1)`,
    transform: "translate(2 7)"
  })), /* @__PURE__ */ React__default["default"].createElement("path", {
    fill: `url(#${prefix}7)`,
    d: "M0 139h160v21H0z"
  }), /* @__PURE__ */ React__default["default"].createElement("path", {
    d: "M37 18a7 7 0 013 13.326v26.742c0 1.23-.997 2.227-2.227 2.227h-1.546A2.227 2.227 0 0134 58.068V31.326A7 7 0 0137 18z",
    fill: `url(#${prefix}2)`,
    fillRule: "nonzero",
    transform: "translate(43 36)"
  }), /* @__PURE__ */ React__default["default"].createElement("g", {
    opacity: ".6",
    strokeLinecap: "round",
    strokeWidth: "7"
  }, /* @__PURE__ */ React__default["default"].createElement("path", {
    d: "M20.875 11.136a18.868 18.868 0 00-5.284 13.121c0 5.094 2.012 9.718 5.284 13.12",
    stroke: `url(#${prefix}3)`,
    transform: "translate(43 36)"
  }), /* @__PURE__ */ React__default["default"].createElement("path", {
    d: "M9.849 0C3.756 6.225 0 14.747 0 24.146c0 9.398 3.756 17.92 9.849 24.145",
    stroke: `url(#${prefix}3)`,
    transform: "translate(43 36)"
  }), /* @__PURE__ */ React__default["default"].createElement("path", {
    d: "M57.625 11.136a18.868 18.868 0 00-5.284 13.121c0 5.094 2.012 9.718 5.284 13.12",
    stroke: `url(#${prefix}4)`,
    transform: "rotate(-180 76.483 42.257)"
  }), /* @__PURE__ */ React__default["default"].createElement("path", {
    d: "M73.216 0c-6.093 6.225-9.849 14.747-9.849 24.146 0 9.398 3.756 17.92 9.849 24.145",
    stroke: `url(#${prefix}4)`,
    transform: "rotate(-180 89.791 42.146)"
  })), /* @__PURE__ */ React__default["default"].createElement("g", {
    transform: "translate(31 105)",
    fillRule: "nonzero"
  }, /* @__PURE__ */ React__default["default"].createElement("rect", {
    fill: `url(#${prefix}5)`,
    width: "98",
    height: "34",
    rx: "2"
  }), /* @__PURE__ */ React__default["default"].createElement("rect", {
    fill: "#FFF",
    x: "9",
    y: "8",
    width: "80",
    height: "18",
    rx: "1.114"
  }), /* @__PURE__ */ React__default["default"].createElement("rect", {
    fill: `url(#${prefix}6)`,
    x: "15",
    y: "12",
    width: "18",
    height: "6",
    rx: "1.114"
  }))));
  const PRESET_IMAGES = ["error", "search", "default"];
  const [bem$18] = createNamespace("empty");
  const Empty = (props) => {
    const renderImage = () => {
      let { image } = props;
      if (React.isValidElement(image)) {
        return image;
      }
      if (image === "network") {
        return Network;
      }
      if (PRESET_IMAGES.includes(image)) {
        image = `https://img.yzcdn.cn/vant/empty-image-${image}.png`;
      }
      return /* @__PURE__ */ React__default["default"].createElement("img", {
        src: image,
        alt: ""
      });
    };
    const renderDescription = () => {
      if (props.description) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$18("description"))
        }, props.description);
      }
      return null;
    };
    const renderBottom = () => {
      if (props.children) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$18("bottom"))
        }, props.children);
      }
      return null;
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, bem$18()),
      style: props.style
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$18("image")),
      style: getSizeStyle(props.imageSize)
    }, renderImage()), renderDescription(), renderBottom());
  };
  Empty.defaultProps = {
    image: "default"
  };
  var index$J = "";
  const [bem$17] = createNamespace("notify");
  const Notify = (_k) => {
    var _l = _k, {
      children
    } = _l, props = __objRest(_l, [
      "children"
    ]);
    const style = {
      color: props.color,
      background: props.background
    };
    return /* @__PURE__ */ React__default["default"].createElement(Popup, {
      visible: props.visible,
      style,
      overlay: false,
      position: "top",
      lockScroll: props.lockScroll,
      onClick: props.onClick,
      onClose: props.onClose,
      onClosed: props.onClosed,
      teleport: props.teleport
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$17([props.type]), props.className)
    }, children || props.message));
  };
  Notify.defaultProps = {
    type: "danger",
    duration: 3e3,
    color: "white",
    lockScroll: false
  };
  let lockCount = 0;
  function lockClick(lock) {
    if (lock) {
      if (!lockCount) {
        document.body.classList.add("rv-toast--unclickable");
      }
      lockCount += 1;
    } else if (lockCount) {
      lockCount -= 1;
      if (!lockCount) {
        document.body.classList.remove("rv-toast--unclickable");
      }
    }
  }
  const NotifyNamespace = {};
  function parseOptions$1(message) {
    return isObject$1(message) ? message : { message };
  }
  const notifyArray = [];
  function syncClear$1() {
    let fn = notifyArray.pop();
    while (fn) {
      fn();
      lockClick(false);
      fn = notifyArray.pop();
    }
  }
  function nextTickClear$1() {
    setTimeout(syncClear$1);
  }
  const show = (p2) => {
    if (!canUseDom())
      return null;
    const props = parseOptions$1(p2);
    const interProps = __spreadValues(__spreadValues({}, NotifyNamespace.currentOptions), props);
    const _a = interProps, { onClose = noop$3, duration } = _a, restProps = __objRest(_a, ["onClose", "duration"]);
    let timer = 0;
    const userContainer = resolveContainer(props.teleport);
    const container = document.createElement("div");
    userContainer.appendChild(container);
    let destroy = noop$3;
    const TempNotify = () => {
      const [visible, setVisible] = React.useState(false);
      destroy = () => {
        setVisible(false);
        if (onClose)
          onClose();
      };
      const internalOnClosed = () => {
        const unmountResult = unmount(container);
        if (unmountResult && container.parentNode) {
          container.parentNode.removeChild(container);
        }
      };
      const internalAfterClose = once$1(() => {
        internalOnClosed();
      });
      React.useEffect(() => {
        setVisible(true);
        syncClear$1();
        notifyArray.push(internalAfterClose);
        if (duration && +duration > 0) {
          timer = window.setTimeout(destroy, duration);
        }
        return () => {
          if (timer !== 0) {
            window.clearTimeout(timer);
          }
        };
      }, []);
      return /* @__PURE__ */ React__default["default"].createElement(Notify, __spreadProps(__spreadValues({}, restProps), {
        visible,
        teleport: () => container,
        onClose,
        onClosed: internalOnClosed
      }));
    };
    render(/* @__PURE__ */ React__default["default"].createElement(TempNotify, null), container);
    return destroy;
  };
  function defaultOptions$1() {
    return {
      type: "danger",
      color: void 0,
      message: "",
      onClose: void 0,
      onClick: void 0,
      duration: 3e3,
      className: "",
      lockScroll: false,
      background: void 0
    };
  }
  NotifyNamespace.currentOptions = defaultOptions$1();
  const setDefaultOptions$1 = (options) => {
    extend(NotifyNamespace.currentOptions, options);
  };
  const resetDefaultOptions = () => {
    NotifyNamespace.currentOptions = defaultOptions$1();
  };
  const clear = nextTickClear$1;
  const exportNotifyNamespace = Object.assign(Notify, {
    show,
    setDefaultOptions: setDefaultOptions$1,
    resetDefaultOptions,
    clear
  });
  var index$I = "";
  const DEFAULT_HEAD_HEIGHT = 50;
  const TEXT_STATUS = ["pulling", "loosing", "success"];
  const [bem$16] = createNamespace("pull-refresh");
  const PullRefresh = (props) => {
    const { locale } = React.useContext(ConfigProvider$1);
    const { disabled, animationDuration } = props;
    const root2 = React.useRef();
    const [state, updateState] = useSetState({
      refreshing: false,
      status: "normal",
      distance: 0,
      duration: 0
    });
    const track = React.useRef();
    const reachTop = React.useRef(null);
    const touch = useTouch();
    const getHeadStyle = () => {
      if (props.headHeight !== DEFAULT_HEAD_HEIGHT) {
        return {
          height: `${props.headHeight}px`
        };
      }
      return null;
    };
    const isTouchable = React.useCallback(() => {
      return state.status !== "loading" && state.status !== "success" && !disabled;
    }, [state.status, disabled]);
    const ease = (distance) => {
      const pullDistance = +(props.pullDistance || props.headHeight);
      if (distance > pullDistance) {
        if (distance < pullDistance * 2) {
          distance = pullDistance + (distance - pullDistance) / 2;
        } else {
          distance = pullDistance * 1.5 + (distance - pullDistance * 2) / 4;
        }
      }
      return Math.round(distance);
    };
    const setStatus = (distance, isLoading) => {
      const pullDistance = +(props.pullDistance || props.headHeight);
      const newState = { distance };
      if (isLoading) {
        newState.status = "loading";
      } else if (distance === 0) {
        newState.status = "normal";
      } else if (distance < pullDistance) {
        newState.status = "pulling";
      } else {
        newState.status = "loosing";
      }
      updateState(newState);
    };
    const getStatusText = () => {
      if (state.status === "normal") {
        return "";
      }
      return props[`${state.status}Text`] || locale.vanPullRefresh[state.status];
    };
    const renderStatus = () => {
      var _a;
      const { status, distance } = state;
      if (typeof props[`${state.status}Text`] === "function") {
        return (_a = props[`${state.status}Text`]) == null ? void 0 : _a.call(props, { distance });
      }
      const nodes = [];
      if (TEXT_STATUS.includes(status)) {
        nodes.push(/* @__PURE__ */ React__default["default"].createElement("div", {
          key: "text",
          className: clsx(bem$16("text"))
        }, getStatusText()));
      }
      if (status === "loading") {
        nodes.push(/* @__PURE__ */ React__default["default"].createElement(Loading, {
          key: "loading",
          className: clsx(bem$16("loading"))
        }, getStatusText()));
      }
      return nodes;
    };
    const showSuccessTip = () => {
      updateState({ status: "success" });
      setTimeout(() => {
        setStatus(0);
      }, +props.successDuration);
    };
    const onRefresh = async () => {
      try {
        updateState({ refreshing: true });
        await props.onRefresh();
        updateState({ refreshing: false });
      } catch (error) {
        updateState({ refreshing: false });
      }
    };
    const checkPosition = (event) => {
      const scrollTarget = getScrollParent$1(event.target);
      reachTop.current = getScrollTop$1(scrollTarget) === 0;
      if (reachTop.current) {
        updateState({ duration: 0 });
        touch.start(event);
      }
    };
    const onTouchStart = (event) => {
      if (isTouchable()) {
        checkPosition(event.nativeEvent);
      }
    };
    const onTouchMove = React.useCallback((event) => {
      if (isTouchable()) {
        if (!reachTop.current) {
          checkPosition(event);
        }
        touch.move(event);
        if (reachTop.current && touch.deltaY.current >= 0 && touch.isVertical()) {
          setStatus(ease(touch.deltaY.current));
          preventDefault(event);
        } else {
          setStatus(0);
        }
      }
    }, [reachTop.current, touch.deltaY.current, isTouchable]);
    const onTouchEnd = async () => {
      if (reachTop.current && touch.deltaY && isTouchable()) {
        updateState({ duration: +animationDuration });
        if (state.status === "loosing") {
          setStatus(+props.headHeight, true);
          await onRefresh();
          setTimeout(() => {
            var _a;
            return (_a = props.onRefreshEnd) == null ? void 0 : _a.call(props);
          });
        } else {
          setStatus(0);
        }
      }
    };
    useEventListener("touchmove", onTouchMove, {
      target: track.current,
      depends: [reachTop.current, isTouchable(), touch.deltaY]
    });
    useUpdateEffect(() => {
      updateState({ duration: +animationDuration });
      if (state.refreshing) {
        setStatus(+props.headHeight, true);
      } else if (props.successText) {
        showSuccessTip();
      } else {
        setStatus(0, false);
      }
    }, [state.refreshing]);
    const trackStyle = React.useMemo(() => ({
      transitionDuration: `${state.duration}ms`,
      transform: state.distance ? `translate3d(0,${state.distance}px, 0)` : ""
    }), [state.duration, state.distance]);
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      ref: root2,
      className: clsx(props.className, bem$16()),
      style: props.style
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      ref: track,
      className: clsx(bem$16("track")),
      style: trackStyle,
      onTouchStart,
      onTouchEnd,
      onTouchCancel: onTouchEnd
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$16("head")),
      style: getHeadStyle()
    }, renderStatus()), props.children));
  };
  PullRefresh.defaultProps = {
    headHeight: 50,
    animationDuration: 300,
    successDuration: 500
  };
  var index$H = "";
  function isWindow$1(val) {
    return val === window;
  }
  const useRect = (elementRef) => {
    const element = elementRef;
    if (isWindow$1(element)) {
      const width = element.innerWidth;
      const height = element.innerHeight;
      return {
        top: 0,
        left: 0,
        right: width,
        bottom: height,
        width,
        height
      };
    }
    if (element && element.getBoundingClientRect) {
      return element.getBoundingClientRect();
    }
    return {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      width: 0,
      height: 0
    };
  };
  const [bem$15] = createNamespace("swipe-cell");
  const SwipeCell = React.forwardRef((props, instanceRef) => {
    const opened = React.useRef(false);
    const lockClick2 = React.useRef(false);
    const startOffset = React.useRef(0);
    const [state, setState] = React.useState({
      offset: 0,
      dragging: false
    });
    const [actionWidth, setActionWidth] = React.useState({
      left: 0,
      right: 0
    });
    const root2 = React.useRef();
    const getWidthByNode = (node) => node ? useRect(node).width : 0;
    const leftRef = React.useCallback((node) => {
      if (node !== null) {
        setActionWidth((v2) => __spreadProps(__spreadValues({}, v2), { left: getWidthByNode(node) }));
      }
    }, []);
    const rightRef = React.useCallback((node) => {
      if (node !== null) {
        setActionWidth((v2) => __spreadProps(__spreadValues({}, v2), { right: getWidthByNode(node) }));
      }
    }, []);
    const touch = useTouch();
    const leftWidth = React.useMemo(() => isDef(props.leftWidth) ? +props.leftWidth : actionWidth.left, [props.leftWidth, actionWidth.left]);
    const rightWidth = React.useMemo(() => isDef(props.rightWidth) ? +props.rightWidth : actionWidth.right, [props.rightWidth, actionWidth.right]);
    const open2 = (side) => {
      var _a;
      opened.current = true;
      const offset2 = side === "left" ? leftWidth : -rightWidth;
      (_a = props.onOpen) == null ? void 0 : _a.call(props, { name: props.name, position: side });
      setState((v2) => __spreadProps(__spreadValues({}, v2), { offset: offset2 }));
    };
    const close = (position) => {
      var _a;
      if (opened.current) {
        opened.current = false;
        (_a = props.onClose) == null ? void 0 : _a.call(props, { name: props.name, position });
      }
      setState((v2) => __spreadProps(__spreadValues({}, v2), { offset: 0 }));
    };
    const toggle = (side) => {
      const offset2 = Math.abs(state.offset);
      const THRESHOLD = 0.15;
      const threshold = opened ? 1 - THRESHOLD : THRESHOLD;
      const width = side === "left" ? leftWidth : rightWidth;
      if (width && offset2 > width * threshold) {
        open2(side);
      } else {
        close(side);
      }
    };
    const onTouchStart = (event) => {
      if (!props.disabled) {
        startOffset.current = state.offset;
        touch.start(event);
      }
    };
    const onTouchMove = (event) => {
      if (props.disabled) {
        return;
      }
      touch.move(event);
      if (touch.isHorizontal()) {
        lockClick2.current = true;
        const newState = __spreadProps(__spreadValues({}, state), { dragging: true });
        const isEdge = !opened || touch.deltaX.current * startOffset.current < 0;
        if (isEdge) {
          preventDefault(event, props.stopPropagation);
        }
        newState.offset = range$1(touch.deltaX.current + startOffset.current, -rightWidth, leftWidth);
        setState(newState);
      }
    };
    const onTouchEnd = () => {
      if (state.dragging) {
        setState((v2) => __spreadProps(__spreadValues({}, v2), { dragging: false }));
        toggle(state.offset > 0 ? "left" : "right");
        setTimeout(() => {
          lockClick2.current = false;
        }, 0);
      }
    };
    const onClick = (position = "outside") => {
      var _a;
      (_a = props.onClick) == null ? void 0 : _a.call(props, position);
      if (opened.current && !lockClick2.current) {
        callInterceptor({
          interceptor: props.beforeClose,
          args: [
            {
              name: props.name,
              position
            }
          ],
          done: () => close(position)
        });
      }
    };
    const getClickHandler = (position, stop2) => (event) => {
      if (stop2) {
        event.stopPropagation();
      }
      onClick(position);
    };
    const renderSideContent = (side, measuredRef) => {
      if (props[`${side}Action`]) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          ref: measuredRef,
          className: clsx(bem$15(side)),
          onClick: getClickHandler(side, true)
        }, props[`${side}Action`]);
      }
      return null;
    };
    useClickAway(root2, () => onClick("outside"), "touchstart");
    React.useImperativeHandle(instanceRef, () => ({
      open: open2,
      close: () => close("outside")
    }));
    const wrapperStyle = {
      transform: `translate3d(${state.offset}px, 0, 0)`,
      transitionDuration: state.dragging ? "0s" : ".6s"
    };
    useEventListener("touchmove", onTouchMove, {
      target: root2.current,
      depends: [touch.deltaX]
    });
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      ref: root2,
      className: clsx(bem$15()),
      onClick: getClickHandler("cell"),
      onTouchStart,
      onTouchEnd,
      onTouchCancel: onTouchEnd
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$15("wrapper")),
      style: wrapperStyle
    }, renderSideContent("left", leftRef), props.children, renderSideContent("right", rightRef)));
  });
  SwipeCell.defaultProps = {
    name: ""
  };
  var index$G = "";
  const PRESET_ICONS = [
    "qq",
    "link",
    "weibo",
    "wechat",
    "poster",
    "qrcode",
    "weapp-qrcode",
    "wechat-moments"
  ];
  function getIconURL(icon) {
    if (PRESET_ICONS.includes(icon)) {
      return `https://img.yzcdn.cn/vant/share-sheet-${icon}.png`;
    }
    return icon;
  }
  const [bem$14] = createNamespace("share-sheet");
  const ShareSheet = (props) => {
    const { locale } = React.useContext(ConfigProvider$1);
    const onCancel = () => {
      var _a;
      (_a = props.onCancel) == null ? void 0 : _a.call(props);
    };
    const onSelect = (option, index2) => {
      var _a;
      (_a = props.onSelect) == null ? void 0 : _a.call(props, option, index2);
    };
    const renderHeader = () => {
      const { title, description } = props;
      if (title || description) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$14("header"))
        }, title && /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$14("title"))
        }, title), description && /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$14("description"))
        }, description));
      }
      return null;
    };
    const renderOption = (option, index2) => {
      const { name, icon, className, description } = option;
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        key: index2,
        role: "button",
        tabIndex: 0,
        className: clsx([bem$14("option"), className]),
        onClick: () => onSelect(option, index2)
      }, typeof icon === "string" ? /* @__PURE__ */ React__default["default"].createElement("img", {
        alt: "share sheet icon",
        src: getIconURL(icon),
        className: clsx(bem$14("icon"))
      }) : icon, name && /* @__PURE__ */ React__default["default"].createElement("span", {
        className: clsx(bem$14("name"))
      }, name), description && /* @__PURE__ */ React__default["default"].createElement("span", {
        className: clsx(bem$14("option-description"))
      }, description));
    };
    const renderOptions = (options, border, key) => /* @__PURE__ */ React__default["default"].createElement("div", {
      key,
      className: clsx(bem$14("options", { border }))
    }, options.map(renderOption));
    const renderRows = () => {
      const { options } = props;
      if (Array.isArray(options[0])) {
        return options.map((item, index2) => renderOptions(item, index2 !== 0, index2));
      }
      return renderOptions(options);
    };
    const renderCancelButton = () => {
      const { cancelText = locale.cancel } = props;
      if (cancelText) {
        return /* @__PURE__ */ React__default["default"].createElement("button", {
          type: "button",
          className: clsx(bem$14("cancel")),
          onClick: onCancel
        }, cancelText);
      }
      return null;
    };
    return /* @__PURE__ */ React__default["default"].createElement(Popup, __spreadValues({
      round: true,
      className: clsx(bem$14()),
      position: "bottom",
      onClose: onCancel
    }, pick(props, [
      "closeOnPopstate",
      "safeAreaInsetBottom",
      "visible",
      "overlay",
      "duration",
      "lockScroll",
      "overlayStyle",
      "overlayClass",
      "closeOnClickOverlay"
    ])), renderHeader(), renderRows(), renderCancelButton());
  };
  ShareSheet.defaultProps = {
    options: [],
    closeOnPopstate: true,
    safeAreaInsetBottom: true,
    closeOnClickOverlay: true
  };
  var index$F = "";
  const [bem$13] = createNamespace("notice-bar");
  const NoticeBar = React.forwardRef((props, ref) => {
    const {
      text,
      color,
      background,
      wrapable,
      scrollable,
      speed,
      delay = 1
    } = props;
    const popupContext = React.useContext(PopupContext);
    const [state, setState] = useSetState({
      show: true,
      offset: 0,
      duration: 0
    });
    const wrapRef = React.useRef();
    const contentRef = React.useRef();
    const wrapWidth = React.useRef(0);
    const contentWidth = React.useRef(0);
    const startTimer = React.useRef(null);
    const renderLeftIcon = () => {
      if (props.leftIcon) {
        return React__default["default"].cloneElement(props.leftIcon, {
          className: clsx(bem$13("left-icon"))
        });
      }
      return null;
    };
    const getRightIcon = () => {
      if (props.mode === "closeable") {
        return /* @__PURE__ */ React__default["default"].createElement(SvgCross, null);
      }
      if (props.mode === "link") {
        return /* @__PURE__ */ React__default["default"].createElement(SvgArrow, null);
      }
      return null;
    };
    const onClickRightIcon = (event) => {
      if (props.mode === "closeable") {
        setState({ show: false });
        if (props.onClose) {
          props.onClose(event);
        }
      }
    };
    const renderRightIcon = () => {
      if (props.rightIcon) {
        return props.rightIcon;
      }
      const finalRightIcon = props.rightIcon || getRightIcon();
      if (finalRightIcon) {
        return React__default["default"].cloneElement(finalRightIcon, {
          className: clsx(bem$13("right-icon")),
          onClick: onClickRightIcon
        });
      }
      return null;
    };
    const onTransitionEnd = () => {
      setState({
        offset: wrapWidth.current,
        duration: 0
      });
      raf$1(() => {
        doubleRaf(() => {
          setState({
            offset: -contentWidth.current,
            duration: (contentWidth.current + wrapWidth.current) / speed
          });
          if (props.onReplay) {
            props.onReplay();
          }
        });
      });
    };
    const renderMarquee = () => {
      const ellipsis = scrollable === false && !props.wrapable;
      const style = {
        transform: state.offset ? `translateX(${state.offset}px)` : "",
        transitionDuration: `${state.duration}s`
      };
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$13("wrap")),
        ref: wrapRef
      }, /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$13("content"), { "rv-ellipsis": ellipsis }),
        ref: contentRef,
        style,
        onTransitionEnd
      }, props.children || text));
    };
    const reset = () => {
      const ms = isDef(delay) ? +delay * 1e3 : 0;
      wrapWidth.current = 0;
      contentWidth.current = 0;
      setState({
        offset: 0,
        duration: 0
      });
      clearTimeout(startTimer.current);
      startTimer.current = setTimeout(() => {
        if (!wrapRef.current || !contentRef.current || scrollable === false) {
          return;
        }
        const wrapRefWidth = useRect(wrapRef.current).width;
        const contentRefWidth = useRect(contentRef.current).width;
        if (scrollable || contentRefWidth > wrapRefWidth) {
          doubleRaf(() => {
            wrapWidth.current = wrapRefWidth;
            contentWidth.current = contentRefWidth;
            setState({
              offset: -contentWidth.current,
              duration: contentWidth.current / speed
            });
          });
        }
      }, ms);
    };
    useEventListener("pageshow", reset);
    React.useEffect(() => {
      reset();
    }, [text, scrollable]);
    useUpdateEffect(() => {
      reset();
    }, [popupContext.visible]);
    React.useImperativeHandle(ref, () => ({
      reset
    }));
    return state.show && /* @__PURE__ */ React__default["default"].createElement("div", {
      role: "alert",
      className: clsx(bem$13({ wrapable }), props.className),
      style: __spreadValues({ color, background }, props.style),
      onClick: props.onClick
    }, renderLeftIcon(), renderMarquee(), renderRightIcon());
  });
  NoticeBar.defaultProps = {
    delay: 1,
    speed: 60,
    onClick: noop$3,
    onClose: noop$3
  };
  var index$E = "";
  function getBoundingClientRect(element, includeScale) {
    var rect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    return {
      width: rect.width / scaleX,
      height: rect.height / scaleY,
      top: rect.top / scaleY,
      right: rect.right / scaleX,
      bottom: rect.bottom / scaleY,
      left: rect.left / scaleX,
      x: rect.left / scaleX,
      y: rect.top / scaleY
    };
  }
  function getWindow(node) {
    if (node == null) {
      return window;
    }
    if (node.toString() !== "[object Window]") {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }
    return node;
  }
  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }
  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }
  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }
  function isShadowRoot(node) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
  }
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }
  function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = rect.width / element.offsetWidth || 1;
    var scaleY = rect.height / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }
    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width,
      height
    };
  }
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
  }
  function getScrollParent(node) {
    if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
      return node.ownerDocument.body;
    }
    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }
    return getScrollParent(getParentNode(node));
  }
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
  }
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
    var isIE = navigator.userAgent.indexOf("Trident") !== -1;
    if (isIE && isHTMLElement(element)) {
      var elementCss = getComputedStyle(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle(currentNode);
      if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start = "start";
  var end = "end";
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
  function order(modifiers) {
    var map = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }
  function debounce$1(fn2) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve(fn2());
          });
        });
      }
      return pending;
    };
  }
  function format$2(str) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return [].concat(args).reduce(function(p2, c6) {
      return p2.replace(/%s/, c6);
    }, str);
  }
  var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
  var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
  var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
  function validateModifiers(modifiers) {
    modifiers.forEach(function(modifier) {
      [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index2, self2) {
        return self2.indexOf(value) === index2;
      }).forEach(function(key) {
        switch (key) {
          case "name":
            if (typeof modifier.name !== "string") {
              console.error(format$2(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
            }
            break;
          case "enabled":
            if (typeof modifier.enabled !== "boolean") {
              console.error(format$2(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
            }
            break;
          case "phase":
            if (modifierPhases.indexOf(modifier.phase) < 0) {
              console.error(format$2(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
            }
            break;
          case "fn":
            if (typeof modifier.fn !== "function") {
              console.error(format$2(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "effect":
            if (modifier.effect != null && typeof modifier.effect !== "function") {
              console.error(format$2(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
            }
            break;
          case "requires":
            if (modifier.requires != null && !Array.isArray(modifier.requires)) {
              console.error(format$2(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
            }
            break;
          case "requiresIfExists":
            if (!Array.isArray(modifier.requiresIfExists)) {
              console.error(format$2(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
            }
            break;
          case "options":
          case "data":
            break;
          default:
            console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
              return '"' + s + '"';
            }).join(", ") + '; but "' + key + '" was provided.');
        }
        modifier.requires && modifier.requires.forEach(function(requirement) {
          if (modifiers.find(function(mod) {
            return mod.name === requirement;
          }) == null) {
            console.error(format$2(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
          }
        });
      });
    });
  }
  function uniqueBy(arr, fn2) {
    var identifiers = /* @__PURE__ */ new Set();
    return arr.filter(function(item) {
      var identifier = fn2(item);
      if (!identifiers.has(identifier)) {
        identifiers.add(identifier);
        return true;
      }
    });
  }
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }
  var round = Math.round;
  function getVariation(placement) {
    return placement.split("-")[1];
  }
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }
  function computeOffsets(_ref) {
    var reference = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference.x + reference.width / 2 - element.width / 2;
    var commonY = reference.y + reference.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case right:
        offsets = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference.x,
          y: reference.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
          break;
      }
    }
    return offsets;
  }
  var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
  var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference, popper, options) {
      if (options === void 0) {
        options = defaultOptions2;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
        modifiersData: {},
        elements: {
          reference,
          popper
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions2, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
            popper: listScrollParents(popper)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m2) {
            return m2.enabled;
          });
          {
            var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
              var name = _ref.name;
              return name;
            });
            validateModifiers(modifiers);
            if (getBasePlacement(state.options.placement) === auto) {
              var flipModifier = state.orderedModifiers.find(function(_ref2) {
                var name = _ref2.name;
                return name === "flip";
              });
              if (!flipModifier) {
                console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
              }
            }
            var _getComputedStyle = getComputedStyle(popper), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
            if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
              return parseFloat(margin);
            })) {
              console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
            }
          }
          runModifierEffects();
          return instance.update();
        },
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference2 = _state$elements.reference, popper2 = _state$elements.popper;
          if (!areValidElements(reference2, popper2)) {
            {
              console.error(INVALID_ELEMENT_ERROR);
            }
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference2, getOffsetParent(popper2), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper2)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          var __debug_loops__ = 0;
          for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
            {
              __debug_loops__ += 1;
              if (__debug_loops__ > 100) {
                console.error(INFINITE_LOOP_ERROR);
                break;
              }
            }
            if (state.reset === true) {
              state.reset = false;
              index2 = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state = fn2({
                state,
                options: _options,
                name,
                instance
              }) || state;
            }
          }
        },
        update: debounce$1(function() {
          return new Promise(function(resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference, popper)) {
        {
          console.error(INVALID_ELEMENT_ERROR);
        }
        return instance;
      }
      instance.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref3) {
          var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect3 = _ref3.effect;
          if (typeof effect3 === "function") {
            var cleanupFn = effect3({
              state,
              name,
              instance,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      return instance;
    };
  }
  var passive = {
    passive: true
  };
  function effect(_ref) {
    var state = _ref.state, instance = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance.update, passive);
      }
    };
  }
  var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect,
    data: {}
  };
  function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref) {
    var x2 = _ref.x, y2 = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(round(x2 * dpr) / dpr) || 0,
      y: round(round(y2 * dpr) / dpr) || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets;
    var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === "function" ? roundOffsets(offsets) : offsets, _ref3$x = _ref3.x, x2 = _ref3$x === void 0 ? 0 : _ref3$x, _ref3$y = _ref3.y, y2 = _ref3$y === void 0 ? 0 : _ref3$y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper)) {
        offsetParent = getDocumentElement(popper);
        if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        y2 -= offsetParent[heightProp] - popperRect.height;
        y2 *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        x2 -= offsetParent[widthProp] - popperRect.width;
        x2 *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position
    }, adaptive && unsetSides);
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref4) {
    var state = _ref4.state, options = _ref4.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    {
      var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || "";
      if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
        return transitionProperty.indexOf(property) >= 0;
      })) {
        console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
      }
    }
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };
  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect2(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style = styleProperties.reduce(function(style2, property) {
          style2[property] = "";
          return style2;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles,
    effect: effect2,
    requires: ["computeStyles"]
  };
  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x2;
      state.modifiersData.popperOffsets.y += y2;
    }
    state.modifiersData[name] = data;
  }
  var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };
  const useLazyEffect = (effect3, deps) => {
    const [c6, setC] = React.useState(0);
    React.useEffect(() => {
      setC((v2) => v2 + 1);
    }, deps);
    React.useEffect(() => {
      return effect3();
    }, [c6]);
  };
  const popupProps = [
    "overlay",
    "duration",
    "overlayStyle",
    "overlayClass",
    "closeOnClickOverlay",
    "teleport",
    "onClose",
    "onOpen",
    "onClosed",
    "onOpened",
    "onClickOverlay"
  ];
  const [bem$12] = createNamespace("popover");
  const Popover = React.forwardRef((_m, ref) => {
    var _n = _m, { children, className } = _n, props = __objRest(_n, ["children", "className"]);
    const [visible, updateShow] = React.useState(false);
    const popper = React.useRef(null);
    const wrapperRef = React.useRef();
    const popoverRef = React.useRef();
    const createPopperInstance = () => createPopper(wrapperRef.current, popoverRef.current.popupRef.current, {
      placement: props.placement,
      modifiers: [
        {
          name: "computeStyles",
          options: {
            adaptive: false,
            gpuAcceleration: false
          }
        },
        extend({}, offset_default, {
          options: {
            offset: props.offset
          }
        })
      ]
    });
    const updateLocation = () => {
      var _a;
      if (!visible) {
        return;
      }
      if (!popper.current) {
        popper.current = createPopperInstance();
      } else {
        (_a = popper.current) == null ? void 0 : _a.setOptions({
          placement: props.placement
        });
      }
    };
    const onClickWrapper = () => {
      if (props.trigger === "click") {
        updateShow(!visible);
      }
    };
    const onClickAction = (action, index2) => {
      var _a;
      if (action.disabled) {
        return;
      }
      (_a = props.onSelect) == null ? void 0 : _a.call(props, action, index2);
      if (props.closeOnClickAction) {
        updateShow(false);
      }
    };
    const onClickAway = () => {
      if (props.closeOnClickOutside && (!props.overlay || props.closeOnClickOverlay)) {
        updateShow(false);
      }
    };
    const renderAction = (action, index2) => {
      const { icon, text, color, disabled, className: actionClassname } = action;
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        key: index2,
        className: clsx(bem$12("action", { disabled, "with-icon": icon }), actionClassname),
        style: { color },
        onClick: () => onClickAction(action, index2)
      }, icon ? React__default["default"].cloneElement(icon, {
        className: clsx(bem$12("action-icon"))
      }) : null, /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$12("action-text"), BORDER_BOTTOM)
      }, text));
    };
    React.useEffect(() => {
      return () => {
        var _a;
        if (popper.current) {
          (_a = popper.current) == null ? void 0 : _a.destroy();
          popper.current = null;
        }
      };
    }, []);
    useLazyEffect(() => {
      updateLocation();
    }, [visible, props.placement]);
    React.useEffect(() => {
      let popupTarget;
      const prevent = (e2) => e2.stopPropagation();
      if (popoverRef.current && popoverRef.current.popupRef.current) {
        popupTarget = popoverRef.current.popupRef.current;
        popupTarget.addEventListener("touchstart", prevent);
      }
      return () => {
        if (popupTarget)
          popupTarget.removeEventListener("touchstart", prevent);
      };
    }, [popoverRef.current]);
    React.useImperativeHandle(ref, () => ({
      show: () => {
        if (visible) {
          updateShow(false);
          setTimeout(() => updateShow(true), 0);
          return;
        }
        updateShow(true);
      },
      hide: () => updateShow(false)
    }));
    useClickAway(wrapperRef, onClickAway, "touchstart");
    return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, /* @__PURE__ */ React__default["default"].createElement("span", {
      ref: wrapperRef,
      className: clsx(bem$12("wrapper")),
      onClick: onClickWrapper
    }, props.reference), /* @__PURE__ */ React__default["default"].createElement(Popup, __spreadValues({
      ref: popoverRef,
      visible,
      className: clsx(className, bem$12([props.theme])),
      position: "",
      transition: "rv-zoom",
      lockScroll: false
    }, pick(props, popupProps)), /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$12("arrow"))
    }), /* @__PURE__ */ React__default["default"].createElement("div", {
      role: "menu",
      className: clsx(bem$12("content"))
    }, children || props.actions.map(renderAction))));
  });
  Popover.defaultProps = {
    overlay: false,
    duration: 300,
    closeOnClickAction: true,
    closeOnClickOverlay: true,
    closeOnClickOutside: true,
    offset: [0, 8],
    theme: "light",
    trigger: "click",
    actions: [],
    placement: "bottom"
  };
  var index$D = "";
  function useLockFn(fn) {
    const lockRef = React.useRef(false);
    return React.useCallback(async (...args) => {
      if (lockRef.current)
        return;
      lockRef.current = true;
      try {
        const ret = await fn(...args);
        lockRef.current = false;
        return ret;
      } catch (e2) {
        lockRef.current = false;
        throw e2;
      }
    }, [fn]);
  }
  function debounce(func, wait, options) {
    let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;
    let lastInvokeTime = 0;
    let leading = false;
    let maxing = false;
    let trailing = true;
    const useRAF = !wait && wait !== 0 && typeof root.requestAnimationFrame === "function";
    if (typeof func !== "function") {
      throw new TypeError("Expected a function");
    }
    wait = +wait || 0;
    if (isObject$1(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing ? Math.max(+options.maxWait || 0, wait) : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      const args = lastArgs;
      const thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function startTimer(pendingFunc, wait2) {
      if (useRAF) {
        root.cancelAnimationFrame(timerId);
        return root.requestAnimationFrame(pendingFunc);
      }
      return setTimeout(() => pendingFunc(), wait2);
    }
    function cancelTimer(id) {
      if (useRAF) {
        return root.cancelAnimationFrame(id);
      }
      clearTimeout(id);
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = startTimer(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      const timeSinceLastCall = time - lastCallTime;
      const timeSinceLastInvoke = time - lastInvokeTime;
      const timeWaiting = wait - timeSinceLastCall;
      return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
      const timeSinceLastCall = time - lastCallTime;
      const timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      const time = Date.now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = startTimer(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        cancelTimer(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush2() {
      return timerId === void 0 ? result : trailingEdge(Date.now());
    }
    function pending() {
      return timerId !== void 0;
    }
    function debounced(...args) {
      const time = Date.now();
      const isInvoking = shouldInvoke(time);
      lastArgs = args;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          timerId = startTimer(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = startTimer(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush2;
    debounced.pending = pending;
    return debounced;
  }
  function throttle(func, wait, options) {
    let leading = true;
    let trailing = true;
    if (typeof func !== "function") {
      throw new TypeError("Expected a function");
    }
    if (isObject$1(options)) {
      leading = "leading" in options ? !!options.leading : leading;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
      leading,
      trailing,
      "maxWait": wait
    });
  }
  function useThrottleFn(fn, options) {
    var _a;
    const fnRef = useLatest(fn);
    const wait = (_a = options == null ? void 0 : options.wait) != null ? _a : 1e3;
    const throttled = React.useMemo(() => throttle((...args) => {
      return fnRef.current(...args);
    }, wait, options), []);
    useUnmount(() => {
      throttled.cancel();
    });
    return {
      run: throttled,
      cancel: throttled.cancel,
      flush: throttled.flush
    };
  }
  const [bem$11] = createNamespace("list");
  function isWindow(element) {
    return element === window;
  }
  const LoadMore = React__default["default"].forwardRef((props, ref) => {
    const { locale } = React__default["default"].useContext(ConfigProvider$1);
    const [failed, setFailed] = React__default["default"].useState(false);
    const doLoadMore = useLockFn(async (isRetry) => {
      try {
        await props.onLoad(isRetry);
      } catch (e2) {
        setFailed(true);
        throw e2;
      }
    });
    const elementRef = React__default["default"].useRef(null);
    const [flag, setFlag] = React__default["default"].useState({});
    const nextFlagRef = React__default["default"].useRef(flag);
    const [scrollParent, setScrollParent] = React__default["default"].useState();
    const { run: check } = useThrottleFn(async () => {
      if (nextFlagRef.current !== flag)
        return;
      if (props.finished)
        return;
      const element = elementRef.current;
      if (!element)
        return;
      if (!element.offsetParent)
        return;
      const parent = getScrollParent$1(element);
      setScrollParent(parent);
      if (!parent)
        return;
      const rect = element.getBoundingClientRect();
      const elementTop = rect.top;
      const current = isWindow(parent) ? window.innerHeight : parent.getBoundingClientRect().bottom;
      const isReachEdge = current >= elementTop - props.threshold;
      if (isReachEdge) {
        const nextFlag = {};
        nextFlagRef.current = nextFlag;
        await doLoadMore(false);
        setFlag(nextFlag);
      }
    }, {
      wait: 100,
      leading: true,
      trailing: true
    });
    React__default["default"].useEffect(() => {
      check();
    });
    React__default["default"].useEffect(() => {
      const element = elementRef.current;
      if (!element)
        return;
      if (!scrollParent)
        return;
      function onScroll() {
        check();
      }
      scrollParent.addEventListener("scroll", onScroll);
      return () => {
        scrollParent.removeEventListener("scroll", onScroll);
      };
    }, [scrollParent]);
    async function retry() {
      setFailed(false);
      await doLoadMore(true);
      setFlag(nextFlagRef.current);
    }
    const renderDone = () => {
      if (props.finishedText) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$11("finished"))
        }, props.finishedText);
      }
      return null;
    };
    const renderFailed = () => {
      if (props.errorText) {
        if (typeof props.errorText === "function")
          return props.errorText(retry);
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          onClick: retry,
          className: clsx(bem$11("error"))
        }, props.errorText);
      }
      return null;
    };
    const renderLoading = () => {
      return /* @__PURE__ */ React__default["default"].createElement(Loading, {
        className: clsx(bem$11("loading")),
        size: 16
      }, props.loadingText || locale.loading);
    };
    const renderPlaceholder = () => {
      if (props.finished)
        return renderDone();
      if (failed)
        return renderFailed();
      return renderLoading();
    };
    React__default["default"].useImperativeHandle(ref, () => ({ check }));
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, bem$11()),
      style: props.style
    }, props.children, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, bem$11("loadmore")),
      ref: elementRef
    }, renderPlaceholder()));
  });
  LoadMore.defaultProps = {
    threshold: 300
  };
  const List$1 = React.forwardRef((props, ref) => {
    return /* @__PURE__ */ React__default["default"].createElement(LoadMore, {
      ref,
      className: clsx(props.className),
      style: props.style,
      onLoad: props.onLoad,
      threshold: props.offset,
      finished: props.finished,
      finishedText: props.finishedText,
      loadingText: props.loadingText,
      errorText: props.errorText
    }, props.children);
  });
  List$1.defaultProps = {
    offset: 300
  };
  var index$C = "";
  const [bem$10] = createNamespace("steps");
  const Steps$1 = (_o) => {
    var _p = _o, {
      children,
      className,
      style
    } = _p, props = __objRest(_p, [
      "children",
      "className",
      "style"
    ]);
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(className, bem$10([props.direction])),
      style
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$10("items"))
    }, React__default["default"].Children.toArray(children).filter(Boolean).map((child, index2) => React__default["default"].cloneElement(child, {
      index: index2,
      parent: props
    }))));
  };
  Steps$1.defaultProps = {
    active: 0,
    direction: "horizontal",
    activeIcon: /* @__PURE__ */ React__default["default"].createElement(SvgChecked, null)
  };
  const [bem$$] = createNamespace("step");
  const StepsItem = (_q) => {
    var _r = _q, { children } = _r, props = __objRest(_r, ["children"]);
    const { index: index2, parent: parentProps } = props;
    const getStatus = () => {
      const active = +parentProps.active;
      if (index2 < active) {
        return "finish";
      }
      return index2 === active ? "process" : "waiting";
    };
    const isActive = () => getStatus() === "process";
    const lineStyle = React.useMemo(() => ({
      background: getStatus() === "finish" ? parentProps.activeColor : parentProps.inactiveColor
    }), [
      index2,
      parentProps.active,
      parentProps.activeColor,
      parentProps.inactiveColor
    ]);
    const titleStyle = React.useMemo(() => {
      if (isActive()) {
        return { color: parentProps.activeColor };
      }
      if (!getStatus()) {
        return { color: parentProps.inactiveColor };
      }
      return {};
    }, [
      index2,
      parentProps.active,
      parentProps.activeColor,
      parentProps.inactiveColor
    ]);
    const onClickStep = () => {
      if (parentProps.onClickStep)
        parentProps.onClickStep(index2);
    };
    const renderCircle = () => {
      var _a, _b, _c;
      const { activeColor } = parentProps;
      const finishIcon = (_a = props.finishIcon) != null ? _a : parentProps.finishIcon;
      const activeIcon = (_b = props.activeIcon) != null ? _b : parentProps.activeIcon;
      const inactiveIcon = (_c = props.inactiveIcon) != null ? _c : parentProps.inactiveIcon;
      if (isActive()) {
        if (activeIcon) {
          return React__default["default"].cloneElement(activeIcon, {
            className: clsx(bem$$("icon", "active")),
            color: activeColor,
            style: {
              color: activeColor
            }
          });
        }
      }
      if (getStatus() === "finish" && finishIcon) {
        return React__default["default"].cloneElement(finishIcon, {
          className: clsx(bem$$("icon", "finish")),
          color: activeColor,
          style: {
            color: activeColor
          }
        });
      }
      if (inactiveIcon) {
        return React__default["default"].cloneElement(inactiveIcon, {
          className: clsx(bem$$("icon")),
          color: activeColor,
          style: {
            color: activeColor
          }
        });
      }
      return /* @__PURE__ */ React__default["default"].createElement("i", {
        className: clsx(bem$$("circle")),
        style: lineStyle
      });
    };
    const status = getStatus();
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      style: props.style,
      className: clsx(props.className, BORDER, bem$$([parentProps.direction, { [status]: status }]))
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$$("title", { active: isActive() })),
      style: titleStyle,
      onClick: onClickStep
    }, children), /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$$("circle-container")),
      onClick: onClickStep
    }, renderCircle()), /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$$("line")),
      style: lineStyle
    }));
  };
  const Steps = Object.assign(Steps$1, { Item: StepsItem });
  var index$B = "";
  const [bem$_] = createNamespace("toast");
  const Toast$1 = (props) => {
    let clickable = false;
    const toggleClickable = () => {
      const newValue = props.visible && props.forbidClick;
      if (clickable !== newValue) {
        clickable = newValue;
        lockClick(clickable);
      }
      if (!props.visible) {
        lockClick(false);
      }
    };
    const onClick = () => {
      if (props.closeOnClick) {
        props.onClose();
      }
    };
    React.useEffect(() => {
      toggleClickable();
    }, [props.visible, props.forbidClick]);
    const renderIcon = () => {
      const { icon, type: type2, iconSize, loadingType } = props;
      const hasIcon = icon || type2 === "success" || type2 === "fail";
      if (hasIcon) {
        const buildInIcon = type2 === "fail" ? /* @__PURE__ */ React__default["default"].createElement(SvgCross, null) : /* @__PURE__ */ React__default["default"].createElement(SvgSuccess, null);
        return React__default["default"].cloneElement(icon || buildInIcon, {
          className: clsx(bem$_("icon")),
          fontSize: iconSize
        });
      }
      if (type2 === "loading") {
        return /* @__PURE__ */ React__default["default"].createElement(Loading, {
          className: clsx(bem$_("loading")),
          type: loadingType
        });
      }
      return null;
    };
    const renderMessage = () => {
      const { message } = props;
      if (isDef(message) && message !== "") {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$_("info"))
        }, message);
      }
      return null;
    };
    return /* @__PURE__ */ React__default["default"].createElement(Popup, {
      className: clsx([
        bem$_([props.position, { [props.type]: !props.icon }]),
        props.className
      ]),
      visible: props.visible,
      overlay: props.overlay,
      transition: props.transition,
      overlayClass: props.overlayClass,
      overlayStyle: props.overlayStyle,
      closeOnClickOverlay: props.closeOnClickOverlay,
      lockScroll: false,
      onClick,
      onClose: props.onClose,
      onClosed: props.onClosed,
      onOpened: props.onOpened,
      teleport: props.teleport
    }, renderIcon(), renderMessage());
  };
  Toast$1.defaultProps = {
    type: "info",
    duration: 2e3,
    position: "middle",
    transition: "rv-fade",
    loadingType: "circular",
    overlay: false
  };
  const defaultOptions = {
    message: "",
    className: "",
    type: "info",
    position: "middle",
    forbidClick: false,
    duration: 2e3,
    teleport: () => document.body
  };
  const toastArray = [];
  let allowMultiple = false;
  let currentOptions = extend({}, defaultOptions);
  const defaultOptionsMap = /* @__PURE__ */ new Map();
  function syncClear() {
    let fn = toastArray.pop();
    while (fn) {
      fn();
      fn = toastArray.pop();
    }
  }
  function nextTickClear() {
    setTimeout(syncClear);
  }
  const ToastObj = (p2) => {
    if (!canUseDom())
      return null;
    const props = parseOptions(p2);
    const update2 = {
      config: () => {
      },
      clear: () => null
    };
    let timer = 0;
    const { onClose, teleport } = props;
    const container = document.createElement("div");
    const bodyContainer = resolveContainer(teleport);
    bodyContainer.appendChild(container);
    const TempToast = () => {
      const options = __spreadValues({
        duration: 2e3
      }, props);
      const [visible, setVisible] = React.useState(false);
      const [state, setState] = React.useState(__spreadValues({}, options));
      const internalOnClosed = React.useCallback(() => {
        if (state.forbidClick) {
          lockClick(false);
        }
        const unmountResult = unmount(container);
        if (unmountResult && container.parentNode) {
          container.parentNode.removeChild(container);
        }
      }, [container]);
      const destroy = React.useCallback(() => {
        setVisible(false);
        if (onClose)
          onClose();
      }, []);
      update2.clear = internalOnClosed;
      update2.config = React.useCallback((nextState) => {
        setState((prev2) => typeof nextState === "function" ? __spreadValues(__spreadValues({}, prev2), nextState(prev2)) : __spreadValues(__spreadValues({}, prev2), nextState));
      }, [setState]);
      React.useEffect(() => {
        setVisible(true);
        if (!allowMultiple)
          syncClear();
        toastArray.push(internalOnClosed);
        if (state.duration !== 0 && "duration" in state) {
          timer = window.setTimeout(destroy, +state.duration);
        }
        return () => {
          if (timer !== 0) {
            window.clearTimeout(timer);
          }
        };
      }, []);
      return /* @__PURE__ */ React__default["default"].createElement(Toast$1, __spreadProps(__spreadValues({}, state), {
        visible,
        teleport: () => container,
        onClose: destroy,
        onClosed: internalOnClosed
      }));
    };
    render(/* @__PURE__ */ React__default["default"].createElement(TempToast, null), container);
    return update2;
  };
  function parseOptions(message) {
    if (isObject$1(message)) {
      return message;
    }
    return { message };
  }
  const createMethod = (type2) => (options) => ToastObj(__spreadProps(__spreadValues(__spreadValues(__spreadValues({}, currentOptions), defaultOptionsMap.get(type2)), parseOptions(options)), {
    type: type2
  }));
  ["info", "loading", "success", "fail"].forEach((method2) => {
    ToastObj[method2] = createMethod(method2);
  });
  ToastObj.allowMultiple = (value = true) => {
    allowMultiple = value;
  };
  ToastObj.clear = nextTickClear;
  function setDefaultOptions(type2, options) {
    if (typeof type2 === "string") {
      defaultOptionsMap.set(type2, options);
    } else {
      extend(currentOptions, type2);
    }
  }
  ToastObj.setDefaultOptions = setDefaultOptions;
  ToastObj.resetDefaultOptions = (type2) => {
    if (typeof type2 === "string") {
      defaultOptionsMap.delete(type2);
    } else {
      currentOptions = extend({}, defaultOptions);
      defaultOptionsMap.clear();
    }
  };
  const Toast = ToastObj;
  var index$A = "";
  const [bem$Z] = createNamespace("action-sheet");
  const ActionSheet = (props) => {
    const onCancel = () => {
      var _a, _b;
      (_a = props.onClose) == null ? void 0 : _a.call(props);
      (_b = props.onCancel) == null ? void 0 : _b.call(props);
    };
    const renderHeader = () => {
      if (!props.title)
        return null;
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$Z("header"))
      }, props.title, props.closeable && React__default["default"].cloneElement(props.closeIcon, {
        className: clsx(bem$Z("clear")),
        onClick: onCancel
      }));
    };
    const renderCancel = () => {
      if (!props.cancelText)
        return null;
      return [
        /* @__PURE__ */ React__default["default"].createElement("div", {
          key: "cancel-gap",
          className: clsx(bem$Z("gap"))
        }),
        /* @__PURE__ */ React__default["default"].createElement("button", {
          key: "cancel-btn",
          type: "button",
          className: clsx(bem$Z("cancel")),
          onClick: onCancel
        }, props.cancelText)
      ];
    };
    const renderOption = (item, index2) => {
      const {
        name,
        color,
        subname,
        loading,
        callback,
        disabled,
        className,
        style
      } = item;
      const Content = loading ? /* @__PURE__ */ React__default["default"].createElement(Loading, {
        className: clsx(bem$Z("loading-icon"))
      }) : [
        /* @__PURE__ */ React__default["default"].createElement("span", {
          key: `${index2}-1`,
          className: clsx(bem$Z("name"))
        }, name),
        subname && /* @__PURE__ */ React__default["default"].createElement("div", {
          key: `${index2}-2`,
          className: clsx(bem$Z("subname"))
        }, subname)
      ];
      const onClick = () => {
        if (disabled || loading) {
          return;
        }
        if (callback) {
          callback(item);
        }
        if (props.closeOnClickAction) {
          onCancel();
        }
        setTimeout(() => {
          var _a;
          (_a = props.onSelect) == null ? void 0 : _a.call(props, item, index2);
        }, 0);
      };
      return /* @__PURE__ */ React__default["default"].createElement("button", {
        key: index2,
        type: "button",
        style: __spreadValues({ color }, style),
        className: clsx(bem$Z("item", { loading, disabled }), className),
        onClick
      }, Content);
    };
    const renderDescription = () => {
      if (props.description) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$Z("description"))
        }, props.description);
      }
      return null;
    };
    const renderOptions = () => {
      if (props.actions) {
        return props.actions.map(renderOption);
      }
      return null;
    };
    return /* @__PURE__ */ React__default["default"].createElement(Popup, __spreadProps(__spreadValues({
      visible: props.visible,
      className: clsx(bem$Z("wrapper")),
      position: "bottom"
    }, pick(props, sharedPopupProps)), {
      onClose: onCancel,
      closeable: false
    }), /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$Z(), props.className),
      style: props.style
    }, renderHeader(), renderDescription(), /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$Z("content"))
    }, renderOptions(), props.children), renderCancel()));
  };
  ActionSheet.defaultProps = {
    closeable: true,
    safeAreaInsetBottom: true,
    round: true,
    lockScroll: true,
    overlay: true,
    closeOnClickOverlay: true,
    closeIcon: /* @__PURE__ */ React__default["default"].createElement(SvgCross, null)
  };
  var index$z = "";
  function useRefs() {
    const refs = React__default["default"].useRef([]);
    const setRefs = React__default["default"].useCallback((index2) => (el) => {
      if (el)
        refs.current[index2] = el;
    }, []);
    const reset = React__default["default"].useCallback(() => {
      refs.current = [];
    }, []);
    return [refs.current, setRefs, reset];
  }
  const DropdownMenu$2 = React.createContext({});
  const useMergedState = (option) => {
    const { defaultValue, value } = option || {};
    const [innerValue, setInnerValue] = React.useState(() => {
      if (value !== void 0) {
        return value;
      }
      if (defaultValue !== void 0) {
        return typeof defaultValue === "function" ? defaultValue() : defaultValue;
      }
      return void 0;
    });
    const mergedValue = value !== void 0 ? value : innerValue;
    function triggerChange(newValue) {
      setInnerValue(newValue);
    }
    return [mergedValue, triggerChange];
  };
  const [bem$Y] = createNamespace("dropdown-menu");
  const DropdownMenu$1 = React.forwardRef((props, ref) => {
    const [innerValue = {}, setInnerValue] = useMergedState({
      value: props.value,
      defaultValue: props.defaultValue
    });
    const [childrenRefs, setChildrenRefs] = useRefs();
    const [showPopupIndex, setShowPopupIndex] = React.useState(null);
    const showPopupIndexRef = React.useRef();
    const root2 = React.useRef();
    const barRef = React.useRef();
    const offset2 = React.useRef(0);
    const isToggleEvent = React.useRef(false);
    const rect = React.useRef({ bottom: 0, top: 0 });
    const innerEffect = React.useRef(false);
    const opened = React.useMemo(() => showPopupIndex !== null, [showPopupIndex]);
    const barStyle = () => {
      if (opened && isDef(props.zIndex)) {
        return {
          zIndex: +props.zIndex + 1
        };
      }
      return {};
    };
    const updateShowPopupIndex = (current) => {
      showPopupIndexRef.current = current;
      setShowPopupIndex(current);
    };
    const closeAll = () => {
      childrenRefs.forEach((item) => {
        item.toggle(false);
      });
      updateShowPopupIndex(null);
    };
    const onClickAway = () => {
      if (props.closeOnClickOutside && !isToggleEvent.current) {
        closeAll();
      } else {
        isToggleEvent.current = false;
      }
    };
    const updateOffset = () => {
      if (barRef.current) {
        rect.current = useRect(barRef.current);
        if (props.direction === "down") {
          offset2.current = rect.current.bottom;
        } else {
          offset2.current = window.innerHeight - rect.current.top;
        }
      }
    };
    const onScroll = () => {
      if (opened) {
        updateOffset();
      }
    };
    const showItem = (index2) => {
      const item = childrenRefs[index2];
      isToggleEvent.current = true;
      updateOffset();
      updateShowPopupIndex(index2);
      item.toggle(true);
    };
    const toggleItem = (active) => {
      childrenRefs.forEach((item, index2) => {
        if (index2 === active) {
          if (active === showPopupIndexRef.current) {
            updateShowPopupIndex(null);
            item.toggle();
            return;
          }
          showItem(active);
        }
      });
    };
    const close = () => {
      updateShowPopupIndex(null);
    };
    const renderTitle = (item, index2) => {
      const showPopup = showPopupIndex === index2;
      const { titleClass } = item;
      const disabled = props.disabled || item.disabled;
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        key: index2,
        role: "button",
        tabIndex: disabled ? -1 : 0,
        className: clsx(bem$Y("item", { disabled })),
        onClick: () => {
          if (!disabled) {
            toggleItem(index2);
          }
        }
      }, /* @__PURE__ */ React__default["default"].createElement("span", {
        className: clsx(bem$Y("title", {
          down: showPopup === (props.direction === "down"),
          active: showPopup
        }), titleClass),
        style: { color: showPopup ? props.activeColor : "" }
      }, /* @__PURE__ */ React__default["default"].createElement("div", {
        className: "rv-ellipsis"
      }, item.renderTitle(innerValue[item.name]))));
    };
    useUpdateEffect(() => {
      if (innerEffect.current) {
        innerEffect.current = false;
        return;
      }
      if (!props.value) {
        setInnerValue(void 0);
        return;
      }
      setInnerValue(props.value);
    }, [props.value]);
    React.useEffect(() => {
      if (barRef.current) {
        updateOffset();
      }
    }, [barRef.current]);
    const onInnerChange = (v2) => {
      innerEffect.current = true;
      const newValue = __spreadValues(__spreadValues({}, innerValue), v2);
      setInnerValue(newValue);
      if (props.onChange)
        props.onChange(newValue);
    };
    const scrollParent = useScrollParent(root2);
    useEventListener("scroll", onScroll, { target: scrollParent });
    useClickAway(root2, onClickAway);
    React.useImperativeHandle(ref, () => ({
      toggleItem,
      showItem,
      close: closeAll
    }));
    return /* @__PURE__ */ React__default["default"].createElement(DropdownMenu$2.Provider, {
      value: { props, value: innerValue, onChange: onInnerChange, close }
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      ref: root2,
      className: clsx(bem$Y(), props.className),
      style: __spreadValues({}, props.style)
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      ref: barRef,
      style: barStyle(),
      className: clsx(bem$Y("bar", { opened }))
    }, childrenRefs.map(renderTitle)), React.Children.toArray(props.children).filter(Boolean).map((child, index2) => React.cloneElement(child, {
      ref: setChildrenRefs(index2),
      offset: offset2.current,
      showPopup: showPopupIndex === index2
    }))));
  });
  DropdownMenu$1.defaultProps = {
    duration: 200,
    overlay: true,
    closeOnClickOutside: true,
    closeOnClickOverlay: true,
    direction: "down",
    defaultValue: {}
  };
  const inheritPropsKey = [
    "overlay",
    "overlayClass",
    "overlayStyle",
    "disabled",
    "placeholder",
    "onOpen",
    "onClosed",
    "onOpened",
    "teleport",
    "closeOnClickOverlay"
  ];
  function inheritProps(parentProps, props) {
    return __spreadValues(__spreadValues({}, parentProps), props);
  }
  const [bem$X] = createNamespace("dropdown-item");
  const DropdownMenuItem = React.forwardRef((props, ref) => {
    var _a;
    const [state, setState] = useSetState({
      transition: true,
      showWrapper: false
    });
    const parent = React.useContext(DropdownMenu$2);
    const currentValue = (_a = parent.value) == null ? void 0 : _a[props.name];
    const onClosed = () => {
      var _a2, _b;
      setState({ showWrapper: false });
      (_b = (_a2 = props.onClosed) != null ? _a2 : parent.props.onClosed) == null ? void 0 : _b();
    };
    const onClickWrapper = (event) => {
      if (props.teleport) {
        event.stopPropagation();
      }
    };
    const onClose = () => {
      var _a2, _b;
      parent.close();
      (_b = (_a2 = props.onClose) != null ? _a2 : parent.props.onClose) == null ? void 0 : _b();
    };
    const toggle = (show2 = !props.showPopup, options = {}) => {
      if (show2 === props.showPopup) {
        return;
      }
      const newState = {};
      newState.transition = !options.immediate;
      if (show2) {
        newState.showWrapper = true;
      } else {
        onClose();
      }
      setState(newState);
    };
    const renderTitle = (itemValue) => {
      if (props.title) {
        return props.title;
      }
      const match = props.options.find((option) => option.value === itemValue);
      return match ? match.text : props.placeholder;
    };
    const renderOption = (option) => {
      const { activeColor } = parent.props;
      const active = option.value === currentValue;
      const onClick = () => {
        if (option.value !== currentValue) {
          parent.onChange({ [props.name]: option.value });
        }
        onClose();
      };
      return /* @__PURE__ */ React__default["default"].createElement(Cell, {
        clickable: true,
        key: option.value,
        icon: option.icon,
        title: option.text,
        className: clsx(bem$X("option", { active })),
        style: { color: active ? activeColor : "" },
        onClick
      }, active && /* @__PURE__ */ React__default["default"].createElement(SvgSuccess, {
        className: clsx(bem$X("icon")),
        color: activeColor
      }));
    };
    const renderContent = () => {
      var _a2;
      const { offset: offset2 } = props;
      const { zIndex, overlayStyle, duration, direction } = parent.props;
      const style = getZIndexStyle(zIndex);
      if (direction === "down") {
        style.top = `${offset2}px`;
      } else {
        style.bottom = `${offset2}px`;
      }
      const attrs = pick(inheritProps(parent.props, props), inheritPropsKey);
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        style: __spreadProps(__spreadValues({}, style), { display: state.showWrapper ? "block" : "none" }),
        className: clsx(bem$X([direction])),
        onClick: onClickWrapper
      }, /* @__PURE__ */ React__default["default"].createElement(Popup, __spreadProps(__spreadValues({}, attrs), {
        teleport: null,
        visible: props.showPopup,
        className: clsx(bem$X("content")),
        position: direction === "down" ? "top" : "bottom",
        duration: state.transition ? +duration : 0,
        overlayStyle: __spreadValues({ position: "absolute" }, overlayStyle),
        onClose,
        onClosed
      }), (_a2 = props.options) == null ? void 0 : _a2.map(renderOption), props.children));
    };
    React.useImperativeHandle(ref, () => ({
      toggle,
      renderTitle,
      state,
      titleClass: props.titleClass,
      disabled: props.disabled,
      name: props.name,
      options: props.options
    }));
    if (props.teleport)
      return renderToContainer(props.teleport, renderContent());
    return renderContent();
  });
  DropdownMenuItem.defaultProps = {
    placeholder: "\u8BF7\u9009\u62E9",
    options: []
  };
  const DropdownMenu = Object.assign(DropdownMenu$1, { Item: DropdownMenuItem });
  var index$y = "";
  const [bem$W] = createNamespace("search");
  const Search = React.forwardRef((props, ref) => {
    const { locale } = React.useContext(ConfigProvider$1);
    const filedRef = React.useRef();
    const innerEffect = React.useRef(false);
    const [value, setValue2] = React.useState(() => props.value);
    const blur = () => {
      var _a;
      (_a = filedRef.current) == null ? void 0 : _a.blur();
    };
    const focus = () => {
      var _a;
      (_a = filedRef.current) == null ? void 0 : _a.focus();
    };
    const change = (v2) => {
      var _a;
      innerEffect.current = true;
      (_a = props == null ? void 0 : props.onChange) == null ? void 0 : _a.call(props, v2);
      setValue2(v2);
    };
    const onCancel = () => {
      var _a;
      change("");
      (_a = props == null ? void 0 : props.onCancel) == null ? void 0 : _a.call(props);
    };
    const onKeypress = (event) => {
      var _a;
      if (event.key === "Enter") {
        preventDefault(event.nativeEvent);
        (_a = props == null ? void 0 : props.onSearch) == null ? void 0 : _a.call(props, value);
      }
    };
    const onClear = (event) => {
      var _a;
      change("");
      (_a = props == null ? void 0 : props.onClear) == null ? void 0 : _a.call(props, event);
    };
    const onClickInput = (event) => {
      var _a;
      (_a = props == null ? void 0 : props.onClickInput) == null ? void 0 : _a.call(props, event);
    };
    const renderLabel = () => {
      if (props.label) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$W("label"))
        }, props.label);
      }
      return null;
    };
    const renderAction = () => {
      if (props.action)
        return props.action;
      if (props.showAction) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$W("action")),
          role: "button",
          tabIndex: 0,
          onClick: onCancel
        }, props.actionText || locale.cancel);
      }
      return null;
    };
    const {
      autoFocus,
      align,
      disabled = false,
      maxLength,
      leftIcon,
      rightIcon,
      clearable = true,
      clearTrigger,
      placeholder,
      readOnly,
      error,
      errorMessage,
      formatter,
      formatTrigger,
      clearIcon
    } = props;
    const fieldPropNames = {
      align,
      leftIcon,
      rightIcon,
      clearable,
      clearTrigger,
      placeholder,
      disabled,
      maxLength,
      readOnly,
      autoFocus,
      error,
      errorMessage,
      formatter,
      formatTrigger,
      clearIcon
    };
    const renderField = () => {
      return /* @__PURE__ */ React__default["default"].createElement(FieldNamespace, __spreadValues({
        ref: filedRef,
        className: clsx(bem$W("field")),
        type: "search",
        rows: 1,
        value: value || "",
        border: false,
        onKeyPress: onKeypress,
        onFocus: props.onFocus,
        onBlur: props.onBlur,
        onChange: change,
        onClear,
        onClickInput
      }, fieldPropNames));
    };
    React.useEffect(() => {
      if (innerEffect.current) {
        innerEffect.current = false;
        return;
      }
      setValue2(props.value);
    }, [props.value]);
    React.useImperativeHandle(ref, () => ({
      focus,
      blur
    }));
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, bem$W({ "show-action": props.showAction })),
      style: __spreadProps(__spreadValues({}, props.style), { background: props.background })
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$W("content", props.shape))
    }, renderLabel(), renderField()), renderAction());
  });
  Search.defaultProps = {
    shape: "square",
    leftIcon: /* @__PURE__ */ React__default["default"].createElement(SvgSearch, null)
  };
  var index$x = "";
  const [bem$V] = createNamespace("sidebar-item");
  const SidebarItem = (props) => {
    const { parent, index: index2 } = props;
    const onClick = () => {
      var _a;
      if (props.disabled) {
        return;
      }
      (_a = props.onClick) == null ? void 0 : _a.call(props, index2);
      parent.setActive(index2);
    };
    const { dot, badge, title, disabled } = props;
    const selected = index2 === parent.getActive();
    return /* @__PURE__ */ React__default["default"].createElement("div", null, /* @__PURE__ */ React__default["default"].createElement("a", {
      className: clsx(bem$V({ select: selected, disabled })),
      onClick
    }, /* @__PURE__ */ React__default["default"].createElement(Badge, {
      dot,
      content: badge,
      className: clsx(bem$V("text"))
    }, title)));
  };
  const [bem$U] = createNamespace("sidebar");
  const Sidebar$1 = (_s) => {
    var _t = _s, {
      children,
      className,
      style
    } = _t, props = __objRest(_t, [
      "children",
      "className",
      "style"
    ]);
    const [active, updateActive] = useMergedState({
      value: props.value,
      defaultValue: props.defaultValue
    });
    const getActive = () => active;
    const setActive = (value) => {
      var _a;
      if (value !== getActive()) {
        updateActive(value);
        (_a = props.onChange) == null ? void 0 : _a.call(props, value);
      }
    };
    const validChildren = React.useMemo(() => React__default["default"].Children.toArray(children).filter(Boolean).map((child) => {
      if (!React__default["default"].isValidElement(child))
        return null;
      if (child.type !== SidebarItem) {
        return null;
      }
      return child;
    }), [children]);
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(className, bem$U("wrapper")),
      style
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.sideClassName, bem$U()),
      style: props.sideStyle
    }, validChildren.map((child, index2) => React__default["default"].cloneElement(child, {
      index: index2,
      parent: {
        setActive,
        getActive
      }
    }))), validChildren.map((child, index2) => {
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(child.props.contentClassName, bem$U("content")),
        key: child.key,
        style: __spreadProps(__spreadValues({}, child.props.contentStyle), {
          display: index2 === getActive() ? void 0 : "none"
        })
      }, child.props.children);
    }));
  };
  Sidebar$1.defaultProps = {
    defaultValue: 0
  };
  const Sidebar = Object.assign(Sidebar$1, { Item: SidebarItem });
  var index$w = "";
  var index$v = "";
  const [bem$T] = createNamespace("sticky");
  const Sticky = (props) => {
    const [state, updateState] = useSetState({
      fixed: false,
      width: 0,
      height: 0,
      transform: 0
    });
    const root2 = React.useRef(null);
    const scrollParent = useScrollParent(root2);
    const offset2 = React.useMemo(() => unitToPx(props.position === "top" ? props.offsetTop : props.offsetBottom), [props.position, props.offsetTop, props.offsetBottom]);
    const rootStyle = React.useMemo(() => {
      const { fixed, height, width } = state;
      if (fixed) {
        return {
          width: `${width}px`,
          height: `${height}px`
        };
      }
      return null;
    }, [state.fixed, state.height, state.width]);
    const stickyStyle = React.useMemo(() => {
      if (!state.fixed) {
        return null;
      }
      const style = extend(getZIndexStyle(props.zIndex), {
        width: `${state.width}px`,
        height: `${state.height}px`,
        [props.position]: `${offset2}px`
      });
      if (state.transform) {
        style.transform = `translate3d(0, ${state.transform}px, 0)`;
      }
      return style;
    }, [
      props.position,
      state.fixed,
      offset2,
      state.width,
      state.height,
      state.transform
    ]);
    const emitScroll = (scrollTop, isFixed) => {
      if (props.onScroll) {
        props.onScroll({
          scrollTop,
          isFixed
        });
      }
    };
    const onScroll = () => {
      if (!root2.current || isHidden(root2.current)) {
        return;
      }
      const { container, position } = props;
      const rootRect = useRect(root2.current);
      const scrollTop = getScrollTop$1(window);
      const newState = {};
      newState.width = rootRect.width;
      newState.height = rootRect.height;
      if (position === "top") {
        if (container) {
          const containerRect = useRect(container.current);
          const difference = containerRect.bottom - offset2 - newState.height;
          newState.fixed = offset2 > rootRect.top && containerRect.bottom > 0;
          newState.transform = difference < 0 ? difference : 0;
        } else {
          newState.fixed = offset2 > rootRect.top;
        }
      } else {
        const { clientHeight } = document.documentElement;
        if (container) {
          const containerRect = useRect(container.current);
          const difference = clientHeight - containerRect.top - offset2 - newState.height;
          newState.fixed = clientHeight - offset2 < rootRect.bottom && clientHeight > containerRect.top;
          newState.transform = difference < 0 ? -difference : 0;
        } else {
          newState.fixed = clientHeight - offset2 < rootRect.bottom;
        }
      }
      updateState(newState);
      emitScroll(scrollTop, newState.fixed);
    };
    useEventListener("scroll", onScroll, { target: scrollParent });
    useVisibilityChange(root2, onScroll);
    useUpdateEffect(() => {
      var _a;
      (_a = props.onChange) == null ? void 0 : _a.call(props, state.fixed);
    }, [state.fixed]);
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      ref: root2,
      style: rootStyle
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$T({ fixed: state.fixed })),
      style: stickyStyle
    }, props.children));
  };
  Sticky.defaultProps = {
    offsetTop: 0,
    offsetBottom: 0,
    position: "top"
  };
  const [bem$S] = createNamespace("tab");
  const TabsTitle = React.forwardRef((props, ref) => {
    const {
      type: type2,
      color,
      isActive,
      activeColor,
      inactiveColor,
      disabled,
      className
    } = props;
    const customStyle = React.useMemo(() => {
      const style = __spreadValues({}, props.style);
      const isCard = type2 === "card";
      if (color) {
        if (isCard) {
          style.borderColor = color;
        }
        if (!disabled) {
          if (isCard) {
            if (isActive) {
              style.backgroundColor = color;
            } else {
              style.color = color;
            }
          }
          if ((props.type === "line" || props.type === "jumbo") && isActive) {
            style.color = color;
          }
        }
      }
      const titleColor = isActive ? activeColor : inactiveColor;
      if (titleColor) {
        style.color = titleColor;
      }
      return style;
    }, [type2, color, disabled, isActive, activeColor, inactiveColor]);
    const renderText = () => {
      const Title2 = /* @__PURE__ */ React__default["default"].createElement("span", {
        className: clsx(bem$S("text", { ellipsis: !props.scrollable && props.type !== "jumbo" })),
        style: {
          backgroundColor: props.type === "capsule" && isActive && color
        }
      }, (() => {
        if (typeof props.title === "function") {
          return props.title(isActive);
        }
        return props.title;
      })());
      const Description = props.type === "jumbo" && !!props.description ? /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$S("description")),
        style: { backgroundColor: isActive && color }
      }, (() => {
        if (typeof props.description === "function") {
          return props.description(isActive);
        }
        return props.description;
      })()) : null;
      const measureContent = /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, Title2, Description);
      if (props.badge) {
        const badgeProps = isObject$1(props.badge) ? props.badge : { content: props.badge };
        return /* @__PURE__ */ React__default["default"].createElement(Badge, __spreadValues({}, badgeProps), measureContent);
      }
      return measureContent;
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      ref,
      className: clsx([
        bem$S({
          active: props.isActive,
          disabled: props.disabled
        }),
        className
      ]),
      style: customStyle,
      "aria-selected": props.isActive,
      onClick: props.onClick
    }, renderText());
  });
  var index$u = "";
  const [bem$R] = createNamespace("swiper-item");
  const SwiperItem = React__default["default"].forwardRef((props, ref) => {
    const wrapperRef = React__default["default"].useRef(null);
    React__default["default"].useImperativeHandle(ref, () => ({
      self: wrapperRef.current
    }));
    const [show2] = useInViewport(wrapperRef, {
      rootMargin: "-0.1px",
      threshold: 0,
      root: () => {
        var _a;
        return (_a = props.trackRef) == null ? void 0 : _a.current;
      }
    });
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      ref: wrapperRef,
      className: clsx(props.className, bem$R({
        hidden: props.autoHeight && show2 === false
      })),
      onClick: props.onClick,
      style: props.style
    }, props.children);
  });
  const [bem$Q] = createNamespace("swiper");
  const Swiper$1 = React.forwardRef((props, ref) => {
    const { loop: outerLoop, autoplay, vertical, duration, autoHeight } = props;
    const axis = vertical ? "y" : "x";
    const slideRatio = props.slideSize / 100;
    const offsetRatio = props.trackOffset / 100;
    const { validChildren, count } = React.useMemo(() => {
      let innerCount = 0;
      const innerValidChildren = React__default["default"].Children.map(props.children, (child) => {
        if (!React__default["default"].isValidElement(child))
          return null;
        if (child.type !== SwiperItem) {
          return null;
        }
        innerCount++;
        return child;
      });
      return {
        validChildren: innerValidChildren,
        count: innerCount
      };
    }, [props.children]);
    const trackRef = React.useRef(null);
    const [childrenRefs, setChildrenRefs] = useRefs();
    const [enabled, setEnabled] = React.useState(() => props.enabled);
    const [current, setCurrent] = React.useState(props.initialSwipe);
    const [dragging, setDragging, draggingRef] = useRefState(false);
    const computedStyle = React.useMemo(() => {
      return __spreadValues({
        [`--rv-swipe-slide-size`]: `${props.slideSize}%`,
        [`--rv-swipe-track-offset`]: `${props.trackOffset}%`
      }, props.style);
    }, [props.slideSize, props.trackOffset, props.style]);
    const loop2 = React.useMemo(() => {
      if (slideRatio * (count - 1) < 1)
        return false;
      return outerLoop;
    }, [count, outerLoop, slideRatio]);
    const getSlidePixels = () => {
      const track = trackRef.current;
      if (!track)
        return 0;
      const trackPixels = vertical ? track.offsetHeight : track.offsetWidth;
      return trackPixels * props.slideSize / 100;
    };
    const boundIndex = (cur) => {
      let min = 0;
      let max = count - 1;
      if (props.stuckAtBoundary) {
        min += (1 - slideRatio - offsetRatio) / slideRatio;
        max -= (1 - slideRatio - offsetRatio) / slideRatio;
      }
      return bound(cur, min, max);
    };
    const [{ position }, api] = useSpring(() => ({
      position: boundIndex(current) * 100,
      config: {
        tension: 200,
        friction: 30,
        duration
      },
      onRest: () => {
        if (draggingRef.current)
          return;
        if (!loop2)
          return;
        const rawX = position.get();
        const totalWidth = 100 * count;
        const standardPosition = modulus(rawX, totalWidth);
        if (standardPosition === rawX)
          return;
        api.start({
          position: standardPosition,
          immediate: true
        });
      }
    }), [count]);
    const bind = useDrag((state) => {
      var _a;
      const slidePixels = getSlidePixels();
      if (!slidePixels)
        return;
      if (!props.preventScroll && isScrollTarget(state.target, (_a = childrenRefs[current]) == null ? void 0 : _a.self)) {
        return;
      }
      const paramIndex = vertical ? 1 : 0;
      const offset2 = state.offset[paramIndex];
      const direction = state.direction[paramIndex];
      const velocity = state.velocity[paramIndex];
      setDragging(true);
      if (!state.last) {
        api.start({
          position: offset2 * 100 / slidePixels,
          immediate: true
        });
      } else {
        const index2 = Math.round((offset2 + Math.min(velocity * 2e3, slidePixels) * direction) / slidePixels);
        swipeTo(index2);
        window.setTimeout(() => {
          setDragging(false);
        });
      }
    }, {
      enabled,
      transform: ([x2, y2]) => [-x2, -y2],
      from: () => {
        const slidePixels = getSlidePixels();
        return [
          position.get() / 100 * slidePixels,
          position.get() / 100 * slidePixels
        ];
      },
      bounds: () => {
        if (loop2)
          return {};
        const slidePixels = getSlidePixels();
        const lowerBound = boundIndex(0) * slidePixels;
        const upperBound = boundIndex(count - 1) * slidePixels;
        return vertical ? {
          top: lowerBound,
          bottom: upperBound
        } : {
          left: lowerBound,
          right: upperBound
        };
      },
      rubberband: props.rubberband,
      axis,
      preventScroll: axis === "x" ? props.preventScroll : false,
      pointer: {
        touch: true
      }
    });
    const renderIndicator = () => {
      if (props.indicator === void 0 || props.indicator === true) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$Q("indicator", { vertical }))
        }, /* @__PURE__ */ React__default["default"].createElement(SwiperPagIndicator, __spreadProps(__spreadValues({}, props.indicatorProps), {
          vertical,
          total: count,
          current
        })));
      }
      if (typeof props.indicator === "function") {
        return props.indicator(count, current);
      }
      return null;
    };
    function swipeTo(index2, immediate = false) {
      const roundedIndex = Math.round(index2);
      const targetIndex = loop2 ? modulus(roundedIndex, count) : bound(roundedIndex, 0, count - 1);
      setCurrent(targetIndex);
      api.start({
        position: (loop2 ? roundedIndex : boundIndex(roundedIndex)) * 100,
        immediate
      });
    }
    const swipeNext = () => {
      swipeTo(Math.round(position.get() / 100) + 1);
    };
    const swipePrev = () => {
      swipeTo(Math.round(position.get() / 100) - 1);
    };
    React.useImperativeHandle(ref, () => ({
      activeIndex: current,
      swipeTo,
      swipeNext,
      swipePrev,
      enable: () => {
        setEnabled(true);
      },
      disable: () => {
        setEnabled(false);
      }
    }));
    useIsomorphicLayoutEffect(() => {
      const maxIndex = validChildren.length - 1;
      if (current > maxIndex) {
        swipeTo(maxIndex, true);
      }
    });
    useUpdateEffect(() => {
      var _a;
      (_a = props.onChange) == null ? void 0 : _a.call(props, current);
    }, [current]);
    React.useEffect(() => {
      if (!autoplay || dragging)
        return noop$3;
      const autoplayInterval = typeof autoplay === "boolean" ? 5e3 : autoplay;
      const interval = window.setInterval(() => {
        swipeNext();
      }, autoplayInterval);
      return () => {
        window.clearInterval(interval);
      };
    }, [autoplay, dragging]);
    const renderTrackInner = () => {
      if (loop2) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$Q("track-inner", {
            vertical
          }))
        }, React__default["default"].Children.map(validChildren, (child, index2) => {
          return /* @__PURE__ */ React__default["default"].createElement(animated.div, {
            className: clsx(bem$Q("slide")),
            style: {
              [axis]: position.to((pos) => {
                let finalPosition = -pos + index2 * 100;
                const totalWidth = count * 100;
                const flagWidth = totalWidth / 2;
                finalPosition = modulus(finalPosition + flagWidth, totalWidth) - flagWidth;
                return `${finalPosition}%`;
              }),
              [vertical ? "top" : "left"]: `-${index2 * 100}%`
            }
          }, React__default["default"].cloneElement(child, {
            ref: setChildrenRefs(index2),
            autoHeight,
            trackRef
          }));
        }));
      }
      return /* @__PURE__ */ React__default["default"].createElement(animated.div, {
        className: clsx(bem$Q("track-inner")),
        style: {
          [axis]: position.to((position2) => `${-position2}%`)
        }
      }, React__default["default"].Children.map(validChildren, (child, index2) => {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$Q("slide"))
        }, React__default["default"].cloneElement(child, {
          ref: setChildrenRefs(index2),
          autoHeight
        }));
      }));
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, bem$Q({ vertical })),
      style: computedStyle
    }, /* @__PURE__ */ React__default["default"].createElement("div", __spreadValues({
      ref: trackRef,
      className: clsx(bem$Q("track", {
        "allow-touch-move": props.touchable
      })),
      onClickCapture: (e2) => {
        if (draggingRef.current) {
          e2.stopPropagation();
        }
      }
    }, props.touchable ? bind() : {}), renderTrackInner()), renderIndicator());
  });
  Swiper$1.defaultProps = {
    initialSwipe: 0,
    loop: true,
    touchable: true,
    enabled: true,
    rubberband: true,
    autoplay: false,
    slideSize: 100,
    trackOffset: 0,
    stuckAtBoundary: false,
    preventScroll: true
  };
  function modulus(value, division) {
    const remainder = value % division;
    return remainder < 0 ? remainder + division : remainder;
  }
  function isScrollTarget(element, parent) {
    if (!parent)
      return false;
    if (element.scrollWidth > element.clientWidth || element.scrollHeight > element.clientHeight) {
      return true;
    }
    if (element.parentElement && element.parentElement !== parent) {
      return isScrollTarget(element.parentElement, parent);
    }
    return false;
  }
  const Swiper = Object.assign(Swiper$1, { Item: SwiperItem });
  const [bem$P] = createNamespace("tabs");
  const TabsContent = (props) => {
    const innerEffect = React.useRef(false);
    const { animated: animated2, swipeable, duration, swiperRef } = props;
    const swiperProps = typeof swipeable === "boolean" ? {} : swipeable;
    const renderChildren = () => {
      if (animated2 || swipeable) {
        return /* @__PURE__ */ React__default["default"].createElement(Swiper, __spreadProps(__spreadValues({}, swiperProps), {
          ref: swiperRef,
          rubberband: false,
          stuckAtBoundary: true,
          loop: false,
          autoplay: false,
          touchable: !!swipeable,
          className: clsx(bem$P("track")),
          duration: +duration,
          indicator: false,
          onChange: (idx) => {
            var _a;
            if (innerEffect.current) {
              innerEffect.current = false;
              return;
            }
            (_a = props.onChange) == null ? void 0 : _a.call(props, idx);
          }
        }), React__default["default"].Children.map(props.children, (child) => /* @__PURE__ */ React__default["default"].createElement(Swiper.Item, {
          style: { cursor: !swipeable ? "auto" : void 0 },
          className: clsx(bem$P("pane-wrapper"))
        }, child)));
      }
      return props.children;
    };
    const swipeToCurrentTab = (index2) => {
      const swipe = swiperRef.current;
      if (!swipe)
        return;
      if (swipe.activeIndex !== index2) {
        innerEffect.current = true;
        swipe.swipeTo(index2);
      }
    };
    React.useEffect(() => {
      swipeToCurrentTab(props.currentIndex);
    }, [props.currentIndex]);
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$P("content", {
        animated: animated2 || swipeable
      }))
    }, renderChildren());
  };
  const TabsContext = React.createContext({});
  function getScrollTop() {
    let scrollTop = 0;
    let bodyScrollTop = 0;
    let documentScrollTop = 0;
    if (document.body) {
      bodyScrollTop = document.body.scrollTop;
    }
    if (document.documentElement) {
      documentScrollTop = document.documentElement.scrollTop;
    }
    scrollTop = bodyScrollTop - documentScrollTop > 0 ? bodyScrollTop : documentScrollTop;
    return scrollTop;
  }
  function getScrollHeight() {
    let scrollHeight = 0;
    let bodyScrollHeight = 0;
    let documentScrollHeight = 0;
    if (document.body) {
      bodyScrollHeight = document.body.scrollHeight;
    }
    if (document.documentElement) {
      documentScrollHeight = document.documentElement.scrollHeight;
    }
    scrollHeight = bodyScrollHeight - documentScrollHeight > 0 ? bodyScrollHeight : documentScrollHeight;
    return scrollHeight;
  }
  function getWindowHeight() {
    let windowHeight = 0;
    if (document.compatMode === "CSS1Compat") {
      windowHeight = document.documentElement.clientHeight;
    } else {
      windowHeight = document.body.clientHeight;
    }
    return windowHeight;
  }
  function isReachBottom(offset2 = 0) {
    return getScrollTop() + getWindowHeight() + offset2 >= getScrollHeight();
  }
  const [bem$O] = createNamespace("tabs");
  const getTabName = (tab, index2) => {
    var _a;
    return (_a = tab == null ? void 0 : tab.name) != null ? _a : index2;
  };
  const Tabs$1 = React.forwardRef((props, ref) => {
    const { children, color, align, background } = props;
    const root2 = React.useRef(null);
    const swiperRef = React.useRef(null);
    const wrapRef = React.useRef(null);
    const lockScroll = React.useRef(false);
    const stickyFixed = React.useRef(false);
    const immediateRef = React.useRef(true);
    const navRef = React.useRef(null);
    const scroller = useScrollParent(root2);
    const [titleRefs, setTitleRefs] = useRefs();
    const [contentRefs, setContentRefs] = useRefs();
    const wrapHeight = React.useMemo(() => {
      if (!wrapRef.current)
        return 0;
      return getVisibleHeight(wrapRef.current);
    }, [wrapRef.current]);
    const childrenList = React.useMemo(() => parseChildList(props.children), [props.children]);
    const defaultIndex = React.useMemo(() => {
      if (props.scrollspy)
        return 0;
      const ac = props.active === void 0 ? props.defaultActive : props.active;
      let idx = childrenList.findIndex((tab, index22) => getTabName(tab, index22) === ac);
      if (idx < 0)
        idx = 0;
      return idx;
    }, [props.scrollspy, props.active, props.defaultActive]);
    const [index2, setIndex] = useRefState(defaultIndex);
    const scrollable = React.useMemo(() => childrenList.length > props.swipeThreshold || !props.ellipsis, [childrenList.length, props.swipeThreshold, props.ellipsis]);
    const navStyle = React.useMemo(() => ({
      borderColor: props.type === "card" && color,
      background
    }), [color, background]);
    const currentName = React.useMemo(() => {
      const activeTab = childrenList == null ? void 0 : childrenList[index2];
      return activeTab ? getTabName(activeTab, index2) : 0;
    }, [childrenList, index2]);
    const offsetTopPx = React.useMemo(() => unitToPx(props.offsetTop), [props.offsetTop]);
    const lineTranslateLeft = React.useMemo(() => {
      const hidden = isHidden(root2.current);
      const title = titleRefs == null ? void 0 : titleRefs[index2];
      if (!title || hidden || props.type !== "line") {
        return;
      }
      return title.offsetLeft + title.offsetWidth / 2;
    }, [root2.current, titleRefs, props.type, index2]);
    const lineStyle = React.useMemo(() => {
      const { lineWidth, lineHeight } = props;
      const measureStyle = {
        width: addUnit$1(lineWidth),
        backgroundColor: color,
        transitionDuration: `${immediateRef.current ? 0 : props.duration}ms`
      };
      if (lineTranslateLeft) {
        measureStyle.transform = `translateX(${lineTranslateLeft}px) translateX(-50%)`;
      }
      if (lineHeight) {
        const height = addUnit$1(lineHeight);
        measureStyle.height = height;
        measureStyle.borderRadius = height;
      }
      return measureStyle;
    }, [
      color,
      props.lineHeight,
      props.lineWidth,
      lineTranslateLeft,
      immediateRef.current
    ]);
    const getAvailableTab = (targetIndex) => {
      var _a;
      const diff = targetIndex < index2 ? -1 : 1;
      while (targetIndex >= 0 && targetIndex < childrenList.length) {
        if (!((_a = childrenList[targetIndex]) == null ? void 0 : _a.disabled)) {
          return targetIndex;
        }
        targetIndex += diff;
      }
      return null;
    };
    const setCurrentIndex = (currentIndex) => {
      var _a;
      const availableIndex = getAvailableTab(currentIndex);
      if (availableIndex === null)
        return;
      const newTab = childrenList[availableIndex];
      const newName = getTabName(newTab, availableIndex);
      setIndex(availableIndex);
      (_a = props.onChange) == null ? void 0 : _a.call(props, newName, availableIndex);
    };
    const scrollToCurrentContent = (current) => {
      var _a, _b;
      if (!props.scrollspy)
        return;
      const contentTarget = contentRefs[current != null ? current : index2];
      if (contentTarget && scroller) {
        const immediate = isObject$1(props.scrollspy) ? (_b = (_a = props.scrollspy) == null ? void 0 : _a.scrollImmediate) != null ? _b : true : true;
        const to2 = Math.ceil(getElementTop(contentTarget, scroller) - (offsetTopPx + wrapHeight));
        lockScroll.current = true;
        scrollTopTo(scroller, to2, immediate ? 0 : +props.duration, () => {
          lockScroll.current = false;
        });
      }
    };
    const onClickTab = (item, targetIndex, event) => {
      var _a;
      const { disabled = false } = item;
      const name = getTabName(item, targetIndex);
      (_a = props.onClickTab) == null ? void 0 : _a.call(props, {
        name,
        event,
        disabled,
        index: targetIndex
      });
      if (disabled)
        return;
      callInterceptor({
        interceptor: props.beforeChange,
        args: [name],
        done: () => {
          if (targetIndex !== index2) {
            setCurrentIndex(targetIndex);
            scrollToCurrentContent(targetIndex);
          }
        }
      });
    };
    const scrollIntoView = (immediate) => {
      const nav = navRef.current;
      const title = titleRefs == null ? void 0 : titleRefs[index2];
      if (!scrollable || !nav || !title) {
        return;
      }
      const to2 = title.offsetLeft - (nav.offsetWidth - title.offsetWidth) / 2;
      scrollLeftTo(nav, to2, immediate ? 0 : +props.duration);
    };
    const getCurrentIndexOnScroll = () => {
      const scrollOffset = offsetTopPx + wrapHeight;
      for (let index22 = 0; index22 < contentRefs.length; index22++) {
        const $el = contentRefs[index22];
        const top2 = getVisibleTop($el);
        if (top2 > scrollOffset) {
          return index22 === 0 ? 0 : index22 - 1;
        }
      }
      return titleRefs.length - 1;
    };
    const onScroll = () => {
      if (!props.scrollspy || lockScroll.current)
        return;
      let currentIndex = getCurrentIndexOnScroll();
      if (typeof props.scrollspy === "object") {
        if (props.scrollspy.autoFocusLast && isReachBottom(props.scrollspy.reachBottomThreshold)) {
          currentIndex = titleRefs.length - 1;
        }
      }
      if (currentIndex !== index2) {
        setCurrentIndex(currentIndex);
      }
    };
    const onStickyScroll = (params) => {
      var _a;
      stickyFixed.current = params.isFixed;
      (_a = props.onScroll) == null ? void 0 : _a.call(props, params);
    };
    const renderNav = () => {
      return childrenList.map((item, itemIndex) => {
        return /* @__PURE__ */ React__default["default"].createElement(TabsTitle, {
          ref: setTitleRefs(itemIndex),
          key: item.key,
          type: props.type,
          badge: item.badge,
          title: item.title,
          description: item.description,
          color,
          style: item.titleStyle,
          className: item.titleClass,
          isActive: itemIndex === index2,
          disabled: item.disabled,
          scrollable,
          activeColor: props.titleActiveColor,
          inactiveColor: props.titleInactiveColor,
          onClick: (event) => {
            onClickTab(item, itemIndex, event);
          }
        });
      });
    };
    const renderHeader = () => {
      const { type: type2, border } = props;
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        ref: wrapRef,
        className: clsx([
          bem$O("wrap", { scrollable }),
          { [BORDER_TOP_BOTTOM]: type2 !== "card" && border }
        ])
      }, /* @__PURE__ */ React__default["default"].createElement("div", {
        ref: navRef,
        role: "tablist",
        className: clsx(bem$O("nav", [
          type2,
          { complete: scrollable, start: align === "start" }
        ])),
        style: navStyle
      }, props.navLeft, renderNav(), type2 === "line" && !immediateRef.current && /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$O("line")),
        style: lineStyle
      }), props.navRight));
    };
    useUpdateEffect(() => {
      if (props.active === void 0)
        return;
      if (props.active !== currentName) {
        const currentIndex = childrenList.findIndex((tab, index22) => getTabName(tab, index22) === props.active);
        if (currentIndex > -1 && currentIndex !== index2) {
          setIndex(currentIndex);
          scrollToCurrentContent(currentIndex);
        }
      }
    }, [props.active]);
    useUpdateEffect(() => {
      scrollIntoView();
      if (stickyFixed.current && props.stickyInitScrollbar && !props.scrollspy) {
        setRootScrollTop(Math.ceil(getElementTop(root2.current) - offsetTopPx));
      }
    }, [index2]);
    React.useEffect(() => {
      immediateRef.current = false;
      scrollIntoView(true);
    }, []);
    useEventListener("scroll", onScroll, {
      target: scroller,
      depends: [index2]
    });
    React.useImperativeHandle(ref, () => {
      var _a, _b;
      return {
        scrollTo: (name) => {
          const currentIndex = childrenList.findIndex((tab, index22) => getTabName(tab, index22) === name);
          if (currentIndex > -1 && currentIndex !== index2) {
            setIndex(currentIndex);
            scrollToCurrentContent(currentIndex);
          }
        },
        swiper: swiperRef.current ? {
          enable: (_a = swiperRef.current) == null ? void 0 : _a.enable,
          disable: (_b = swiperRef.current) == null ? void 0 : _b.disable
        } : void 0
      };
    });
    return /* @__PURE__ */ React__default["default"].createElement(TabsContext.Provider, {
      value: { props, currentName, scrollIntoView }
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      ref: root2,
      className: clsx(props.className, bem$O([props.type]))
    }, props.sticky ? /* @__PURE__ */ React__default["default"].createElement(Sticky, {
      container: root2,
      offsetTop: offsetTopPx,
      onScroll: onStickyScroll
    }, renderHeader(), props.navBottom) : /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, renderHeader(), props.navBottom), /* @__PURE__ */ React__default["default"].createElement(TabsContent, {
      swiperRef,
      count: childrenList.length,
      animated: props.animated,
      duration: props.duration,
      swipeable: props.swipeable,
      lazyRender: props.lazyRender,
      currentIndex: index2,
      onChange: setCurrentIndex
    }, React__default["default"].Children.toArray(children).filter(Boolean).map((node, index22) => React__default["default"].cloneElement(node, {
      index: index22,
      ref: setContentRefs(index22)
    })))));
  });
  Tabs$1.defaultProps = {
    type: "line",
    duration: 300,
    swipeThreshold: 5,
    offsetTop: 0,
    ellipsis: true,
    lazyRender: true,
    stickyInitScrollbar: true,
    defaultActive: 0,
    align: "center"
  };
  const [bem$N] = createNamespace("tab");
  const TabPane = React.forwardRef((props, ref) => {
    const parent = React.useContext(TabsContext);
    const { animated: animated2, swipeable, scrollspy, lazyRender, lazyRenderPlaceholder } = parent.props;
    const { index: index2 } = props;
    const name = React.useMemo(() => {
      var _a;
      return (_a = props.name) != null ? _a : index2;
    }, [index2, props.name]);
    const active = React.useMemo(() => name === parent.currentName, [name, parent.currentName]);
    const [inited, setInited] = React.useState(() => active);
    const init = () => {
      setInited(true);
    };
    const isActive = React.useMemo(() => {
      if (active && !inited) {
        init();
      }
      return active;
    }, [active, inited]);
    const show2 = scrollspy || isActive;
    const shouldRender = inited || scrollspy || !lazyRender;
    const Content = shouldRender ? props.children : lazyRenderPlaceholder;
    if (animated2 || swipeable) {
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        ref,
        role: "tabpanel",
        className: clsx(bem$N("pane"))
      }, Content);
    }
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      ref,
      style: { display: show2 ? "block" : "none" },
      role: "tabpanel",
      className: clsx(bem$N("pane"))
    }, Content);
  });
  const Tabs = Object.assign(Tabs$1, { TabPane });
  var index$t = "";
  const useHeight = (element) => {
    const [height, setHeight] = React.useState(0);
    React.useEffect(() => {
      if (element.current) {
        setHeight(useRect(element.current).height);
      }
    }, [element.current]);
    return height;
  };
  const [bem$M] = createNamespace("nav-bar");
  const NavBar = (props) => {
    const navBarRef = React.useRef(null);
    const navBarHeight = useHeight(navBarRef);
    const onClickLeft = (event) => {
      if (props.onClickLeft)
        props.onClickLeft(event);
    };
    const onClickRight = (event) => {
      if (props.onClickRight)
        props.onClickRight(event);
    };
    const renderLeft = () => {
      if (typeof props.leftText !== "string" && React.isValidElement(props.leftText)) {
        return props.leftText;
      }
      return [
        props.leftArrow && React__default["default"].cloneElement(props.leftArrow, {
          key: "arroe",
          className: clsx(bem$M("arrow"))
        }),
        props.leftText && /* @__PURE__ */ React__default["default"].createElement("span", {
          key: "text",
          className: clsx(bem$M("text"))
        }, props.leftText)
      ];
    };
    const renderRight = () => {
      if (typeof props.rightText !== "string" && React.isValidElement(props.rightText)) {
        return props.rightText;
      }
      return /* @__PURE__ */ React__default["default"].createElement("span", {
        className: clsx(bem$M("text"))
      }, props.rightText);
    };
    const renderNavBar = () => {
      const { title, fixed, border, zIndex } = props;
      const style = __spreadValues({
        zIndex: zIndex !== void 0 ? +zIndex : void 0
      }, props.style);
      const hasLeft = props.leftArrow || props.leftText;
      const hasRight = props.rightText;
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        ref: navBarRef,
        style,
        className: clsx(bem$M({ fixed, "safe-area-inset-top": props.safeAreaInsetTop }), {
          [BORDER_BOTTOM]: border
        }, props.className)
      }, /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$M("content"))
      }, hasLeft && /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$M("left")),
        onClick: onClickLeft
      }, renderLeft()), /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$M("title"), "rv-ellipsis")
      }, title), hasRight && /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$M("right")),
        onClick: onClickRight
      }, renderRight())));
    };
    const renderPlaceholder = () => {
      if (props.fixed && props.placeholder) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$M("placeholder")),
          style: { height: navBarHeight ? `${navBarHeight}px` : void 0 }
        });
      }
      return null;
    };
    return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, renderPlaceholder(), renderNavBar());
  };
  NavBar.defaultProps = {
    border: true,
    leftArrow: /* @__PURE__ */ React__default["default"].createElement(SvgArrowLeft, null)
  };
  var index$s = "";
  const [bem$L] = createNamespace("tag");
  const Tag = (props) => {
    const nodeRef = React.useRef(null);
    const onClose = (event) => {
      event.stopPropagation();
      if (props.onClose) {
        props.onClose(event);
      }
    };
    const getStyle = React.useMemo(() => {
      if (props.plain) {
        return {
          color: props.textColor || props.color,
          borderColor: props.color
        };
      }
      return {
        color: props.textColor,
        background: props.color
      };
    }, [props.textColor, props.color, props.plain]);
    const renderTag = () => {
      const { type: type2, mark, plain, round: round2, size, closeable } = props;
      const classes = {
        mark,
        plain,
        round: round2
      };
      if (size) {
        classes[size] = size;
      }
      const CloseIcon = closeable && /* @__PURE__ */ React__default["default"].createElement(SvgCross, {
        className: clsx(bem$L("close")),
        onClick: onClose
      });
      return /* @__PURE__ */ React__default["default"].createElement("span", {
        ref: nodeRef,
        style: __spreadValues(__spreadValues({}, getStyle), props.style),
        className: clsx(props.className, bem$L([classes, type2])),
        onClick: props.onClick
      }, props.children, CloseIcon);
    };
    return /* @__PURE__ */ React__default["default"].createElement(CSSTransition$1, {
      nodeRef,
      classNames: "rv-fade",
      in: props.show,
      timeout: 300,
      unmountOnExit: true
    }, renderTag());
  };
  Tag.defaultProps = {
    show: true,
    type: "default"
  };
  var index$r = "";
  const [bem$K] = createNamespace("grid");
  const Grid = (_u) => {
    var _v = _u, {
      children,
      className,
      style
    } = _v, props = __objRest(_v, [
      "children",
      "className",
      "style"
    ]);
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      style: __spreadValues({ paddingLeft: addUnit$1(props.gutter) }, style),
      className: clsx(className, bem$K(), {
        [BORDER_TOP]: props.border && !props.gutter
      })
    }, React__default["default"].Children.toArray(children).filter(Boolean).map((child, index2) => React__default["default"].cloneElement(child, {
      index: index2,
      parent: props
    })));
  };
  Grid.defaultProps = {
    center: true,
    border: true,
    columnNum: 4
  };
  const [bem$J] = createNamespace("grid-item");
  const GridItem = (_w) => {
    var _x = _w, {
      children,
      className,
      style
    } = _x, props = __objRest(_x, [
      "children",
      "className",
      "style"
    ]);
    const { index: index2, parent } = props;
    const rootStyle = React.useMemo(() => {
      const { square: square2, gutter: gutter2, columnNum } = parent;
      const percent = `${100 / +columnNum}%`;
      const internalStyle = __spreadProps(__spreadValues({}, style), {
        flexBasis: percent
      });
      if (square2) {
        internalStyle.paddingTop = percent;
      } else if (gutter2) {
        const gutterValue = addUnit$1(gutter2);
        internalStyle.paddingRight = gutterValue;
        if (index2 >= columnNum) {
          internalStyle.marginTop = gutterValue;
        }
      }
      return internalStyle;
    }, [parent.style, parent.gutter, parent.columnNum]);
    const contentStyle = React.useMemo(() => {
      const { square: square2, gutter: gutter2 } = parent;
      if (square2 && gutter2) {
        const gutterValue = addUnit$1(gutter2);
        return __spreadProps(__spreadValues({}, props.contentStyle), {
          right: gutterValue,
          bottom: gutterValue,
          height: "auto"
        });
      }
      return props.contentStyle;
    }, [parent.gutter, parent.columnNum, props.contentStyle]);
    const renderIcon = () => {
      if (props.icon) {
        return /* @__PURE__ */ React__default["default"].createElement(Badge, __spreadValues({}, props.badge), React__default["default"].cloneElement(props.icon, {
          className: clsx(bem$J("icon")),
          color: props.iconColor,
          fontSize: parent.iconSize
        }));
      }
      return null;
    };
    const renderText = () => {
      if (React__default["default"].isValidElement(props.text)) {
        return props.text;
      }
      if (props.text) {
        return /* @__PURE__ */ React__default["default"].createElement("span", {
          className: clsx(bem$J("text"))
        }, props.text);
      }
      return null;
    };
    const renderContent = () => {
      if (children) {
        return children;
      }
      return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, renderIcon(), renderText());
    };
    const { center, border, square, gutter, reverse, direction } = parent;
    const classes = clsx(props.contentClassName, bem$J("content", [
      direction,
      {
        center,
        square,
        reverse,
        clickable: !!props.onClick,
        surround: border && gutter
      }
    ]), { [BORDER]: border });
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(className, bem$J({ square })),
      style: rootStyle
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      role: props.onClick ? "button" : void 0,
      className: classes,
      style: contentStyle,
      onClick: props.onClick
    }, renderContent()));
  };
  GridItem.defaultProps = {
    index: 0,
    parent: {}
  };
  const GridNamespace = Object.assign(Grid, { Item: GridItem });
  var index$q = "";
  const IndexBarContext = React.createContext({});
  const INDEX_ANCHORE_KEY = Symbol("index-anchor");
  const [bem$I] = createNamespace("index-anchor");
  const IndexAnchor = React.forwardRef((props, ref) => {
    const root2 = React.useRef();
    const height = useHeight(root2);
    const context = React.useContext(IndexBarContext);
    const [state, updateState] = useSetState({
      top: 0,
      left: 0,
      rect: { top: 0, height: 0 },
      width: 0,
      active: false
    });
    const [rect, setRect] = React.useState({ top: 0, height: 0 });
    const isSticky = React.useCallback(() => state.active && context.sticky, [state.active, context.sticky]);
    const anchorStyle = React.useMemo(() => {
      const { zIndex, highlightColor } = context;
      if (isSticky()) {
        return {
          zIndex: `${zIndex}`,
          left: state.left ? `${state.left}px` : null,
          width: state.width ? `${state.width}px` : null,
          transform: state.top ? `translate3d(0, ${state.top}px, 0)` : null,
          color: highlightColor
        };
      }
      return null;
    }, [isSticky(), state.width, state.left, state.top]);
    const getRect = (scrollParent, scrollParentRect) => {
      const rootRect = useRect(root2.current);
      const newState = __spreadValues({}, state);
      newState.rect.height = rootRect.height;
      if (scrollParent === window || scrollParent === document.body) {
        newState.rect.top = rootRect.top + getRootScrollTop();
      } else {
        newState.rect.top = rootRect.top + getScrollTop$1(scrollParent) - scrollParentRect.top;
      }
      updateState(newState);
      return newState.rect;
    };
    React.useEffect(() => {
      setRect({ top: rect.top, height });
    }, [height]);
    React.useImperativeHandle(ref, () => ({
      getRect,
      state,
      updateState,
      root: root2
    }));
    const sticky = isSticky();
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: props.className,
      ref: root2,
      style: __spreadProps(__spreadValues({}, props.style), {
        height: sticky ? `${state.rect.height}px` : void 0
      })
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      style: anchorStyle,
      className: clsx(bem$I({ sticky }), { [BORDER_BOTTOM]: sticky })
    }, props.children || props.index));
  });
  IndexAnchor[COMPONENT_TYPE_KEY] = INDEX_ANCHORE_KEY;
  const [bem$H] = createNamespace("index-bar");
  const IndexBar$1 = React.forwardRef((props, ref) => {
    const popupContext = React.useContext(PopupContext);
    const { children, sticky, zIndex, highlightColor } = props;
    const [activeAnchor, setActiveAnchor] = React.useState(null);
    const root2 = React.useRef(null);
    const sidebar = React.useRef(null);
    const touchActiveIndex = React.useRef(null);
    const touch = useTouch();
    const scrollParent = useScrollParent(root2);
    const [refs, setRefs] = useRefs();
    const sidebarStyle = React.useMemo(() => {
      if (isDef(zIndex)) {
        return {
          zIndex: +zIndex + 1
        };
      }
      return {};
    }, [zIndex]);
    const highlightStyle = React.useMemo(() => {
      if (highlightColor) {
        return {
          color: highlightColor
        };
      }
      return {};
    }, [highlightColor]);
    const getScrollerRect = () => {
      if (scrollParent.getBoundingClientRect) {
        return useRect(scrollParent);
      }
      return {
        top: 0,
        left: 0
      };
    };
    const getActiveAnchor = (scrollTop, rects) => {
      for (let i = rects.length - 1; i >= 0; i -= 1) {
        const prevHeight = i > 0 ? rects[i - 1].height : 0;
        const reachTop = props.sticky ? prevHeight + props.stickyOffsetTop : 0;
        if (scrollTop + reachTop >= rects[i].top) {
          return i;
        }
      }
      return -1;
    };
    const onScroll = () => {
      if (isHidden(root2.current) || !scrollParent) {
        return;
      }
      const { indexList } = props;
      const scrollTop = getScrollTop$1(scrollParent);
      const scrollParentRect = getScrollerRect();
      const rects = Object.values(refs).map((anchor) => {
        return anchor.getRect(scrollParent, scrollParentRect);
      });
      const active = getActiveAnchor(scrollTop, rects);
      setActiveAnchor(indexList[active]);
      if (sticky) {
        Object.values(refs).forEach((item, index2) => {
          const { updateState } = item;
          if (index2 === active || index2 === active - 1) {
            const rect = item.root.current.getBoundingClientRect();
            updateState({ left: rect.left, width: rect.width });
          } else {
            updateState({ left: null, width: null });
          }
          if (index2 === active) {
            updateState({
              active: true,
              top: Math.max(props.stickyOffsetTop, rects[index2].top - scrollTop) + scrollParentRect.top
            });
          } else if (index2 === active - 1) {
            const activeItemTop = rects[active].top - scrollTop;
            updateState({
              active: activeItemTop > 0,
              top: activeItemTop + scrollParentRect.top - rects[index2].height
            });
          } else {
            updateState({ active: false });
          }
        });
      }
    };
    const init = () => setTimeout(onScroll, 0);
    const renderIndexes = () => props.indexList.map((index2) => {
      const active = index2 === activeAnchor;
      return /* @__PURE__ */ React__default["default"].createElement("span", {
        key: index2,
        className: clsx(bem$H("index", { active })),
        style: active ? highlightStyle : null,
        "data-index": index2
      }, index2);
    });
    const onTouchStart = (event) => {
      touch.start(event);
    };
    const scrollTo = (index2) => {
      if (!index2) {
        return;
      }
      if (refs[index2]) {
        refs[index2].root.current.scrollIntoView();
        if (props.sticky && props.stickyOffsetTop) {
          if (popupContext.visible) {
            setScrollTop(scrollParent, getScrollTop$1(scrollParent) - props.stickyOffsetTop);
          } else {
            setRootScrollTop(getRootScrollTop() - props.stickyOffsetTop);
          }
        }
        if (props.onSelect && typeof props.onSelect === "function") {
          props.onSelect(activeAnchor);
        }
      }
    };
    const scrollToElement = (element) => {
      const { index: index2 } = element.dataset;
      scrollTo(index2);
    };
    const onClickSidebar = (event) => {
      scrollToElement(event.target);
    };
    const onTouchMove = (event) => {
      touch.move(event);
      preventDefault(event);
      if (touch.isVertical()) {
        const { clientX, clientY } = event.touches[0];
        const target = document.elementFromPoint(clientX, clientY);
        if (target) {
          const { index: index2 } = target.dataset;
          if (touchActiveIndex.current !== index2) {
            touchActiveIndex.current = index2;
            scrollToElement(target);
          }
        }
      }
    };
    useEventListener("scroll", onScroll, {
      target: scrollParent,
      depends: [scrollParent]
    });
    useEventListener("touchmove", onTouchMove, {
      target: sidebar.current,
      depends: [touch.deltaY]
    });
    React.useEffect(() => {
      if (props.onChange && typeof props.onChange === "function") {
        props.onChange(activeAnchor);
      }
    }, [activeAnchor]);
    useMount(init);
    const handleMapChildren = ($children) => {
      return React__default["default"].Children.toArray($children).filter(Boolean).map((child) => {
        var _a, _b;
        if (((_a = child.type) == null ? void 0 : _a[COMPONENT_TYPE_KEY]) === INDEX_ANCHORE_KEY) {
          return React__default["default"].cloneElement(child, {
            ref: setRefs(child.props.index)
          });
        }
        if ((_b = child.props) == null ? void 0 : _b.children) {
          const deepMap = handleMapChildren(child.props.children);
          return deepMap.length ? deepMap : child;
        }
        return child;
      });
    };
    React.useImperativeHandle(ref, () => ({
      scrollTo
    }));
    const memoChildren = React.useMemo(() => handleMapChildren(children), [children]);
    return /* @__PURE__ */ React__default["default"].createElement(IndexBarContext.Provider, {
      value: { zIndex, highlightColor, sticky }
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      ref: root2,
      className: clsx(bem$H(), props.className),
      style: props.style
    }, renderToContainer(props.teleport, /* @__PURE__ */ React__default["default"].createElement("div", {
      ref: sidebar,
      className: clsx(bem$H("sidebar")),
      style: sidebarStyle,
      onClick: onClickSidebar,
      onTouchStart
    }, renderIndexes())), memoChildren));
  });
  function genAlphabet() {
    const indexList = [];
    const charCodeOfA = "A".charCodeAt(0);
    for (let i = 0; i < 26; i += 1) {
      indexList.push(String.fromCharCode(charCodeOfA + i));
    }
    return indexList;
  }
  IndexBar$1.defaultProps = {
    sticky: true,
    stickyOffsetTop: 0,
    indexList: genAlphabet()
  };
  const IndexBar = Object.assign(IndexBar$1, { Anchor: IndexAnchor });
  var index$p = "";
  const CollapseContext = React.createContext({});
  const [bem$G] = createNamespace("collapse");
  const Collapse$1 = (props) => {
    const { accordion } = props;
    const initExpandedDefault = accordion ? "" : [];
    const { initExpanded = initExpandedDefault } = props;
    const innerEffect = React.useRef(false);
    const [expanded, setExpanded] = React.useState(() => {
      var _a;
      return (_a = props.value) != null ? _a : initExpanded;
    });
    const updateName = (name) => {
      var _a;
      innerEffect.current = true;
      setExpanded(name);
      (_a = props.onChange) == null ? void 0 : _a.call(props, name);
    };
    const toggle = (name, isExpanded2) => {
      if (accordion) {
        if (name === expanded) {
          name = "";
        }
      } else if (isExpanded2) {
        name = expanded.concat(name);
      } else {
        name = expanded.filter((activeName) => activeName !== name);
      }
      updateName(name);
    };
    const isExpanded = (name) => {
      return accordion ? expanded === name : expanded.includes(name);
    };
    useUpdateEffect(() => {
      if (innerEffect.current) {
        innerEffect.current = false;
        return;
      }
      setExpanded(props.value);
    }, [props.value]);
    return /* @__PURE__ */ React__default["default"].createElement(CollapseContext.Provider, {
      value: { isExpanded, toggle }
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      style: props.style,
      ref: props.nativeRef,
      className: clsx(bem$G(), props.className, {
        [BORDER_TOP_BOTTOM]: props.border
      })
    }, React__default["default"].Children.toArray(props.children).filter(Boolean).map((child, index2) => React__default["default"].cloneElement(child, {
      index: index2
    }))));
  };
  Collapse$1.defaultProps = {
    border: true
  };
  function useLazyRender(show2) {
    const [inited, setInited] = React.useState(false);
    React.useEffect(() => {
      if (show2) {
        setInited(show2);
      }
    }, [show2]);
    return (render2) => () => inited ? render2() : null;
  }
  const [bem$F] = createNamespace("collapse-item");
  const CollapseItem = React.forwardRef((_y, ref) => {
    var _z = _y, { className, style } = _z, props = __objRest(_z, ["className", "style"]);
    const { index: index2 } = props;
    const parent = React.useContext(CollapseContext);
    const wrapperRef = React.useRef(null);
    const contentRef = React.useRef(null);
    const name = React.useMemo(() => {
      var _a;
      return (_a = props.name) != null ? _a : index2;
    }, [index2, props.name]);
    const expanded = React.useMemo(() => {
      if (parent) {
        return parent.isExpanded(name);
      }
      return null;
    }, [parent, name]);
    const [show2, setShow] = React.useState(() => expanded);
    const lazyRender = useLazyRender(show2);
    const onTransitionEnd = () => {
      if (!expanded) {
        setShow(false);
      } else {
        wrapperRef.current.style.height = "";
      }
    };
    useUpdateEffect(() => {
      if (expanded) {
        setShow(true);
      }
      raf$1(() => {
        if (!contentRef.current || !wrapperRef.current) {
          return;
        }
        const { offsetHeight } = contentRef.current;
        if (offsetHeight) {
          const contentHeight = `${offsetHeight}px`;
          wrapperRef.current.style.height = expanded ? 0 : contentHeight;
          doubleRaf(() => {
            wrapperRef.current.style.height = expanded ? contentHeight : 0;
          });
        } else {
          onTransitionEnd();
        }
      });
    }, [expanded]);
    const toggle = (value = !expanded) => {
      parent.toggle(name, value);
    };
    const onClickTitle = () => {
      if (!props.disabled && !props.readOnly) {
        toggle();
      }
    };
    const renderTitle = () => {
      const _a = props, { border, disabled, children, readOnly } = _a, others = __objRest(_a, ["border", "disabled", "children", "readOnly"]);
      return /* @__PURE__ */ React__default["default"].createElement(Cell, __spreadProps(__spreadValues({
        className: clsx(bem$F("title", {
          disabled,
          expanded,
          borderless: !border
        })),
        "aria-expanded": String(expanded),
        onClick: onClickTitle
      }, others), {
        isLink: readOnly ? false : others.isLink,
        clickable: disabled || readOnly ? false : others.clickable
      }));
    };
    const renderContent = lazyRender(() => /* @__PURE__ */ React__default["default"].createElement("div", {
      ref: wrapperRef,
      className: clsx(bem$F("wrapper")),
      onTransitionEnd
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      ref: contentRef,
      className: clsx(bem$F("content"))
    }, props.children)));
    React.useImperativeHandle(ref, () => ({
      toggle
    }));
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      style,
      className: clsx(className, bem$F({ border: index2 && props.border }))
    }, renderTitle(), renderContent());
  });
  CollapseItem.defaultProps = {
    isLink: true,
    border: true
  };
  const Collapse = Object.assign(Collapse$1, { Item: CollapseItem });
  var index$o = "";
  const RadioContext = React.createContext({});
  const [bem$E] = createNamespace("radio-group");
  function RadioGroup(props) {
    const [checked, setChecked] = useMergedState({
      value: props.value,
      defaultValue: props.defaultValue
    });
    const toggle = (name) => {
      var _a;
      setChecked(name);
      (_a = props.onChange) == null ? void 0 : _a.call(props, name);
    };
    return /* @__PURE__ */ React__default["default"].createElement(RadioContext.Provider, {
      value: { parent: { props }, toggle, checked }
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, bem$E([props.direction])),
      style: props.style,
      role: "radiogroup"
    }, props.children));
  }
  const Checker = (props) => {
    const iconRef = React.useRef(null);
    const getParentProp = (name) => {
      if (props.parent && props.bindGroup) {
        return props.parent.props[name];
      }
      return null;
    };
    const disabled = React.useMemo(() => getParentProp("disabled") || props.disabled, [props.parent, props.disabled]);
    const direction = React.useMemo(() => getParentProp("direction") || null, [props.parent]);
    const iconStyle = React.useMemo(() => {
      const checkedColor = props.checkedColor || getParentProp("checkedColor");
      if (checkedColor && props.checked && !disabled) {
        return {
          borderColor: checkedColor,
          backgroundColor: checkedColor
        };
      }
      return {};
    }, [props.checkedColor, props.checked, disabled]);
    const onClick = (event) => {
      const { target } = event;
      const icon = iconRef.current;
      const iconClicked = icon === target || (icon == null ? void 0 : icon.contains(target));
      if (!disabled && (iconClicked || !props.labelDisabled)) {
        if (props.onToggle) {
          props.onToggle();
        }
      }
      if (props.onClick) {
        props.onClick(event);
      }
    };
    const renderIcon = () => {
      const { bem: bem2, shape, checked } = props;
      const iconSize = props.iconSize || getParentProp("iconSize");
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        ref: iconRef,
        className: clsx(bem2("icon", [shape, { disabled, checked }])),
        style: { fontSize: addUnit$1(iconSize) }
      }, props.iconRender ? props.iconRender({ checked, disabled }) : /* @__PURE__ */ React__default["default"].createElement(SvgSuccess, {
        style: iconStyle
      }));
    };
    const renderLabel = () => {
      if (props.children) {
        return /* @__PURE__ */ React__default["default"].createElement("span", {
          className: props.bem("label", [props.labelPosition, { disabled }])
        }, props.children);
      }
      return null;
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      role: props.role,
      className: clsx(props.bem([
        {
          disabled,
          "label-disabled": props.labelDisabled
        },
        direction
      ]), props.className),
      style: props.style,
      tabIndex: disabled ? -1 : 0,
      "aria-checked": props.checked,
      onClick
    }, props.labelPosition === "left" && renderLabel(), renderIcon(), props.labelPosition !== "left" && renderLabel());
  };
  Checker.defaultProps = {
    shape: "round",
    bindGroup: true
  };
  const [bem$D] = createNamespace("radio");
  function Radio$1(props) {
    const _a = React.useContext(RadioContext), { parent } = _a, context = __objRest(_a, ["parent"]);
    const checked = React.useMemo(() => {
      return parent ? context.checked === props.name : props.checked;
    }, [context.checked]);
    const toggle = () => {
      const emitter = parent ? context.toggle : () => {
      };
      emitter(props.name);
    };
    return /* @__PURE__ */ React__default["default"].createElement(Checker, __spreadProps(__spreadValues({}, props), {
      bem: bem$D,
      role: "radio",
      parent,
      checked,
      onToggle: toggle
    }));
  }
  const Radio = Object.assign(Radio$1, { Group: RadioGroup });
  var index$n = "";
  function getRateStatus(value, index2, allowHalf, readOnly) {
    if (value >= index2) {
      return { status: "full", value: 1 };
    }
    if (value + 0.5 >= index2 && allowHalf && !readOnly) {
      return { status: "half", value: 0.5 };
    }
    if (value + 1 >= index2 && allowHalf && readOnly) {
      const cardinal = 10 ** 10;
      return {
        status: "half",
        value: Math.round((value - index2 + 1) * cardinal) / cardinal
      };
    }
    return { status: "void", value: 0 };
  }
  const [bem$C] = createNamespace("rate");
  const Rate = (_A) => {
    var _B = _A, {
      count,
      touchable,
      onChange
    } = _B, props = __objRest(_B, [
      "count",
      "touchable",
      "onChange"
    ]);
    const [value, setValue2] = useMergedState({
      value: props.value,
      defaultValue: props.defaultValue
    });
    const root2 = React.useRef(null);
    const touch = useTouch();
    const [itemRefs, setItemRefs] = useRefs();
    const untouchable = () => props.readOnly || props.disabled || !touchable;
    const list = React.useMemo(() => Array(count).fill("").map((_, i) => getRateStatus(value, i + 1, props.allowHalf, props.readOnly)), [count, value, props.allowHalf, props.readOnly]);
    const ranges = React.useRef();
    const updateRanges = () => {
      const rects = itemRefs.map((item) => item.getBoundingClientRect());
      ranges.current = [];
      rects.forEach((rect, index2) => {
        if (props.allowHalf) {
          ranges.current.push({ score: index2 + 0.5, left: rect.left }, { score: index2 + 1, left: rect.left + rect.width / 2 });
        } else {
          ranges.current.push({ score: index2 + 1, left: rect.left });
        }
      });
    };
    const getScoreByPosition = (x2) => {
      for (let i = ranges.current.length - 1; i > 0; i--) {
        if (x2 > ranges.current[i].left) {
          return ranges.current[i].score;
        }
      }
      return props.allowHalf ? 0.5 : 1;
    };
    const select = (index2) => {
      if (!props.disabled && !props.readOnly && index2 !== value) {
        setValue2(index2);
        onChange == null ? void 0 : onChange(index2);
      }
    };
    const onTouchStart = (event) => {
      if (untouchable()) {
        return;
      }
      touch.start(event.nativeEvent);
      updateRanges();
    };
    const onTouchMove = (event) => {
      if (untouchable()) {
        return;
      }
      touch.move(event);
      if (touch.isHorizontal()) {
        const { clientX } = event.touches[0];
        preventDefault(event);
        select(getScoreByPosition(clientX));
      }
    };
    const renderStar = (item, index2) => {
      const {
        icon,
        size,
        color,
        gutter,
        voidIcon,
        disabled,
        voidColor,
        allowHalf,
        disabledColor
      } = props;
      const score = index2 + 1;
      const isFull = item.status === "full";
      const isVoid = item.status === "void";
      const renderHalf = allowHalf && item.value > 0 && item.value < 1;
      let style;
      if (gutter && score !== +count) {
        style = {
          marginRight: addUnit$1(gutter)
        };
      }
      const onClickItem = (event) => {
        updateRanges();
        select(allowHalf ? getScoreByPosition(event.clientX) : score);
      };
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        key: index2,
        ref: setItemRefs(index2),
        role: "radio",
        style,
        className: clsx(bem$C("item")),
        tabIndex: 0,
        "aria-setsize": parseInt(count == null ? void 0 : count.toString(), 10),
        "aria-posinset": score,
        "aria-checked": !isVoid,
        onClick: onClickItem
      }, React__default["default"].cloneElement(isFull ? icon : voidIcon, {
        className: clsx(bem$C("icon", { disabled, full: isFull })),
        style: {
          color: disabled ? disabledColor : isFull ? color : voidColor,
          fontSize: size
        }
      }), renderHalf && /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$C("icon", ["half"])),
        style: { width: `${item.value * 100}%` }
      }, React__default["default"].cloneElement(isVoid ? voidIcon : icon, {
        className: clsx(bem$C("icon", [{ disabled, full: !isVoid }])),
        style: {
          color: disabled ? disabledColor : isVoid ? voidColor : color,
          fontSize: size
        }
      })));
    };
    useEventListener("touchmove", onTouchMove, {
      target: root2.current,
      depends: [touch.deltaY.current]
    });
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      ref: root2,
      role: "radiogroup",
      className: clsx(bem$C({
        readOnly: props.readOnly,
        disabled: props.disabled
      })),
      tabIndex: 0,
      onTouchStart
    }, list.map(renderStar));
  };
  Rate.defaultProps = {
    size: 20,
    count: 5,
    gutter: 4,
    icon: /* @__PURE__ */ React__default["default"].createElement(SvgStar, null),
    voidIcon: /* @__PURE__ */ React__default["default"].createElement(SvgStarO, null),
    touchable: true
  };
  var index$m = "";
  function formatMonthTitle(date2) {
    return [date2.getFullYear(), date2.getMonth() + 1];
  }
  function compareMonth(date1, date2) {
    const year1 = date1.getFullYear();
    const year2 = date2.getFullYear();
    if (year1 === year2) {
      const month1 = date1.getMonth();
      const month2 = date2.getMonth();
      return month1 === month2 ? 0 : month1 > month2 ? 1 : -1;
    }
    return year1 > year2 ? 1 : -1;
  }
  function compareDay(day1, day2) {
    const compareMonthResult = compareMonth(day1, day2);
    if (compareMonthResult === 0) {
      const date1 = day1.getDate();
      const date2 = day2.getDate();
      return date1 === date2 ? 0 : date1 > date2 ? 1 : -1;
    }
    return compareMonthResult;
  }
  const cloneDate = (date2) => new Date(date2);
  const cloneDates = (dates) => Array.isArray(dates) ? dates.map(cloneDate) : cloneDate(dates);
  function getDayByOffset(date2, offset2) {
    const cloned = cloneDate(date2);
    cloned.setDate(cloned.getDate() + offset2);
    return cloned;
  }
  const getPrevDay = (date2) => getDayByOffset(date2, -1);
  const getNextDay = (date2) => getDayByOffset(date2, 1);
  const getToday = () => {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    return today;
  };
  function calcDateNum(date2) {
    const day1 = date2[0].getTime();
    const day2 = date2[1].getTime();
    return (day2 - day1) / (1e3 * 60 * 60 * 24) + 1;
  }
  function times(n2, iteratee) {
    let index2 = -1;
    const result = Array(n2);
    while (++index2 < n2) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  function getTrueValue(value) {
    if (!value) {
      return 0;
    }
    while (isNaN$1(parseInt(value, 10))) {
      if (value.length > 1) {
        value = value.slice(1);
      } else {
        return 0;
      }
    }
    return parseInt(value, 10);
  }
  function getMonthEndDay(year, month) {
    return 32 - new Date(year, month - 1, 32).getDate();
  }
  const [bem$B] = createNamespace("calendar");
  const CalenderDay = (props) => {
    const style = React.useMemo(() => {
      const { item, index: index2, color, offset: offset2, rowHeight } = props;
      const iternalStyle = {
        height: rowHeight
      };
      if (item.type === "placeholder") {
        iternalStyle.width = "100%";
        return iternalStyle;
      }
      if (index2 === 0) {
        iternalStyle.marginLeft = `${100 * offset2 / 7}%`;
      }
      if (color) {
        switch (item.type) {
          case "end":
          case "start":
          case "start-end":
          case "multiple-middle":
          case "multiple-selected":
            iternalStyle.background = color;
            break;
          case "middle":
            iternalStyle.color = color;
            break;
        }
      }
      return iternalStyle;
    }, [props.item, props.index, props.color, props.offset, props.rowHeight]);
    const onClick = () => {
      var _a;
      if (props.item.type !== "disabled") {
        (_a = props.onClick) == null ? void 0 : _a.call(props, props.item);
      }
    };
    const renderTopInfo = () => {
      const { topInfo } = props.item;
      if (topInfo || props.topInfoRender) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$B("top-info"))
        }, props.topInfoRender ? props.topInfoRender(props.item) : topInfo);
      }
      return null;
    };
    const renderBottomInfo = () => {
      const { bottomInfo } = props.item;
      if (bottomInfo || props.bottomInfoRender) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$B("bottom-info"))
        }, props.bottomInfoRender ? props.bottomInfoRender(props.item) : bottomInfo);
      }
      return null;
    };
    const renderContent = () => {
      const { item, color, rowHeight } = props;
      const { type: type22, text } = item;
      const Nodes = /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, renderTopInfo(), text, renderBottomInfo());
      if (type22 === "selected") {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$B("selected-day")),
          style: {
            width: rowHeight,
            height: rowHeight,
            background: color
          }
        }, Nodes);
      }
      return Nodes;
    };
    const { type: type2, className } = props.item;
    if (type2 === "placeholder") {
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$B("day")),
        style
      });
    }
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      role: "gridcell",
      style,
      className: clsx(bem$B("day", type2), className),
      tabIndex: type2 === "disabled" ? void 0 : -1,
      onClick
    }, renderContent());
  };
  CalenderDay.defaultProps = {
    offset: 0
  };
  const [bem$A] = createNamespace("calendar");
  const CalenderMonth = React.forwardRef((props, ref) => {
    const [visible, setVisible] = React.useState();
    const daysRef = React.useRef();
    const [monthRef, setMonthRef] = React.useState();
    const height = React.useRef(0);
    const { locale } = React.useContext(ConfigProvider$1);
    React.useEffect(() => {
      if (monthRef) {
        height.current = useRect(monthRef).height;
      }
    }, [monthRef]);
    const title = React.useMemo(() => {
      return props.formatMonthTitle ? props.formatMonthTitle(props.date) : locale.vanCalendar.monthTitle(...formatMonthTitle(props.date));
    }, [props.date, props.formatMonthTitle]);
    const rowHeight = React.useMemo(() => addUnit$1(props.rowHeight), [props.rowHeight]);
    const offset2 = React.useMemo(() => {
      const realDay = props.date.getDay();
      if (props.firstDayOfWeek) {
        return (realDay + 7 - props.firstDayOfWeek) % 7;
      }
      return realDay;
    }, [props.date, props.firstDayOfWeek]);
    const totalDay = React.useMemo(() => getMonthEndDay(props.date.getFullYear(), props.date.getMonth() + 1), [props.date]);
    const shouldRender = React.useMemo(() => visible || !props.lazyRender, [visible]);
    const getTitle = () => title;
    const scrollIntoView = (body) => {
      const el = props.showSubtitle ? daysRef.current : monthRef;
      const scrollTop = (el == null ? void 0 : el.getBoundingClientRect().top) - body.getBoundingClientRect().top + body.scrollTop;
      setScrollTop(body, scrollTop);
    };
    const getMultipleDayType = (day) => {
      const isSelected = (date2) => props.currentDate.some((item) => compareDay(item, date2) === 0);
      if (isSelected(day)) {
        const prevDay = getPrevDay(day);
        const nextDay = getNextDay(day);
        const prevSelected = isSelected(prevDay);
        const nextSelected = isSelected(nextDay);
        if (prevSelected && nextSelected) {
          return "multiple-middle";
        }
        if (prevSelected) {
          return "end";
        }
        if (nextSelected) {
          return "start";
        }
        return "multiple-selected";
      }
      return "";
    };
    const getRangeDayType = (day) => {
      const [startDay, endDay] = props.currentDate;
      if (!startDay) {
        return "";
      }
      const compareToStart = compareDay(day, startDay);
      if (!endDay) {
        return compareToStart === 0 ? "start" : "";
      }
      const compareToEnd = compareDay(day, endDay);
      if (props.allowSameDay && compareToStart === 0 && compareToEnd === 0) {
        return "start-end";
      }
      if (compareToStart === 0) {
        return "start";
      }
      if (compareToEnd === 0) {
        return "end";
      }
      if (compareToStart > 0 && compareToEnd < 0) {
        return "middle";
      }
      return "";
    };
    const getDayType = (day) => {
      const { type: type2, minDate, maxDate, currentDate } = props;
      if (compareDay(day, minDate) < 0 || compareDay(day, maxDate) > 0) {
        return "disabled";
      }
      if (currentDate === null) {
        return "";
      }
      if (Array.isArray(currentDate)) {
        if (type2 === "multiple") {
          return getMultipleDayType(day);
        }
        if (type2 === "range") {
          return getRangeDayType(day);
        }
      } else if (type2 === "single") {
        return compareDay(day, currentDate) === 0 ? "selected" : "";
      }
      return "";
    };
    const getBottomInfo = (dayType) => {
      if (props.type === "range") {
        if (dayType === "start") {
          return locale.vanCalendar.start;
        }
        if (dayType === "end") {
          return locale.vanCalendar.end;
        }
        if (dayType === "start-end") {
          return locale.vanCalendar.startEnd;
        }
      }
      return null;
    };
    const renderTitle = () => {
      if (props.showMonthTitle) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$A("month-title"))
        }, title);
      }
      return null;
    };
    const renderMark = () => {
      if (props.showMark && shouldRender) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$A("month-mark"))
        }, props.date.getMonth() + 1);
      }
      return null;
    };
    const placeholders = React.useMemo(() => {
      const count = Math.ceil((totalDay + offset2) / 7);
      return Array(count).fill({ type: "placeholder" });
    }, [totalDay, offset2]);
    const days = React.useMemo(() => {
      const internalDays = [];
      const year = props.date.getFullYear();
      const month = props.date.getMonth();
      for (let day = 1; day <= totalDay; day++) {
        const date2 = new Date(year, month, day);
        const type2 = getDayType(date2);
        let config2 = {
          date: date2,
          type: type2,
          text: day,
          bottomInfo: getBottomInfo(type2)
        };
        if (props.formatter) {
          config2 = props.formatter(config2);
        }
        internalDays.push(config2);
      }
      return internalDays;
    }, [getDayType, props.date, props.formatter]);
    const renderDay = (item, index2) => /* @__PURE__ */ React__default["default"].createElement(CalenderDay, {
      key: index2,
      item,
      index: index2,
      color: props.color,
      offset: offset2,
      rowHeight,
      onClick: props.onClick,
      topInfoRender: props.topInfoRender,
      bottomInfoRender: props.bottomInfoRender
    });
    const renderDays = () => /* @__PURE__ */ React__default["default"].createElement("div", {
      ref: daysRef,
      role: "grid",
      className: clsx(bem$A("days"))
    }, renderMark(), (shouldRender ? days : placeholders).map(renderDay));
    React.useImperativeHandle(ref, () => ({
      getTitle,
      getHeight: () => height.current,
      setVisible,
      scrollIntoView
    }));
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$A("month")),
      ref: setMonthRef
    }, renderTitle(), renderDays());
  });
  const [bem$z] = createNamespace("calendar");
  const CalenderHeader = (props) => {
    const { locale } = React.useContext(ConfigProvider$1);
    const renderTitle = () => {
      if (props.showTitle) {
        const text = props.title || locale.vanCalendar.title;
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$z("header-title"))
        }, text);
      }
      return null;
    };
    const onClickSubtitle = (event) => {
      var _a;
      (_a = props.onClickSubtitle) == null ? void 0 : _a.call(props, event);
    };
    const renderSubtitle = () => {
      if (props.showSubtitle) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$z("header-subtitle")),
          onClick: onClickSubtitle
        }, props.subtitle);
      }
      return null;
    };
    const renderWeekDays = () => {
      const { weekdays: customWeekdays, firstDayOfWeek } = props;
      const defaultWeekdays = locale.vanCalendar.weekdays;
      const weekdays = customWeekdays ? defaultWeekdays.map((wk, i) => customWeekdays[i] || wk) : defaultWeekdays;
      const renderWeekDaysContent = [
        ...weekdays.slice(firstDayOfWeek, 7),
        ...weekdays.slice(0, firstDayOfWeek)
      ];
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$z("weekdays"))
      }, renderWeekDaysContent.map((text, i) => /* @__PURE__ */ React__default["default"].createElement("span", {
        key: i,
        className: clsx(bem$z("weekday"))
      }, text)));
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$z("header"))
    }, renderTitle(), renderSubtitle(), renderWeekDays());
  };
  const [bem$y] = createNamespace("calendar");
  const Calendar = React.forwardRef((_C, ref) => {
    var _D = _C, { className, style } = _D, props = __objRest(_D, ["className", "style"]);
    var _a;
    const { locale } = React.useContext(ConfigProvider$1);
    const [visible, setVisible] = usePropsValue({
      value: props.visible,
      defaultValue: false,
      onChange: (v2) => {
        var _a2;
        if (v2 === false) {
          (_a2 = props.onClose) == null ? void 0 : _a2.call(props);
        }
      }
    });
    const limitDateRange = (date2, minDate = props.minDate, maxDate = props.maxDate) => {
      if (compareDay(date2, minDate) === -1) {
        return minDate;
      }
      if (compareDay(date2, maxDate) === 1) {
        return maxDate;
      }
      return date2;
    };
    const getInitialDate = (defaultDate = props.defaultValue) => {
      const { type: type2, minDate, maxDate } = props;
      if (defaultDate === null) {
        return defaultDate;
      }
      const now = getToday();
      if (type2 === "range") {
        if (!Array.isArray(defaultDate)) {
          defaultDate = [];
        }
        const start2 = limitDateRange(defaultDate[0] || now, minDate, getPrevDay(maxDate));
        const end2 = limitDateRange(defaultDate[1] || now, getNextDay(minDate));
        return [start2, end2];
      }
      if (type2 === "multiple") {
        if (Array.isArray(defaultDate)) {
          return defaultDate.map((date2) => limitDateRange(date2));
        }
        return [limitDateRange(now)];
      }
      if (!defaultDate || Array.isArray(defaultDate)) {
        defaultDate = now;
      }
      return limitDateRange(defaultDate);
    };
    const bodyRef = React.useRef();
    const bodyHeightRef = React.useRef(0);
    const [value, setValue2] = React__default["default"].useState(getInitialDate(props.value === void 0 ? props.defaultValue : props.value));
    const [state, updateState] = useSetState({
      subtitle: "",
      currentDate: value
    });
    useUpdateEffect(() => {
      if (props.value === void 0)
        return;
      if (JSON.stringify(value) !== JSON.stringify(props.value)) {
        setValue2(props.value);
      }
    }, [props.value]);
    React.useEffect(() => {
      if (JSON.stringify(state.currentDate) !== JSON.stringify(value)) {
        updateState({ currentDate: value });
      }
    }, [value]);
    const [monthRefs, setMonthRefs] = useRefs();
    const dayOffset = React.useMemo(() => props.firstDayOfWeek ? +props.firstDayOfWeek % 7 : 0, [props.firstDayOfWeek, props.firstDayOfWeek]);
    const months = React.useMemo(() => {
      const internalMonths = [];
      const cursor = new Date(props.minDate);
      cursor.setDate(1);
      do {
        internalMonths.push(new Date(cursor));
        cursor.setMonth(cursor.getMonth() + 1);
      } while (compareMonth(cursor, props.maxDate) !== 1);
      return internalMonths;
    }, [props.minDate, props.maxDate]);
    const buttonDisabled = React.useMemo(() => {
      const { currentDate } = state;
      if (currentDate) {
        if (props.type === "range") {
          return !currentDate[0] || !currentDate[1];
        }
        if (props.type === "multiple") {
          return !currentDate.length;
        }
      }
      return !currentDate;
    }, [props.type, state.currentDate]);
    const onScroll = () => {
      var _a2;
      const top2 = getScrollTop$1(bodyRef.current);
      const bottom2 = top2 + bodyHeightRef.current;
      const heights = months.map((item, index2) => monthRefs[index2].getHeight());
      const heightSum = heights.reduce((a, b2) => a + b2, 0);
      if (bottom2 > heightSum && top2 > 0) {
        return;
      }
      let height = 0;
      let currentMonth;
      const visibleRange = [-1, -1];
      for (let i = 0; i < months.length; i++) {
        const month = monthRefs[i];
        const visible2 = height <= bottom2 && height + heights[i] >= top2;
        if (visible2) {
          visibleRange[1] = i;
          if (!currentMonth) {
            currentMonth = month;
            visibleRange[0] = i;
          }
          if (!monthRefs[i].showed) {
            monthRefs[i].showed = true;
            (_a2 = props.onMonthShow) == null ? void 0 : _a2.call(props, {
              date: month.date,
              title: month.getTitle()
            });
          }
        }
        height += heights[i];
      }
      months.forEach((_, index2) => {
        const visible2 = index2 >= visibleRange[0] - 1 && index2 <= visibleRange[1] + 1;
        monthRefs[index2].setVisible(visible2);
      });
      if (currentMonth && currentMonth.getTitle() !== state.subtitle) {
        updateState({ subtitle: currentMonth.getTitle() });
      }
    };
    const scrollToDate = (targetDate) => {
      raf$1(() => {
        months.some((month, index2) => {
          if (compareMonth(month, targetDate) === 0) {
            if (bodyRef.current) {
              monthRefs[index2].scrollIntoView(bodyRef.current);
            }
            return true;
          }
          return false;
        });
        onScroll();
      });
    };
    const scrollIntoView = () => {
      if (props.poppable && !visible) {
        return;
      }
      const { currentDate } = state;
      if (currentDate) {
        const targetDate = props.type === "single" ? currentDate : currentDate[0];
        scrollToDate(targetDate);
      } else {
        raf$1(onScroll);
      }
    };
    const init = () => {
      raf$1(() => {
        bodyHeightRef.current = Math.floor(useRect(bodyRef.current).height);
        scrollIntoView();
      });
    };
    const reset = (date2 = getInitialDate()) => {
      updateState({ currentDate: date2 });
      scrollIntoView();
    };
    const checkRange = (date2) => {
      var _a2;
      const { maxRange, rangePrompt, showRangePrompt } = props;
      if (maxRange && calcDateNum(date2) > maxRange) {
        if (showRangePrompt) {
          Toast.info(rangePrompt || locale.vanCalendar.rangePrompt(+maxRange));
        }
        (_a2 = props.onOverRange) == null ? void 0 : _a2.call(props);
        return false;
      }
      return true;
    };
    const onConfirm = () => {
      var _a2;
      const nextCurrentDate = cloneDates(state.currentDate);
      if (props.poppable) {
        setValue2(nextCurrentDate);
      }
      (_a2 = props.onConfirm) == null ? void 0 : _a2.call(props, nextCurrentDate);
      actions.close();
    };
    const select = (date2, complete) => {
      const setCurrentDate = (current) => {
        var _a2;
        state.currentDate = current;
        updateState({ currentDate: current });
        (_a2 = props.onSelect) == null ? void 0 : _a2.call(props, cloneDates(state.currentDate));
      };
      if (complete && props.type === "range") {
        const valid = checkRange(date2);
        if (!valid) {
          if (props.showConfirm) {
            setCurrentDate([
              date2[0],
              getDayByOffset(date2[0], +props.maxRange - 1)
            ]);
          } else {
            setCurrentDate(date2);
          }
          return;
        }
      }
      setCurrentDate(date2);
      if (complete && !props.showConfirm) {
        onConfirm();
      }
    };
    const onClickDay = (item) => {
      var _a2;
      if (props.readOnly || !item.date) {
        return;
      }
      const { date: date2 } = item;
      const { type: type2 } = props;
      const { currentDate } = state;
      if (type2 === "range") {
        if (!currentDate) {
          select([date2]);
          return;
        }
        const [startDay, endDay] = currentDate;
        if (startDay && !endDay) {
          const compareToStart = compareDay(date2, startDay);
          if (compareToStart === 1) {
            select([startDay, date2], true);
          } else if (compareToStart === -1) {
            select([date2]);
          } else if (props.allowSameDay) {
            select([date2, date2], true);
          }
        } else {
          select([date2]);
        }
      } else if (type2 === "multiple") {
        if (!currentDate) {
          select([date2]);
          return;
        }
        let selectedIndex;
        const selected = state.currentDate.some((dateItem, index2) => {
          const equal = compareDay(dateItem, date2) === 0;
          if (equal) {
            selectedIndex = index2;
          }
          return equal;
        });
        if (selected) {
          const [unselectedDate] = currentDate.splice(selectedIndex, 1);
          (_a2 = props.onUnselect) == null ? void 0 : _a2.call(props, cloneDate(unselectedDate));
          select([...currentDate]);
        } else if (props.maxRange && currentDate.length >= props.maxRange) {
          Toast(props.rangePrompt || `\u9009\u62E9\u5929\u6570\u4E0D\u80FD\u8D85\u8FC7 ${props.maxRange} \u5929`);
        } else {
          select([...currentDate, date2]);
        }
      } else {
        select(date2, true);
      }
    };
    const renderMonth = (date2, index2) => {
      const showMonthTitle = index2 !== 0 || !props.showSubtitle;
      return /* @__PURE__ */ React__default["default"].createElement(CalenderMonth, __spreadProps(__spreadValues({
        key: index2,
        ref: setMonthRefs(index2),
        date: date2,
        currentDate: state.currentDate,
        showMonthTitle,
        firstDayOfWeek: dayOffset
      }, pick(props, [
        "type",
        "color",
        "minDate",
        "maxDate",
        "showMark",
        "formatter",
        "rowHeight",
        "showSubtitle",
        "lazyRender",
        "allowSameDay",
        "topInfoRender",
        "bottomInfoRender",
        "formatMonthTitle"
      ])), {
        onClick: onClickDay
      }));
    };
    const renderFooterButton = () => {
      if (props.footer) {
        return props.footer;
      }
      if (props.showConfirm) {
        const text = buttonDisabled ? props.confirmDisabledText : props.confirmText;
        return /* @__PURE__ */ React__default["default"].createElement(Button, {
          round: true,
          block: true,
          type: "danger",
          color: props.color,
          className: clsx(bem$y("confirm")),
          disabled: buttonDisabled,
          nativeType: "button",
          onClick: onConfirm
        }, text || locale.vanCalendar.confirm);
      }
      return null;
    };
    const renderFooter = () => /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$y("footer"), {
        "rv-safe-area-bottom": props.safeAreaInsetBottom
      })
    }, renderFooterButton());
    const renderCalendar = () => /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(className, bem$y()),
      style
    }, /* @__PURE__ */ React__default["default"].createElement(CalenderHeader, {
      weekdays: props.weekdays,
      title: props.title,
      subtitle: props.subtitle || state.subtitle,
      showTitle: props.showTitle,
      showSubtitle: props.showSubtitle,
      firstDayOfWeek: dayOffset,
      onClickSubtitle: (event) => {
        var _a2;
        (_a2 = props.onClickSubtitle) == null ? void 0 : _a2.call(props, event);
      }
    }), /* @__PURE__ */ React__default["default"].createElement("div", {
      ref: bodyRef,
      className: clsx(bem$y("body")),
      onScroll
    }, months.map(renderMonth)), renderFooter());
    const actions = {
      toggle: () => {
        if (props.poppable)
          setVisible((v2) => !v2);
      },
      open: () => {
        if (props.poppable) {
          setVisible(true);
        }
      },
      close: () => {
        if (props.poppable) {
          setVisible(false);
        }
      }
    };
    React.useEffect(() => {
      if (!props.poppable) {
        init();
      }
    }, []);
    React.useEffect(() => {
      if (props.poppable && visible) {
        init();
      }
    }, [visible]);
    useUpdateEffect(() => {
      reset(getInitialDate(state.currentDate));
    }, [props.type, props.minDate, props.maxDate]);
    React.useImperativeHandle(ref, () => __spreadValues({
      reset,
      scrollToDate
    }, actions));
    if (props.poppable) {
      return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, /* @__PURE__ */ React__default["default"].createElement(Popup, {
        visible,
        className: clsx(bem$y("popup")),
        round: props.round,
        position: props.position,
        closeable: props.showTitle || props.showSubtitle,
        closeOnPopstate: props.closeOnPopstate,
        closeOnClickOverlay: props.closeOnClickOverlay,
        onClose: actions.close,
        onClosed: () => {
          var _a2;
          if (props.poppable && JSON.stringify(state.currentDate) !== JSON.stringify(value)) {
            updateState({ currentDate: value });
          }
          (_a2 = props.onClosed) == null ? void 0 : _a2.call(props);
        }
      }, renderCalendar()), (_a = props.children) == null ? void 0 : _a.call(props, value, actions));
    }
    return renderCalendar();
  });
  Calendar.defaultProps = {
    round: true,
    poppable: true,
    showMark: true,
    showTitle: true,
    showConfirm: true,
    showSubtitle: true,
    closeOnPopstate: true,
    closeOnClickOverlay: true,
    safeAreaInsetBottom: true,
    defaultValue: null,
    type: "single",
    position: "bottom",
    maxRange: null,
    minDate: getToday(),
    maxDate: (() => {
      const now = getToday();
      return new Date(now.getFullYear(), now.getMonth() + 6, now.getDate());
    })(),
    firstDayOfWeek: 0,
    showRangePrompt: true
  };
  var index$l = "";
  function useCascaderExtend(options, keys, value) {
    const { childrenKey, valueKey } = keys;
    const depth = React.useMemo(() => {
      let depth2 = 0;
      function traverse(options2, currentDepth) {
        if (currentDepth > depth2)
          depth2 = currentDepth;
        const nextDepth = currentDepth + 1;
        options2.forEach((option) => {
          if (option[childrenKey]) {
            traverse(option[childrenKey], nextDepth);
          }
        });
      }
      traverse(options, 1);
      return depth2;
    }, [options, childrenKey]);
    const tabs = React.useMemo(() => {
      if (!value || !value.length) {
        return [options];
      }
      return value.reduce((a, v2, i) => {
        if (!v2)
          return a;
        const next = a[i].find((option) => option[valueKey] === value[i]);
        if (next && next[childrenKey])
          a.push(next[childrenKey]);
        return a;
      }, [options]);
    }, [value, childrenKey, valueKey, options]);
    const items = React.useMemo(() => {
      return value.map((val, i) => {
        var _a;
        const item = (_a = tabs[i].find((tab) => tab[valueKey] === val)) != null ? _a : void 0;
        return item;
      });
    }, [value, valueKey, tabs]);
    return { tabs, items, depth };
  }
  function useDebounceFn(fn, options) {
    var _a;
    const fnRef = useLatest(fn);
    const wait = (_a = options == null ? void 0 : options.wait) != null ? _a : 1e3;
    const debounced = React.useMemo(() => debounce((...args) => {
      return fnRef.current(...args);
    }, wait, options), []);
    useUnmount(() => {
      debounced.cancel();
    });
    return {
      run: debounced,
      cancel: debounced.cancel,
      flush: debounced.flush
    };
  }
  function useDebounceEffect(effect3, deps, options) {
    const [flag, setFlag] = React.useState({});
    const { run } = useDebounceFn(() => {
      setFlag({});
    }, options);
    React.useEffect(() => {
      return run();
    }, deps);
    useUpdateEffect(effect3, [flag]);
  }
  const [bem$x] = createNamespace("cascader");
  const Cascader = (props) => {
    const { locale } = React.useContext(ConfigProvider$1);
    const [value, setValue2] = React.useState(() => props.value === void 0 ? props.defaultValue : props.value);
    const [activeTab, updateActiveTab] = React.useState(0);
    const {
      text: textKey,
      value: valueKey,
      children: childrenKey
    } = extend({
      text: "text",
      value: "value",
      children: "children"
    }, props.fieldNames);
    const { tabs, items, depth } = useCascaderExtend(props.options, { textKey, valueKey, childrenKey }, value || []);
    useUpdateEffect(() => {
      if (props.value === void 0)
        return;
      if (JSON.stringify(value) !== JSON.stringify(props.value)) {
        setValue2(props.value);
      }
    }, [props.value]);
    React.useEffect(() => {
      let tabIndex = 0;
      if (Array.isArray(value) && value.length > 0)
        tabIndex = value.length;
      if (tabIndex >= depth)
        tabIndex = depth - 1;
      if (tabIndex === activeTab)
        return;
      updateActiveTab(tabIndex);
    }, [value]);
    useDebounceEffect(() => {
      var _a, _b;
      if (JSON.stringify(props.value) === JSON.stringify(value))
        return;
      (_a = props.onChange) == null ? void 0 : _a.call(props, value, items);
      if (value.length >= depth) {
        (_b = props.onFinish) == null ? void 0 : _b.call(props, value, items);
      }
    }, [value], {
      wait: 0,
      leading: false,
      trailing: true
    });
    const onSelect = (option, tabIndex) => {
      if (option.disabled) {
        return;
      }
      setValue2((prev2) => {
        const next = [...prev2];
        next[tabIndex] = option == null ? void 0 : option[valueKey];
        return next.slice(0, tabIndex + 1);
      });
    };
    const onClickTab = ({ name, index: index2 }) => {
      var _a;
      (_a = props.onClickTab) == null ? void 0 : _a.call(props, +name);
      updateActiveTab(index2);
    };
    const renderCloseIcon = () => {
      if (!props.closeable)
        return null;
      if (props.closeIcon) {
        return React__default["default"].cloneElement(props.closeIcon, {
          className: clsx(bem$x("close-icon")),
          onClick: props.onClose
        });
      }
      return /* @__PURE__ */ React__default["default"].createElement(SvgCross, {
        className: clsx(bem$x("close-icon")),
        onClick: props.onClose
      });
    };
    const renderHeader = () => /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$x("header"))
    }, /* @__PURE__ */ React__default["default"].createElement("h2", {
      className: clsx(bem$x("title"))
    }, props.title), renderCloseIcon());
    const renderOption = (option, selected, tabIndex) => {
      const color = option.color || (selected ? props.activeColor : void 0);
      const Text2 = props.optionRender ? props.optionRender({ option, selected }) : /* @__PURE__ */ React__default["default"].createElement("span", null, option[textKey]);
      return /* @__PURE__ */ React__default["default"].createElement("li", {
        key: option[valueKey],
        className: clsx(bem$x("option", {
          selected,
          disabled: option.disabled
        }), option.className),
        style: { color },
        onClick: () => onSelect(option, tabIndex)
      }, Text2, selected ? /* @__PURE__ */ React__default["default"].createElement(SvgSuccess, {
        className: clsx(bem$x("selected-icon"))
      }) : null);
    };
    const renderOptions = (options, selectedOption, tabIndex) => /* @__PURE__ */ React__default["default"].createElement("ul", {
      key: tabIndex,
      className: clsx(bem$x("options"))
    }, options.map((option) => renderOption(option, option[valueKey] === (selectedOption == null ? void 0 : selectedOption[valueKey]), tabIndex)));
    const renderTab = (options, tabIndex) => {
      const selectedOption = items[tabIndex];
      const title = selectedOption ? selectedOption[textKey] : props.placeholder || locale.vanPicker.select;
      return /* @__PURE__ */ React__default["default"].createElement(Tabs.TabPane, {
        key: tabIndex,
        title,
        titleClass: clsx(bem$x("tab", {
          unselected: !selectedOption
        }))
      }, renderOptions(options, selectedOption, tabIndex));
    };
    const renderTabs = () => /* @__PURE__ */ React__default["default"].createElement(Tabs, {
      animated: true,
      active: activeTab,
      className: clsx(bem$x("tabs")),
      color: props.activeColor,
      swipeThreshold: 0,
      swipeable: props.swipeable,
      duration: 300,
      onClickTab
    }, tabs.map(renderTab));
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$x())
    }, renderHeader(), tabs.length ? renderTabs() : null);
  };
  const CascaderPopup = React__default["default"].forwardRef((props, ref) => {
    var _b;
    const _a = props, { visible: outerVisible, popup } = _a, cascaderProps = __objRest(_a, ["visible", "popup"]);
    const [visible, setVisible] = usePropsValue({
      value: outerVisible,
      defaultValue: false
    });
    const [value, setValue2] = React.useState(() => props.value === void 0 ? props.defaultValue : props.value);
    const [innerValue, setInnerValue] = React.useState(value);
    const {
      text: textKey,
      value: valueKey,
      children: childrenKey
    } = extend({
      text: "text",
      value: "value",
      children: "children"
    }, props.fieldNames);
    const { items } = useCascaderExtend(props.options, { textKey, valueKey, childrenKey }, value || []);
    useUpdateEffect(() => {
      if (props.value === void 0)
        return;
      if (JSON.stringify(value) !== JSON.stringify(props.value)) {
        setValue2(props.value);
      }
    }, [props.value]);
    React.useEffect(() => {
      if (!popup && JSON.stringify(innerValue) !== JSON.stringify(value)) {
        setInnerValue(value);
      }
    }, [value]);
    React.useEffect(() => {
      if (popup && JSON.stringify(innerValue) !== JSON.stringify(value)) {
        setInnerValue(value);
      }
    }, [visible]);
    const actions = {
      toggle: () => {
        if (popup)
          setVisible((v2) => !v2);
      },
      open: () => {
        if (popup) {
          setVisible(true);
        }
      },
      close: () => {
        if (popup) {
          setVisible(false);
        }
      }
    };
    const onClose = () => {
      var _a2;
      (_a2 = props.onClose) == null ? void 0 : _a2.call(props);
      actions.close();
    };
    const onFinish = useMemoizedFn((val, selectedRows) => {
      var _a2;
      setValue2(val);
      (_a2 = props.onFinish) == null ? void 0 : _a2.call(props, val, selectedRows);
      actions.close();
    });
    const onChange = useMemoizedFn((val, selectedRows) => {
      var _a2, _b2;
      setInnerValue(val);
      if (popup) {
        if (visible)
          (_a2 = props.onChange) == null ? void 0 : _a2.call(props, val, selectedRows);
      } else {
        (_b2 = props.onChange) == null ? void 0 : _b2.call(props, val, selectedRows);
      }
    });
    React.useImperativeHandle(ref, () => actions);
    const content = /* @__PURE__ */ React__default["default"].createElement(Cascader, __spreadProps(__spreadValues({
      value: innerValue
    }, cascaderProps), {
      onChange,
      onFinish,
      onClose
    }));
    if (!popup)
      return content;
    const popupProps2 = isObject$1(popup) ? __spreadValues({ closeOnClickOverlay: true }, popup) : { closeOnClickOverlay: true };
    return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, /* @__PURE__ */ React__default["default"].createElement(Popup, __spreadValues({
      position: "bottom",
      visible,
      closeOnClickOverlay: true,
      onClickOverlay: () => {
        if (!(popupProps2 == null ? void 0 : popupProps2.closeOnClickOverlay))
          return;
        setVisible(false);
      }
    }, popupProps2), content), (_b = props.children) == null ? void 0 : _b.call(props, value, items, actions));
  });
  CascaderPopup.defaultProps = {
    closeable: true,
    swipeable: false,
    defaultValue: [],
    options: []
  };
  var index$k = "";
  const CheckboxContext = React.createContext({});
  const [bem$w] = createNamespace("checkbox-group");
  const CheckBoxGroup = React.forwardRef((props, ref) => {
    const [childrenRefs, setChildrenRefs] = useRefs();
    const [checked, setChecked] = useMergedState({
      value: props.value,
      defaultValue: props.defaultValue
    });
    const toggleAll = (options = {}) => {
      if (typeof options === "boolean") {
        options = { checked: options };
      }
      const { checked: isChecked, skipDisabled } = options;
      const checkedChildren = childrenRefs.filter((item) => {
        if (!item.props.bindGroup) {
          return false;
        }
        if (item.props.disabled && skipDisabled) {
          return item.checked;
        }
        return isChecked != null ? isChecked : !item.checked;
      });
      const names = checkedChildren.map((item) => item.props.name);
      setChecked(names);
      props.onChange(names);
    };
    const toggle = (name) => {
      var _a;
      setChecked(name);
      (_a = props.onChange) == null ? void 0 : _a.call(props, name);
    };
    React.useImperativeHandle(ref, () => ({
      toggleAll
    }));
    return /* @__PURE__ */ React__default["default"].createElement(CheckboxContext.Provider, {
      value: { parent: { props }, toggle, checked: checked || [] }
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, bem$w([props.direction]))
    }, React__default["default"].Children.toArray(props.children).filter(Boolean).map((child, index2) => {
      var _a;
      if (((_a = child.type) == null ? void 0 : _a.displayName) !== "Checkbox")
        return child;
      return React__default["default"].cloneElement(child, { ref: setChildrenRefs(index2) });
    })));
  });
  const [bem$v] = createNamespace("checkbox");
  const CheckBox = React.forwardRef((props, ref) => {
    const _a = React.useContext(CheckboxContext), { parent } = _a, context = __objRest(_a, ["parent"]);
    const [checked, setChecked] = useMergedState({
      value: props.checked,
      defaultValue: props.defaultChecked
    });
    const setParentValue = (isChecked2) => {
      const { name } = props;
      const { max } = parent.props;
      const value = context.checked.slice();
      if (isChecked2) {
        const overlimit = max && value.length >= max;
        if (!overlimit && value.indexOf(name) === -1) {
          value.push(name);
          if (props.bindGroup) {
            context.toggle(value);
          }
        }
      } else {
        const index2 = value.indexOf(name);
        if (index2 !== -1) {
          value.splice(index2, 1);
          if (props.bindGroup) {
            context.toggle(value);
          }
        }
      }
    };
    const isChecked = React.useMemo(() => {
      if (parent && props.bindGroup) {
        return context.checked.indexOf(props.name) !== -1;
      }
      return checked;
    }, [context.checked, checked]);
    const toggle = (newValue = !isChecked) => {
      var _a2;
      if (parent && props.bindGroup) {
        setParentValue(newValue);
      } else {
        setChecked(newValue);
        (_a2 = props.onChange) == null ? void 0 : _a2.call(props, newValue);
      }
    };
    React.useImperativeHandle(ref, () => ({
      toggle,
      checked: isChecked,
      props
    }));
    return /* @__PURE__ */ React__default["default"].createElement(Checker, __spreadProps(__spreadValues({}, props), {
      bem: bem$v,
      role: "checkbox",
      parent,
      checked: isChecked,
      className: props.className,
      bindGroup: props.bindGroup,
      onToggle: toggle
    }));
  });
  CheckBox.displayName = "Checkbox";
  CheckBox.defaultProps = {
    bindGroup: true
  };
  const Checkbox = Object.assign(CheckBox, { Group: CheckBoxGroup });
  var index$j = "";
  const DEFAULT_DURATION = 200;
  const MOMENTUM_LIMIT_TIME = 300;
  const MOMENTUM_LIMIT_DISTANCE = 15;
  function getElementTranslateY(element) {
    const style = window.getComputedStyle(element);
    const transform = style.transform || style.webkitTransform;
    const translateY = transform.slice(7, transform.length - 1).split(", ")[5];
    return Number(translateY);
  }
  const [bem$u] = createNamespace("picker-column");
  const PickerColumn = React.memo(React.forwardRef((props, ref) => {
    const { locale } = React.useContext(ConfigProvider$1);
    const {
      valueKey,
      textKey,
      itemHeight,
      visibleItemCount,
      placeholder,
      value
    } = props;
    const options = React.useMemo(() => {
      if (Array.isArray(props.options) && !props.options.length)
        return [];
      if (placeholder) {
        const DEFAULT_OPTION = {
          [valueKey]: void 0,
          [textKey]: placeholder === true ? locale.vanPicker.select : placeholder
        };
        return [DEFAULT_OPTION, ...props.options];
      }
      return props.options;
    }, [props.options]);
    const wrapper = React.useRef(null);
    const moving = React.useRef(false);
    const startOffset = React.useRef(0);
    const transitionEndTrigger = React.useRef(null);
    const touchStartTime = React.useRef(0);
    const momentumOffset = React.useRef(0);
    const [state, updateState, stateRef] = useSetState({
      offset: 0,
      duration: 0
    });
    const touch = useTouch();
    const baseOffset = React.useMemo(() => {
      return itemHeight * (+visibleItemCount - 1) / 2;
    }, [itemHeight, visibleItemCount]);
    const adjustIndex = (index2) => {
      var _a, _b;
      index2 = range$1(index2, 0, options.length);
      for (let i = index2; i < options.length; i += 1) {
        if (!((_a = options[i]) == null ? void 0 : _a.disabled))
          return i;
      }
      for (let i = index2 - 1; i >= 0; i -= 1) {
        if (!((_b = options[i]) == null ? void 0 : _b.disabled))
          return i;
      }
      return null;
    };
    const onSelect = (val) => {
      props.onSelect(val, props.index);
    };
    const setIndex = (index2) => {
      index2 = adjustIndex(index2) || 0;
      const offset2 = -index2 * props.itemHeight;
      const trigger = () => {
        if (options[index2][valueKey] !== value) {
          onSelect(options[index2]);
        }
      };
      if (moving.current && offset2 !== stateRef.current.offset) {
        transitionEndTrigger.current = trigger;
      } else {
        trigger();
      }
      updateState({ offset: offset2 });
    };
    const animate = (index2) => {
      index2 = adjustIndex(index2) || 0;
      const offset2 = -index2 * props.itemHeight;
      updateState({ offset: offset2 });
    };
    useIsomorphicLayoutEffect(() => {
      if (options.length === 0) {
        if (value !== void 0) {
          onSelect(void 0);
        }
      } else {
        let targetIndex = options.findIndex((item) => item[valueKey] === value);
        if (targetIndex < 0) {
          targetIndex = 0;
          onSelect(options[0]);
        }
        animate(targetIndex);
      }
    }, [value, JSON.stringify(options)]);
    const onClickItem = (index2) => {
      if (moving.current || props.readOnly) {
        return;
      }
      transitionEndTrigger.current = null;
      updateState({ duration: DEFAULT_DURATION });
      setIndex(index2);
    };
    const getIndexByOffset = (offset2) => range$1(Math.round(-offset2 / props.itemHeight), 0, options.length - 1);
    const momentum = (distance, _duration) => {
      const speed = Math.abs(distance / _duration);
      distance = stateRef.current.offset + speed / 3e-3 * (distance < 0 ? -1 : 1);
      const index2 = getIndexByOffset(distance);
      updateState({ duration: +props.swipeDuration });
      setIndex(index2);
    };
    const stopMomentum = () => {
      moving.current = false;
      updateState({ duration: 0 });
      if (transitionEndTrigger.current) {
        transitionEndTrigger.current();
        transitionEndTrigger.current = null;
      }
    };
    const onTouchStart = (event) => {
      if (props.readOnly) {
        return;
      }
      touch.start(event);
      let { offset: offset2 } = state;
      if (moving.current) {
        const translateY = getElementTranslateY(wrapper.current);
        offset2 = Math.min(0, translateY - baseOffset);
        startOffset.current = offset2;
      } else {
        startOffset.current = offset2;
      }
      updateState({ duration: 0, offset: offset2 });
      touchStartTime.current = Date.now();
      momentumOffset.current = startOffset.current;
      transitionEndTrigger.current = null;
    };
    const onTouchMove = (event) => {
      if (props.readOnly) {
        return;
      }
      touch.move(event);
      if (touch.isVertical()) {
        moving.current = true;
      }
      const offset2 = range$1(startOffset.current + touch.deltaY.current, -(options.length * props.itemHeight), props.itemHeight);
      updateState({
        offset: offset2
      });
      const now = Date.now();
      if (now - touchStartTime.current > MOMENTUM_LIMIT_TIME) {
        touchStartTime.current = now;
        momentumOffset.current = offset2;
      }
    };
    const onTouchEnd = () => {
      if (props.readOnly || !moving.current) {
        return;
      }
      const distance = stateRef.current.offset - momentumOffset.current;
      const duration = Date.now() - touchStartTime.current;
      const allowMomentum = duration < MOMENTUM_LIMIT_TIME && Math.abs(distance) > MOMENTUM_LIMIT_DISTANCE;
      if (allowMomentum) {
        momentum(distance, duration);
        return;
      }
      const index2 = getIndexByOffset(stateRef.current.offset);
      updateState({ duration: DEFAULT_DURATION });
      setIndex(index2);
      setTimeout(() => {
        moving.current = false;
      }, 0);
    };
    const renderOptions = () => {
      const optionStyle = {
        height: `${props.itemHeight}px`
      };
      return options.map((option, index2) => {
        const { disabled } = option;
        const data = {
          role: "button",
          style: optionStyle,
          tabIndex: disabled ? -1 : 0,
          className: clsx(bem$u("item", {
            disabled,
            selected: option[valueKey] === value
          })),
          onClick: () => {
            onClickItem(index2);
          }
        };
        const childData = {
          className: "rv-ellipsis",
          children: option[textKey]
        };
        return /* @__PURE__ */ React__default["default"].createElement("li", __spreadProps(__spreadValues({}, data), {
          key: index2
        }), props.optionRender ? props.optionRender(option) : /* @__PURE__ */ React__default["default"].createElement("div", __spreadValues({}, childData)));
      });
    };
    React.useImperativeHandle(ref, () => ({
      stopMomentum
    }));
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$u(), props.className),
      onTouchStart,
      onTouchMove,
      onTouchEnd,
      onTouchCancel: onTouchEnd
    }, /* @__PURE__ */ React__default["default"].createElement("ul", {
      ref: wrapper,
      style: {
        transform: `translate3d(0, ${state.offset + baseOffset}px, 0)`,
        transitionDuration: `${state.duration}ms`,
        transitionProperty: state.duration ? "all" : "none"
      },
      className: clsx(bem$u("wrapper")),
      onTransitionEnd: stopMomentum
    }, renderOptions()));
  }), (prev2, next) => {
    if (prev2.index !== next.index)
      return false;
    if (prev2.value !== next.value) {
      return false;
    }
    if (prev2.onSelect !== next.onSelect)
      return false;
    if (JSON.stringify(prev2.options) !== JSON.stringify(next.options)) {
      return false;
    }
    return true;
  });
  function useColumnsFn(options, keys) {
    const { textKey, valueKey, childrenKey } = keys;
    const dataType = React.useMemo(() => {
      const firstColumn = options[0] || {};
      if (typeof firstColumn === "object") {
        if (childrenKey in firstColumn) {
          return "cascade";
        }
        return "object";
      }
      return "plain";
    }, [options, childrenKey]);
    const depth = React.useMemo(() => {
      let depth2 = 0;
      function traverse(options2, currentDepth) {
        if (currentDepth > depth2)
          depth2 = currentDepth;
        const nextDepth = currentDepth + 1;
        options2.forEach((option) => {
          if (option[childrenKey]) {
            traverse(option[childrenKey], nextDepth);
          }
        });
      }
      traverse(options, 1);
      return depth2;
    }, [options, childrenKey]);
    if (dataType !== "cascade")
      return options;
    return (selected) => {
      const columns = [];
      let currentOptions2 = options;
      let i = 0;
      while (true) {
        columns.push(currentOptions2.map((option) => {
          var _a;
          return {
            [textKey]: option[textKey],
            [valueKey]: (_a = option[valueKey]) != null ? _a : option[textKey]
          };
        }));
        const x2 = selected[i];
        const targetOptions = currentOptions2.find((option) => {
          var _a;
          return ((_a = option[valueKey]) != null ? _a : option[textKey]) === x2;
        });
        if (!targetOptions || !targetOptions[childrenKey])
          break;
        currentOptions2 = targetOptions[childrenKey];
        i++;
      }
      while (i < depth - 1) {
        columns.push([]);
        i++;
      }
      return columns;
    };
  }
  function withCache(generate) {
    let cache = null;
    return () => {
      if (cache === null) {
        cache = generate();
      }
      return cache;
    };
  }
  function generateColumnsExtend(rawColumns, keys, val) {
    const { textKey, valueKey } = keys;
    const columns = withCache(() => {
      let cls = typeof rawColumns === "function" ? rawColumns(val) : rawColumns;
      if (!Array.isArray(cls[0]))
        cls = [cls];
      return cls.map((column) => column.map((item) => {
        if (typeof item === "string")
          return { [textKey]: item, [valueKey]: item };
        if (!(valueKey in item))
          item[valueKey] = item[textKey];
        return item;
      }));
    });
    const items = withCache(() => {
      return val.map((v2, index2) => {
        var _a;
        const column = columns()[index2];
        if (!column)
          return null;
        return (_a = column.find((item) => item[valueKey] === v2)) != null ? _a : void 0;
      });
    });
    const indexes = withCache(() => {
      return val.map((v2, index2) => {
        var _a;
        const column = columns()[index2];
        if (!column)
          return null;
        return (_a = column.findIndex((item) => item[valueKey] === v2)) != null ? _a : null;
      });
    });
    const result = {
      get columns() {
        return columns();
      },
      get items() {
        return items();
      },
      get indexes() {
        return indexes();
      }
    };
    return result;
  }
  function useColumnsExtend(columns, keys, value) {
    const formatColumns = useColumnsFn(columns, keys);
    return React.useMemo(() => generateColumnsExtend(formatColumns, keys, value), [columns, keys, value]);
  }
  const [bem$t] = createNamespace("picker");
  function PickerInner(props) {
    const { locale } = React.useContext(ConfigProvider$1);
    const wrapper = React.useRef(null);
    const [refs, setRefs] = useRefs();
    const {
      text: textKey,
      value: valueKey,
      children: childrenKey
    } = extend({
      text: "text",
      value: "value",
      children: "children"
    }, props.columnsFieldNames);
    const [innerValue, setInnerValue] = React.useState(props.value);
    React.useEffect(() => {
      if (props.value === void 0)
        return;
      if (JSON.stringify(innerValue) === JSON.stringify(props.value))
        return;
      setInnerValue(props.value);
    }, [props.value]);
    const formatColumns = useColumnsExtend(props.columns, { textKey, valueKey, childrenKey }, innerValue);
    const { columns, items, indexes } = formatColumns;
    useDebounceEffect(() => {
      var _a;
      if (JSON.stringify(props.value) === JSON.stringify(innerValue))
        return;
      (_a = props.onChange) == null ? void 0 : _a.call(props, innerValue, items, indexes);
    }, [innerValue], {
      wait: 0,
      leading: false,
      trailing: true
    });
    const itemHeight = React.useMemo(() => unitToPx(props.itemHeight), [props.itemHeight]);
    const handleSelect = (val, index2) => {
      setInnerValue((prev2) => {
        const next = [...prev2];
        next[index2] = val == null ? void 0 : val[valueKey];
        return next;
      });
    };
    const confirm = () => {
      var _a;
      refs.forEach((_ref) => _ref.stopMomentum());
      (_a = props.onConfirm) == null ? void 0 : _a.call(props, innerValue, items, indexes);
    };
    const cancel = () => {
      var _a;
      (_a = props.onCancel) == null ? void 0 : _a.call(props);
    };
    const renderTitle = () => {
      if (props.title) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$t("title"), "rv-ellipsis")
        }, props.title);
      }
      return null;
    };
    const renderCancel = () => {
      const text = props.cancelButtonText || locale.cancel;
      return /* @__PURE__ */ React__default["default"].createElement("button", {
        type: "button",
        className: clsx(bem$t("cancel")),
        onClick: cancel
      }, text);
    };
    const renderConfirm = () => {
      const text = props.confirmButtonText || locale.confirm;
      return /* @__PURE__ */ React__default["default"].createElement("button", {
        type: "button",
        className: clsx(bem$t("confirm")),
        onClick: confirm
      }, text);
    };
    const renderToolbar = () => {
      if (props.showToolbar) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$t("toolbar"))
        }, props.toolbar || /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, renderCancel(), renderTitle(), renderConfirm()));
      }
      return null;
    };
    const renderColumnItems = () => {
      return columns.map((item, columnIndex) => {
        const placeholder = Array.isArray(props.placeholder) ? props.placeholder[columnIndex] : props.placeholder;
        return /* @__PURE__ */ React__default["default"].createElement(PickerColumn, {
          textKey,
          valueKey,
          key: columnIndex,
          ref: setRefs(columnIndex),
          placeholder,
          optionRender: props.optionRender,
          readOnly: props.readOnly,
          value: innerValue[columnIndex],
          itemHeight,
          index: columnIndex,
          swipeDuration: props.swipeDuration,
          visibleItemCount: props.visibleItemCount,
          options: item,
          onSelect: handleSelect
        });
      });
    };
    const renderColumns = () => {
      const wrapHeight = itemHeight * props.visibleItemCount;
      const frameStyle = { height: `${itemHeight}px` };
      const columnsStyle = { height: `${wrapHeight}px` };
      const maskStyle = {
        backgroundSize: `100% ${(wrapHeight - itemHeight) / 2}px`
      };
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        ref: wrapper,
        className: clsx(bem$t("columns")),
        style: columnsStyle
      }, renderColumnItems(), /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$t("mask")),
        style: maskStyle
      }), /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(BORDER_UNSET_TOP_BOTTOM, bem$t("frame")),
        style: frameStyle
      }));
    };
    useEventListener("touchmove", preventDefault, {
      target: wrapper.current
    });
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$t(), props.className)
    }, props.toolbarPosition === "top" ? renderToolbar() : null, props.loading ? /* @__PURE__ */ React__default["default"].createElement(Loading, {
      className: clsx(bem$t("loading"))
    }) : null, props.columnsTop, renderColumns(), props.columnsBottom, props.toolbarPosition === "bottom" ? renderToolbar() : null);
  }
  function PopupPicker(props, ref) {
    const _a = props, {
      visible: outerVisible,
      popup,
      children,
      defaultValue = []
    } = _a, pickerProps = __objRest(_a, [
      "visible",
      "popup",
      "children",
      "defaultValue"
    ]);
    const [visible, setVisible] = usePropsValue({
      value: outerVisible,
      defaultValue: false,
      onChange: (v2) => {
        var _a2;
        if (v2 === false) {
          (_a2 = props.onClose) == null ? void 0 : _a2.call(props);
        }
      }
    });
    const actions = {
      toggle: () => {
        if (popup)
          setVisible((v2) => !v2);
      },
      open: () => {
        if (popup) {
          setVisible(true);
        }
      },
      close: () => {
        if (popup) {
          setVisible(false);
        }
      }
    };
    React.useImperativeHandle(ref, () => actions);
    const formatValue2 = Array.isArray(props.value) ? props.value : props.value !== void 0 ? [props.value] : void 0;
    const formatDefaultValue = Array.isArray(defaultValue) ? defaultValue : defaultValue !== void 0 ? [defaultValue] : [];
    const {
      text: textKey,
      value: valueKey,
      children: childrenKey
    } = extend({
      text: "text",
      value: "value",
      children: "children"
    }, props.columnsFieldNames);
    const isPlainType = React.useMemo(() => {
      const firstColumn = props.columns[0] || {};
      if (Array.isArray(firstColumn))
        return false;
      if (typeof firstColumn === "object") {
        if (childrenKey in firstColumn) {
          return false;
        }
      }
      return true;
    }, [props.columns, childrenKey]);
    const parseValue = (target) => isPlainType ? target == null ? void 0 : target[0] : target;
    const [value, setValue2] = usePropsValue({
      value: formatValue2,
      defaultValue: formatDefaultValue
    });
    const formatColumns = useColumnsExtend(props.columns, { textKey, valueKey, childrenKey }, value);
    const [innerValue, setInnerValue] = React.useState(value);
    React.useEffect(() => {
      if (popup && JSON.stringify(innerValue) !== JSON.stringify(value)) {
        setInnerValue(value);
      }
    }, [visible]);
    React.useEffect(() => {
      if (!popup && JSON.stringify(innerValue) !== JSON.stringify(value)) {
        setInnerValue(value);
      }
    }, [value]);
    const onConfirm = (val, items, indexes) => {
      var _a2;
      setValue2(innerValue, true);
      (_a2 = props.onConfirm) == null ? void 0 : _a2.call(props, parseValue(val), parseValue(items), parseValue(indexes));
      if (popup)
        actions.close();
    };
    const onCancel = () => {
      var _a2;
      (_a2 = props.onCancel) == null ? void 0 : _a2.call(props);
      if (popup)
        actions.close();
    };
    const onChange = useMemoizedFn((val, ext, indexes) => {
      var _a2, _b;
      setInnerValue(val);
      if (popup) {
        if (visible)
          (_a2 = props.onChange) == null ? void 0 : _a2.call(props, parseValue(val), parseValue(ext), parseValue(indexes));
      } else {
        (_b = props.onChange) == null ? void 0 : _b.call(props, parseValue(val), parseValue(ext), parseValue(indexes));
      }
    });
    const popupProps2 = isObject$1(popup) ? __spreadValues({ closeOnClickOverlay: true }, popup) : { closeOnClickOverlay: true };
    const content = /* @__PURE__ */ React__default["default"].createElement(PickerInner, __spreadProps(__spreadValues({}, pickerProps), {
      value: innerValue,
      onCancel,
      onConfirm,
      onChange
    }));
    if (!popup)
      return content;
    return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, /* @__PURE__ */ React__default["default"].createElement(Popup, __spreadValues({
      round: true,
      position: "bottom",
      visible,
      closeOnClickOverlay: true,
      onClickOverlay: () => {
        if (!(popupProps2 == null ? void 0 : popupProps2.closeOnClickOverlay))
          return;
        setVisible(false);
      }
    }, popupProps2), content), children == null ? void 0 : children(parseValue(value), parseValue(formatColumns.items), actions));
  }
  const Picker = React.forwardRef(PopupPicker);
  Picker.defaultProps = {
    columns: [],
    itemHeight: 44,
    visibleItemCount: 5,
    swipeDuration: 300,
    showToolbar: true,
    placeholder: true,
    toolbarPosition: "top"
  };
  function isDate(val) {
    return Object.prototype.toString.call(val) === "[object Date]" && !isNaN$1(val.getTime());
  }
  const DatePicker = React.forwardRef((props, ref) => {
    const _a = props, {
      value,
      defaultValue,
      formatter,
      columnsOrder,
      type: datePickerType,
      filter,
      minDate,
      maxDate
    } = _a, pickerProps = __objRest(_a, [
      "value",
      "defaultValue",
      "formatter",
      "columnsOrder",
      "type",
      "filter",
      "minDate",
      "maxDate"
    ]);
    const formatValue2 = (date2) => {
      if (!isDate(date2)) {
        date2 = minDate;
      }
      date2 = Math.max(date2, minDate.getTime());
      date2 = Math.min(date2, maxDate.getTime());
      return new Date(date2);
    };
    const [currentDate, setCurrentDate, currentDateRef] = useRefState(() => formatValue2(value || defaultValue));
    const getBoundary = (type2, value2) => {
      const boundary = props[`${type2}Date`];
      const year = boundary.getFullYear();
      let month = 1;
      let date2 = 1;
      let hour = 0;
      let minute = 0;
      if (type2 === "max") {
        month = 12;
        date2 = getMonthEndDay(value2.getFullYear(), value2.getMonth() + 1);
        hour = 23;
        minute = 59;
      }
      if (value2.getFullYear() === year) {
        month = boundary.getMonth() + 1;
        if (value2.getMonth() + 1 === month) {
          date2 = boundary.getDate();
          if (value2.getDate() === date2) {
            hour = boundary.getHours();
            if (value2.getHours() === hour) {
              minute = boundary.getMinutes();
            }
          }
        }
      }
      return {
        [`${type2}Year`]: year,
        [`${type2}Month`]: month,
        [`${type2}Date`]: date2,
        [`${type2}Hour`]: hour,
        [`${type2}Minute`]: minute
      };
    };
    const originColumns = React.useMemo(() => {
      const { maxYear, maxDate: maxDate2, maxMonth, maxHour, maxMinute } = getBoundary("max", currentDateRef.current);
      const { minYear, minDate: minDate2, minMonth, minHour, minMinute } = getBoundary("min", currentDateRef.current);
      let result = [
        {
          type: "year",
          range: [minYear, maxYear]
        },
        {
          type: "month",
          range: [minMonth, maxMonth]
        },
        {
          type: "day",
          range: [minDate2, maxDate2]
        },
        {
          type: "hour",
          range: [minHour, maxHour]
        },
        {
          type: "minute",
          range: [minMinute, maxMinute]
        }
      ];
      switch (datePickerType) {
        case "date":
          result = result.slice(0, 3);
          break;
        case "year-month":
          result = result.slice(0, 2);
          break;
        case "month-day":
          result = result.slice(1, 3);
          break;
        case "datehour":
          result = result.slice(0, 4);
          break;
      }
      if (columnsOrder) {
        const columnsOrderArr = columnsOrder.concat(result.map((column) => column.type));
        result.sort((a, b2) => columnsOrderArr.indexOf(a.type) - columnsOrderArr.indexOf(b2.type));
      }
      return result.map(({ type: type2, range: rangeArr }) => {
        let values = times(rangeArr[1] - rangeArr[0] + 1, (index2) => {
          return padZero(rangeArr[0] + index2);
        });
        if (filter) {
          values = filter(type2, values);
        }
        return {
          type: type2,
          values
        };
      });
    }, [columnsOrder, currentDateRef.current, minDate, maxDate]);
    const columns = React.useMemo(() => originColumns.map((column) => column.values.map((value2) => formatter(column.type, value2))), [originColumns, formatter]);
    const pickerValue = React.useMemo(() => {
      const value2 = props.popup ? formatValue2(props.value) : currentDateRef.current;
      const values = originColumns.map((column) => {
        switch (column.type) {
          case "year":
            return formatter("year", `${value2.getFullYear()}`);
          case "month":
            return formatter("month", padZero(value2.getMonth() + 1));
          case "day":
            return formatter("day", padZero(value2.getDate()));
          case "hour":
            return formatter("hour", padZero(value2.getHours()));
          case "minute":
            return formatter("minute", padZero(value2.getMinutes()));
          default:
            return "";
        }
      });
      return values;
    }, [props.value, currentDateRef.current, formatValue2]);
    const updateInnerValue = (indexes) => {
      const { type: type2 } = props;
      const getValue2 = (datetimePickerColumnType) => {
        let index2 = 0;
        originColumns.forEach((column, columnIndex) => {
          if (datetimePickerColumnType === column.type) {
            index2 = columnIndex;
          }
        });
        const { values } = originColumns[index2];
        return getTrueValue(values[indexes[index2]]);
      };
      let year = null;
      let month = null;
      let day = null;
      if (type2 === "month-day") {
        year = (currentDate || minDate).getFullYear();
        month = getValue2("month");
        day = getValue2("day");
      } else {
        year = getValue2("year");
        month = getValue2("month");
        day = type2 === "year-month" ? 1 : getValue2("day");
      }
      const maxDay = getMonthEndDay(year, month);
      day = day > maxDay ? maxDay : day;
      let hour = 0;
      let minute = 0;
      if (type2 === "datehour") {
        hour = +getValue2("hour");
      }
      if (type2 === "datetime") {
        hour = +getValue2("hour");
        minute = +getValue2("minute");
      }
      return formatValue2(new Date(year, month - 1, day, hour, minute));
    };
    const onChange = (val, values, indexes) => {
      var _a2;
      const nextValue = updateInnerValue(indexes);
      setCurrentDate(nextValue);
      (_a2 = props.onChange) == null ? void 0 : _a2.call(props, nextValue);
    };
    const onConfirm = () => {
      var _a2;
      (_a2 = props.onConfirm) == null ? void 0 : _a2.call(props, currentDate);
    };
    useUpdateEffect(() => {
      const nextValue = formatValue2(value);
      if (nextValue && nextValue.valueOf() !== (currentDate == null ? void 0 : currentDate.valueOf())) {
        setCurrentDate(nextValue);
      }
    }, [value, filter, minDate, maxDate]);
    return /* @__PURE__ */ React__default["default"].createElement(Picker, __spreadProps(__spreadValues({}, pickerProps), {
      value: pickerValue,
      ref,
      columns,
      onChange,
      onConfirm,
      onCancel: props.onCancel
    }), (_, selectRows, actions) => {
      var _a2;
      return (_a2 = props.children) == null ? void 0 : _a2.call(props, value, selectRows, actions);
    });
  });
  const currentYear = new Date().getFullYear();
  DatePicker.defaultProps = {
    type: "datetime",
    placeholder: false,
    minDate: new Date(currentYear - 10, 0, 1),
    maxDate: new Date(currentYear + 10, 11, 31),
    formatter: (type2, value) => value
  };
  const TimePicker = React.forwardRef((props, ref) => {
    const _a = props, {
      value,
      defaultValue,
      formatter,
      filter,
      minHour,
      maxHour,
      minMinute,
      maxMinute
    } = _a, pickerProps = __objRest(_a, [
      "value",
      "defaultValue",
      "formatter",
      "filter",
      "minHour",
      "maxHour",
      "minMinute",
      "maxMinute"
    ]);
    const formatValue2 = (str) => {
      if (!str) {
        str = `${padZero(minHour)}:${padZero(minMinute)}`;
      }
      let [hour, minute] = str.split(":");
      hour = padZero(range$1(hour, +minHour, +maxHour));
      minute = padZero(range$1(minute, +minMinute, +maxMinute));
      return `${hour}:${minute}`;
    };
    const [currentDate, setCurrentDate] = React.useState(() => formatValue2(value === void 0 ? defaultValue : value));
    const ranges = React.useMemo(() => [
      {
        type: "hour",
        range: [+minHour, +maxHour]
      },
      {
        type: "minute",
        range: [+minMinute, +maxMinute]
      }
    ], [minHour, maxHour, minMinute, maxMinute]);
    const originColumns = React.useMemo(() => ranges.map(({ type: type2, range: rangeArr }) => {
      let values = times(rangeArr[1] - rangeArr[0] + 1, (index2) => padZero(rangeArr[0] + index2));
      if (filter) {
        values = filter(type2, values);
      }
      return {
        type: type2,
        values
      };
    }), [ranges]);
    const columns = React.useMemo(() => originColumns.map((column) => column.values.map((value2) => formatter(column.type, value2))), [originColumns]);
    const pickerValue = React.useMemo(() => {
      const pair = (props.popup ? formatValue2(props.value) : currentDate).split(":");
      return [formatter("hour", pair[0]), formatter("minute", pair[1])];
    }, [props.value, currentDate, formatValue2]);
    const onConfirm = () => {
      var _a2;
      (_a2 = props.onConfirm) == null ? void 0 : _a2.call(props, currentDate);
    };
    const onCancel = () => {
      var _a2;
      (_a2 = props.onCancel) == null ? void 0 : _a2.call(props);
    };
    const onChange = (val) => {
      var _a2;
      const nextValue = formatValue2(val.join(":"));
      setCurrentDate(nextValue);
      (_a2 = props.onChange) == null ? void 0 : _a2.call(props, nextValue);
    };
    useUpdateEffect(() => {
      const nextValue = formatValue2(currentDate);
      setCurrentDate(nextValue);
    }, [filter, minHour, maxHour, minMinute, maxMinute]);
    useUpdateEffect(() => {
      const nextValue = formatValue2(value);
      if (nextValue !== currentDate) {
        setCurrentDate(nextValue);
      }
    }, [value]);
    return /* @__PURE__ */ React__default["default"].createElement(Picker, __spreadProps(__spreadValues({}, pickerProps), {
      ref,
      columns,
      value: pickerValue,
      onChange,
      onConfirm,
      onCancel
    }), (_, selectRows, actions) => {
      var _a2;
      return (_a2 = props.children) == null ? void 0 : _a2.call(props, value, selectRows, actions);
    });
  });
  TimePicker.defaultProps = {
    minHour: 0,
    maxHour: 23,
    minMinute: 0,
    maxMinute: 59,
    placeholder: false,
    defaultValue: "",
    formatter: (type2, value) => value
  };
  const [bem$s] = createNamespace("datetime-picker");
  const DateTimePicker = React.forwardRef((props, ref) => {
    const isTimePicker = props.type === "time";
    if (isTimePicker)
      return /* @__PURE__ */ React__default["default"].createElement(TimePicker, __spreadValues({
        ref,
        className: clsx(bem$s())
      }, props));
    return /* @__PURE__ */ React__default["default"].createElement(DatePicker, __spreadValues({
      ref,
      className: clsx(bem$s())
    }, props));
  });
  var index$i = "";
  const [bem$r] = createNamespace("password-input");
  const PasswordInput = React.forwardRef((props, ref) => {
    const innerEffect = React.useRef(false);
    const inputRef = React.useRef(null);
    const [state, updateState] = useSetState({
      code: props.value || "",
      focused: props.autoFocus,
      inputType: props.type,
      inputMode: "text"
    });
    const codeArr = React.useMemo(() => {
      var _a;
      return (_a = state.code) == null ? void 0 : _a.toString().split("");
    }, [state.code]);
    const cursorIndex = React.useMemo(() => codeArr.length, [codeArr.length]);
    const { length, onSubmit } = props;
    const focus = () => {
      var _a;
      (_a = inputRef.current) == null ? void 0 : _a.focus();
      updateState({ focused: true });
    };
    const blur = () => {
      var _a;
      (_a = inputRef.current) == null ? void 0 : _a.blur();
      updateState({ focused: false });
    };
    const clear2 = () => {
      updateState({ code: "" });
    };
    const formatValue2 = (val, callback) => {
      if (isDef(length) && (val == null ? void 0 : val.length) > +length) {
        val = val.slice(0, length);
      }
      if (props.type === "number") {
        val = formatNumber(val, false, false);
      }
      if (isFunction(props.validator)) {
        if (props.validator(val)) {
          updateState({ code: val });
          if (isFunction(callback))
            callback(val);
        }
      } else {
        updateState({ code: val });
        if (isFunction(callback))
          callback(val);
      }
    };
    const handleChange = (e2) => {
      const val = e2.target.value || "";
      innerEffect.current = true;
      formatValue2(val, props.onChange);
    };
    const renderPoints = () => {
      const Points = [];
      const { mask, gutter } = props;
      for (let i = 0; i < length; i++) {
        const char = codeArr[i];
        const showBorder = i !== 0 && !gutter;
        const showCursor = state.focused && cursorIndex === i && !char;
        let style;
        if (i !== 0 && gutter) {
          style = { marginLeft: addUnit$1(gutter) };
        }
        Points.push(/* @__PURE__ */ React__default["default"].createElement("li", {
          key: i,
          className: clsx({
            [BORDER_LEFT]: showBorder,
            [props.highlightClass]: props.highlightClass && char && !props.mask
          }, bem$r("item", { focus: showCursor })),
          style
        }, mask ? /* @__PURE__ */ React__default["default"].createElement("i", {
          style: { visibility: char ? "visible" : "hidden" }
        }) : char, showCursor && /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$r("cursor"))
        })));
      }
      return Points;
    };
    useUpdateEffect(() => {
      var _a;
      if (innerEffect.current) {
        innerEffect.current = false;
        return;
      }
      formatValue2((_a = props.value) != null ? _a : "");
    }, [props.value]);
    React.useEffect(() => {
      var _a, _b;
      if (state.code.length >= length) {
        (_b = (_a = inputRef == null ? void 0 : inputRef.current) == null ? void 0 : _a.blur) == null ? void 0 : _b.call(_a);
        onSubmit == null ? void 0 : onSubmit(state.code);
      }
    }, [length, state.code]);
    useUpdateEffect(() => {
      if (props.type === "number") {
        updateState({ inputType: "tel", inputMode: "numeric" });
      } else {
        updateState({ inputType: "text" });
      }
    }, [props.type]);
    React.useImperativeHandle(ref, () => ({
      focus,
      blur,
      clear: clear2
    }));
    const info = props.errorInfo || props.info;
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$r(), props.className),
      style: props.style
    }, /* @__PURE__ */ React__default["default"].createElement("ul", {
      className: clsx(bem$r("security"), {
        [BORDER_SURROUND]: !props.gutter
      })
    }, renderPoints(), /* @__PURE__ */ React__default["default"].createElement("input", {
      ref: inputRef,
      type: state.inputType,
      inputMode: state.inputMode,
      pattern: "[0-9]*",
      maxLength: props.length,
      value: state.code,
      autoComplete: "false",
      autoCorrect: "off",
      autoCapitalize: "off",
      autoFocus: props.autoFocus,
      spellCheck: "false",
      onChange: handleChange,
      onFocus: (e2) => {
        var _a;
        updateState({ focused: true });
        (_a = props.onFocus) == null ? void 0 : _a.call(props, e2);
      },
      onBlur: (e2) => {
        var _a;
        updateState({ focused: false });
        (_a = props.onBlur) == null ? void 0 : _a.call(props, e2);
      }
    })), info ? /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$r(props.errorInfo ? "error-info" : "info"))
    }, info) : null);
  });
  PasswordInput.defaultProps = {
    length: 6,
    gutter: 0,
    mask: true,
    type: "text"
  };
  var index$h = "";
  const CollapseIcon = ({ bem: bem2 }) => /* @__PURE__ */ React__default["default"].createElement("svg", {
    className: clsx(bem2("collapse-icon")),
    viewBox: "0 0 30 24"
  }, /* @__PURE__ */ React__default["default"].createElement("path", {
    d: "M25.877 12.843h-1.502c-.188 0-.188 0-.188.19v1.512c0 .188 0 .188.188.188h1.5c.187 0 .187 0 .187-.188v-1.511c0-.19 0-.191-.185-.191zM17.999 10.2c0 .188 0 .188.188.188h1.687c.188 0 .188 0 .188-.188V8.688c0-.187.004-.187-.186-.19h-1.69c-.187 0-.187 0-.187.19V10.2zm2.25-3.967h1.5c.188 0 .188 0 .188-.188v-1.7c0-.19 0-.19-.188-.19h-1.5c-.189 0-.189 0-.189.19v1.7c0 .188 0 .188.19.188zm2.063 4.157h3.563c.187 0 .187 0 .187-.189V4.346c0-.19.004-.19-.185-.19h-1.69c-.187 0-.187 0-.187.188v4.155h-1.688c-.187 0-.187 0-.187.189v1.514c0 .19 0 .19.187.19zM14.812 24l2.812-3.4H12l2.813 3.4zm-9-11.157H4.31c-.188 0-.188 0-.188.19v1.512c0 .188 0 .188.188.188h1.502c.187 0 .187 0 .187-.188v-1.511c0-.19.01-.191-.189-.191zm15.937 0H8.25c-.188 0-.188 0-.188.19v1.512c0 .188 0 .188.188.188h13.5c.188 0 .188 0 .188-.188v-1.511c0-.19 0-.191-.188-.191zm-11.438-2.454h1.5c.188 0 .188 0 .188-.188V8.688c0-.187 0-.187-.188-.189h-1.5c-.187 0-.187 0-.187.189V10.2c0 .188 0 .188.187.188zM27.94 0c.563 0 .917.21 1.313.567.518.466.748.757.748 1.51v14.92c0 .567-.188 1.134-.562 1.512-.376.378-.938.566-1.313.566H2.063c-.563 0-.938-.188-1.313-.566-.562-.378-.75-.945-.75-1.511V2.078C0 1.51.188.944.562.567.938.189 1.5 0 1.875 0zm-.062 2H2v14.92h25.877V2zM5.81 4.157c.19 0 .19 0 .19.189v1.762c-.003.126-.024.126-.188.126H4.249c-.126-.003-.126-.023-.126-.188v-1.7c-.187-.19 0-.19.188-.19zm10.5 2.077h1.503c.187 0 .187 0 .187-.188v-1.7c0-.19 0-.19-.187-.19h-1.502c-.188 0-.188.001-.188.19v1.7c0 .188 0 .188.188.188zM7.875 8.5c.187 0 .187.002.187.189V10.2c0 .188 0 .188-.187.188H4.249c-.126-.002-.126-.023-.126-.188V8.625c.003-.126.024-.126.188-.126zm7.875 0c.19.002.19.002.19.189v1.575c-.003.126-.024.126-.19.126h-1.563c-.126-.002-.126-.023-.126-.188V8.625c.002-.126.023-.126.189-.126zm-6-4.342c.187 0 .187 0 .187.189v1.7c0 .188 0 .188-.187.188H8.187c-.126-.003-.126-.023-.126-.188V4.283c.003-.126.024-.126.188-.126zm3.94 0c.185 0 .372 0 .372.189v1.762c-.002.126-.023.126-.187.126h-1.75C12 6.231 12 6.211 12 6.046v-1.7c0-.19.187-.19.187-.19z",
    fill: "currentColor"
  }));
  const DeleteIcon = ({ bem: bem2 }) => /* @__PURE__ */ React__default["default"].createElement("svg", {
    className: clsx(bem2("delete-icon")),
    viewBox: "0 0 32 22"
  }, /* @__PURE__ */ React__default["default"].createElement("path", {
    d: "M28.016 0A3.991 3.991 0 0132 3.987v14.026c0 2.2-1.787 3.987-3.98 3.987H10.382c-.509 0-.996-.206-1.374-.585L.89 13.09C.33 12.62 0 11.84 0 11.006c0-.86.325-1.62.887-2.08L9.01.585A1.936 1.936 0 0110.383 0zm0 1.947H10.368L2.24 10.28c-.224.226-.312.432-.312.73 0 .287.094.51.312.729l8.128 8.333h17.648a2.041 2.041 0 002.037-2.04V3.987c0-1.127-.915-2.04-2.037-2.04zM23.028 6a.96.96 0 01.678.292.95.95 0 01-.003 1.377l-3.342 3.348 3.326 3.333c.189.188.292.43.292.679 0 .248-.103.49-.292.679a.96.96 0 01-.678.292.959.959 0 01-.677-.292L18.99 12.36l-3.343 3.345a.96.96 0 01-.677.292.96.96 0 01-.678-.292.962.962 0 01-.292-.68c0-.248.104-.49.292-.679l3.342-3.348-3.342-3.348A.963.963 0 0114 6.971c0-.248.104-.49.292-.679A.96.96 0 0114.97 6a.96.96 0 01.677.292l3.358 3.348 3.345-3.348A.96.96 0 0123.028 6z",
    fill: "currentColor"
  }));
  const [bem$q] = createNamespace("key");
  const NumberKeyboardKey = (_E) => {
    var _F = _E, {
      children,
      className,
      style
    } = _F, props = __objRest(_F, [
      "children",
      "className",
      "style"
    ]);
    const [active, setActive] = React.useState(false);
    const touch = useTouch();
    const onTouchStart = (event) => {
      touch.start(event);
      setActive(true);
    };
    const onTouchMove = (event) => {
      touch.move(event);
      if (touch.direction.current) {
        setActive(false);
      }
    };
    const onTouchEnd = (event) => {
      var _a;
      if (active) {
        if (!children) {
          event.preventDefault();
        }
        setActive(false);
        (_a = props.onPress) == null ? void 0 : _a.call(props, props.text, props.type);
      }
    };
    const renderContent = () => {
      if (props.loading) {
        return /* @__PURE__ */ React__default["default"].createElement(Loading, {
          className: clsx(bem$q("loading-icon"))
        });
      }
      const text = children || props.text;
      switch (props.type) {
        case "delete":
          return text || /* @__PURE__ */ React__default["default"].createElement(DeleteIcon, {
            bem: bem$q
          });
        case "extra":
          return text || /* @__PURE__ */ React__default["default"].createElement(CollapseIcon, {
            bem: bem$q
          });
        default:
          return text;
      }
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      style,
      className: clsx(className, bem$q("wrapper", { wider: props.wider })),
      onTouchStart,
      onTouchMove,
      onTouchEnd,
      onTouchCancel: onTouchEnd
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      role: "button",
      tabIndex: 0,
      className: clsx(bem$q([
        props.color,
        {
          large: props.large,
          active,
          delete: props.type === "delete"
        }
      ]))
    }, renderContent()));
  };
  const [bem$p] = createNamespace("number-keyboard");
  const NumberKeyboard = (_G) => {
    var _H = _G, {
      className,
      style
    } = _H, props = __objRest(_H, [
      "className",
      "style"
    ]);
    const root2 = React.useRef();
    const genBasicKeys = () => {
      const keys2 = Array(9).fill("").map((_, i) => ({ text: i + 1 }));
      if (props.randomKeyOrder) {
        keys2.sort(() => Math.random() > 0.5 ? 1 : -1);
      }
      return keys2;
    };
    const genDefaultKeys = () => [
      ...genBasicKeys(),
      { text: props.extraKey, type: "extra" },
      { text: 0 },
      {
        text: props.showDeleteKey ? props.deleteButtonText : "",
        type: props.showDeleteKey ? "delete" : ""
      }
    ];
    const genCustomKeys = () => {
      const keys2 = genBasicKeys();
      const { extraKey } = props;
      const extraKeys = Array.isArray(extraKey) ? extraKey : [extraKey];
      if (extraKeys.length === 1) {
        keys2.push({ text: 0, wider: true }, { text: extraKeys[0], type: "extra" });
      } else if (extraKeys.length === 2) {
        keys2.push({ text: extraKeys[0], type: "extra" }, { text: 0 }, { text: extraKeys[1], type: "extra" });
      }
      return keys2;
    };
    const keys = React.useMemo(() => props.theme === "custom" ? genCustomKeys() : genDefaultKeys(), [props.theme]);
    const onBlur = () => {
      var _a;
      if (props.visible) {
        (_a = props.onBlur) == null ? void 0 : _a.call(props);
      }
    };
    const onClose = () => {
      var _a;
      (_a = props.onClose) == null ? void 0 : _a.call(props);
      if (props.blurOnClose) {
        onBlur();
      }
    };
    const onAnimationEnd = () => {
      var _a;
      (_a = props[props.visible ? "onShow" : "onHide"]) == null ? void 0 : _a.call(props);
    };
    const onPress = (text, type2) => {
      var _a, _b, _c, _d;
      if (text === "") {
        if (type2 === "extra") {
          onBlur();
        }
        return;
      }
      const { value } = props;
      if (type2 === "delete") {
        (_a = props.onDelete) == null ? void 0 : _a.call(props);
        (_b = props.onChange) == null ? void 0 : _b.call(props, value.slice(0, value.length - 1));
      } else if (type2 === "close") {
        onClose();
      } else if (value.length < props.maxlength) {
        (_c = props.onInput) == null ? void 0 : _c.call(props, text);
        (_d = props.onChange) == null ? void 0 : _d.call(props, value + text);
      }
    };
    const renderTitle = () => {
      const { title, theme, closeButtonText } = props;
      const showClose = closeButtonText && theme === "default";
      const showTitle = title || showClose;
      if (!showTitle) {
        return null;
      }
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$p("header"))
      }, title && /* @__PURE__ */ React__default["default"].createElement("h2", {
        className: clsx(bem$p("title"))
      }, title), showClose && /* @__PURE__ */ React__default["default"].createElement("button", {
        type: "button",
        className: clsx(bem$p("close")),
        onClick: onClose
      }, closeButtonText));
    };
    const renderKeys = () => keys.map((key, i) => {
      var _a, _b, _c;
      let keySlots = null;
      if (!key.type) {
        keySlots = (_a = props.numberKeyRender) == null ? void 0 : _a.call(props, key);
      }
      if (key.type === "delete") {
        keySlots = (_b = props.deleteRender) == null ? void 0 : _b.call(props);
      }
      if (key.type === "extra") {
        keySlots = (_c = props.extraKeyRender) == null ? void 0 : _c.call(props);
      }
      return /* @__PURE__ */ React__default["default"].createElement(NumberKeyboardKey, {
        key: i,
        text: key.text,
        type: key.type,
        wider: key.wider,
        color: key.color,
        onPress,
        children: keySlots
      });
    });
    const renderSidebar = () => {
      if (props.theme === "custom") {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$p("sidebar"))
        }, props.showDeleteKey && /* @__PURE__ */ React__default["default"].createElement(NumberKeyboardKey, {
          large: true,
          text: props.deleteButtonText,
          type: "delete",
          onPress
        }), /* @__PURE__ */ React__default["default"].createElement(NumberKeyboardKey, {
          large: true,
          text: props.closeButtonText,
          type: "close",
          color: "blue",
          loading: props.closeButtonLoading,
          onPress
        }));
      }
      return null;
    };
    useUpdateEffect(() => {
      var _a;
      if (!props.transition) {
        (_a = props[props.visible ? "onShow" : "onHide"]) == null ? void 0 : _a.call(props);
      }
    }, [props.visible]);
    useClickAway(root2, props.hideOnClickOutside ? onBlur : noop$3, "touchstart");
    const Title2 = renderTitle();
    const Content = /* @__PURE__ */ React__default["default"].createElement(CSSTransition$1, {
      mountOnEnter: true,
      unmountOnExit: true,
      nodeRef: root2,
      in: props.visible,
      timeout: 300,
      classNames: props.transition ? "rv-slide-up" : "",
      onExited: onAnimationEnd
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      ref: root2,
      style: __spreadValues(__spreadValues({}, style), getZIndexStyle(props.zIndex)),
      className: clsx(className, bem$p({
        unfit: !props.safeAreaInsetBottom,
        "with-title": !!Title2
      })),
      onTouchStart: stopPropagation
    }, Title2, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$p("body"))
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$p("keys"))
    }, renderKeys()), renderSidebar())));
    return Content;
  };
  NumberKeyboard.defaultProps = {
    transition: true,
    blurOnClose: true,
    showDeleteKey: true,
    hideOnClickOutside: true,
    safeAreaInsetBottom: true,
    theme: "default",
    value: "",
    extraKey: "",
    maxlength: Number.MAX_VALUE
  };
  var index$g = "";
  const [bem$o] = createNamespace("slider");
  const Slider = (props) => {
    const [buttonRef1, setButtonRef1] = React.useState(null);
    const [buttonRef2, setButtonRef2] = React.useState(null);
    const buttonIndex = React.useRef();
    const startValue = React.useRef();
    const currentValue = React.useRef(props.value);
    const root2 = React.useRef();
    const dragStatus = React.useRef();
    const touch = useTouch();
    const scope = React.useMemo(() => Number(props.max) - Number(props.min), [props.max, props.min]);
    const wrapperStyle = React.useMemo(() => {
      const crossAxis = props.vertical ? "width" : "height";
      return __spreadValues({
        background: props.inactiveColor,
        [crossAxis]: addUnit$1(props.barHeight)
      }, props.style);
    }, [props.vertical, props.barHeight, props.inactiveColor, props.style]);
    const isRange = (val) => props.range && Array.isArray(val);
    const calcMainAxis = () => {
      const { value, min } = props;
      if (isRange(value)) {
        return `${(value[1] - value[0]) * 100 / scope}%`;
      }
      return `${(+value - Number(min)) * 100 / scope}%`;
    };
    const calcOffset = () => {
      const { value, min } = props;
      if (isRange(value)) {
        return `${(value[0] - Number(min)) * 100 / scope}%`;
      }
      return "0%";
    };
    const barStyle = React.useMemo(() => {
      const mainAxis = props.vertical ? "height" : "width";
      const style = {
        [mainAxis]: calcMainAxis(),
        background: props.activeColor
      };
      if (dragStatus.current) {
        style.transition = "none";
      }
      const getPositionKey = () => {
        if (props.vertical) {
          return props.reverse ? "bottom" : "top";
        }
        return props.reverse ? "right" : "left";
      };
      style[getPositionKey()] = calcOffset();
      return style;
    }, [calcOffset]);
    const format2 = (value) => {
      const min = +props.min;
      const max = +props.max;
      const step = +props.step;
      value = range$1(value, min, max);
      const diff = Math.round((value - min) / step) * step;
      return addNumber(min, diff);
    };
    const isSameValue = (newValue, oldValue) => JSON.stringify(newValue) === JSON.stringify(oldValue);
    const handleRangeValue = (value) => {
      var _a, _b;
      const left2 = (_a = value[0]) != null ? _a : Number(props.min);
      const right2 = (_b = value[1]) != null ? _b : Number(props.max);
      return left2 > right2 ? [right2, left2] : [left2, right2];
    };
    const updateValue = (value, end2) => {
      var _a, _b;
      if (isRange(value)) {
        value = handleRangeValue(value).map(format2);
      } else {
        value = format2(value);
      }
      if (!isSameValue(value, props.value)) {
        (_a = props.onChange) == null ? void 0 : _a.call(props, value);
      }
      if (end2 && !isSameValue(value, startValue.current)) {
        (_b = props.onChangeAfter) == null ? void 0 : _b.call(props, value);
      }
      return value;
    };
    const onClick = (event) => {
      event.stopPropagation();
      if (props.disabled || props.readOnly) {
        return;
      }
      const { min, reverse, vertical, value: modelValue } = props;
      const rect = useRect(root2.current);
      const getDelta = () => {
        if (vertical) {
          if (reverse) {
            return rect.bottom - event.clientY;
          }
          return event.clientY - rect.top;
        }
        if (reverse) {
          return rect.right - event.clientX;
        }
        return event.clientX - rect.left;
      };
      const total = vertical ? rect.height : rect.width;
      const value = Number(min) + getDelta() / total * scope;
      if (isRange(modelValue)) {
        const [left2, right2] = modelValue;
        const middle = (left2 + right2) / 2;
        if (value <= middle) {
          updateValue([value, right2], true);
        } else {
          updateValue([left2, value], true);
        }
      } else {
        updateValue(value, true);
      }
    };
    const onTouchStart = (event) => {
      if (props.disabled || props.readOnly) {
        return;
      }
      touch.start(event);
      currentValue.current = JSON.parse(JSON.stringify(props.value));
      if (isRange(currentValue.current)) {
        startValue.current = currentValue.current.map(format2);
      } else {
        startValue.current = format2(currentValue.current);
      }
      dragStatus.current = "start";
    };
    const onTouchMove = (event) => {
      var _a;
      if (props.disabled || props.readOnly) {
        return;
      }
      if (dragStatus.current === "start") {
        (_a = props.onDragStart) == null ? void 0 : _a.call(props, event, startValue.current);
      }
      preventDefault(event, true);
      touch.move(event);
      dragStatus.current = "dragging";
      const rect = useRect(root2.current);
      const delta = props.vertical ? touch.deltaY.current : touch.deltaX.current;
      const total = props.vertical ? rect.height : rect.width;
      let diff = delta / total * scope;
      if (props.reverse) {
        diff = -diff;
      }
      if (isRange(startValue.current)) {
        const index2 = props.reverse ? 1 - buttonIndex.current : buttonIndex.current;
        currentValue.current[index2] = startValue.current[index2] + diff;
      } else {
        currentValue.current = +startValue.current + diff;
      }
      updateValue(currentValue.current);
    };
    const onTouchEnd = (event) => {
      var _a;
      if (props.disabled || props.readOnly) {
        return;
      }
      if (dragStatus.current === "dragging") {
        const value = updateValue(currentValue.current, true);
        (_a = props.onDragEnd) == null ? void 0 : _a.call(props, event, value);
      }
      dragStatus.current = "";
    };
    const getButtonClassName = (index2) => {
      if (typeof index2 === "number") {
        const position = ["left", "right"];
        return bem$o("button-wrapper", position[index2]);
      }
      return bem$o("button-wrapper", props.reverse ? "left" : "right");
    };
    const renderButtonContent = (value, index2) => {
      if (typeof index2 === "number") {
        const slot = props[index2 === 0 ? "leftButton" : "rightButton"];
        if (slot) {
          return slot;
        }
      }
      if (typeof props.button === "function") {
        return props.button({ value });
      }
      if (props.button) {
        return props.button;
      }
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$o("button")),
        style: getSizeStyle(props.buttonSize)
      });
    };
    const renderButton = (buttounRef, index2) => {
      const value = typeof index2 === "number" ? props.value[index2] : props.value;
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        ref: buttounRef,
        key: index2,
        role: "slider",
        className: clsx(getButtonClassName(index2)),
        tabIndex: props.disabled || props.readOnly ? -1 : 0,
        "aria-valuemin": props.min,
        "aria-valuenow": value,
        "aria-valuemax": props.max,
        "aria-orientation": props.vertical ? "vertical" : "horizontal",
        onTouchStart: (event) => {
          if (typeof index2 === "number") {
            buttonIndex.current = index2;
          }
          onTouchStart(event);
        },
        onTouchEnd,
        onTouchCancel: onTouchEnd,
        onClick: stopPropagation
      }, renderButtonContent(currentValue.current, index2));
    };
    useEventListener("touchmove", onTouchMove, {
      target: buttonRef1,
      depends: [
        touch.deltaX.current,
        touch.deltaY.current,
        props.disabled,
        props.readOnly
      ]
    });
    useEventListener("touchmove", onTouchMove, {
      target: buttonRef2,
      depends: [
        touch.deltaX.current,
        touch.deltaY.current,
        props.disabled,
        props.readOnly
      ]
    });
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      ref: root2,
      style: wrapperStyle,
      className: clsx(props.className, bem$o({
        vertical: props.vertical,
        disabled: props.disabled
      })),
      onClick
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$o("bar")),
      style: barStyle
    }, props.range ? [renderButton(setButtonRef1, 0), renderButton(setButtonRef2, 1)] : renderButton(setButtonRef1)));
  };
  Slider.defaultProps = {
    min: 0,
    max: 100,
    step: 1
  };
  var index$f = "";
  const LONG_PRESS_INTERVAL = 100;
  const LONG_PRESS_START_TIME = 600;
  function add(num1, num2) {
    const cardinal = 10 ** 10;
    return Math.round((num1 + num2) * cardinal) / cardinal;
  }
  const [bem$n] = createNamespace("stepper");
  function Stepper(props) {
    const { defaultValue = 0 } = props;
    let actionType;
    const inputRef = React.useRef(null);
    const [value, setValue2] = usePropsValue(__spreadProps(__spreadValues({}, props), {
      defaultValue,
      onChange: (v2) => {
        var _a;
        (_a = props.onChange) == null ? void 0 : _a.call(props, v2, { name: props.name });
      }
    }));
    const format2 = (v2) => {
      v2 = +formatNumber(String(v2), !props.integer);
      if (isNaN$1(v2))
        return;
      let target = bound(v2, props.min, props.max);
      if (props.decimalLength !== void 0) {
        target = parseFloat(target.toFixed(props.decimalLength));
      }
      return target;
    };
    const setValueWithCheck = (v2) => {
      setValue2(format2(v2));
    };
    const [inputValue, setInputValue, inputValueRef] = useRefState(() => convertValueToText(value, props.decimalLength));
    const [hasFocus, setHasFocus] = React.useState(false);
    React.useEffect(() => {
      if (!hasFocus) {
        setInputValue(convertValueToText(value, props.decimalLength));
      }
    }, [hasFocus]);
    React.useEffect(() => {
      if (!hasFocus) {
        setInputValue(convertValueToText(value, props.decimalLength));
      }
    }, [value, props.decimalLength]);
    const minusDisabled = React.useMemo(() => props.disabled || props.disableMinus || +value <= +props.min, [props.disabled, props.disableMinus, props.min, value]);
    const plusDisabled = React.useMemo(() => props.disabled || props.disablePlus || +value >= +props.max, [props.disabled, props.disablePlus, props.max, value]);
    const inputStyle = React.useMemo(() => ({
      width: addUnit$1(props.inputWidth),
      height: addUnit$1(props.buttonSize)
    }), [props.inputWidth, props.buttonSize]);
    const buttonStyle = React.useMemo(() => getSizeStyle(props.buttonSize), [props.buttonSize]);
    const onChange = (e2) => {
      var _a, _b, _c;
      const isMinus = actionType === "minus";
      if (actionType === "plus" && plusDisabled || isMinus && minusDisabled) {
        (_a = props.onOverlimit) == null ? void 0 : _a.call(props, actionType);
        return;
      }
      const diff = isMinus ? -props.step : +props.step;
      const val = add(+inputValueRef.current, diff);
      setValueWithCheck(val);
      if (isMinus) {
        (_b = props.onMinus) == null ? void 0 : _b.call(props, e2, val);
      } else {
        (_c = props.onPlus) == null ? void 0 : _c.call(props, e2, val);
      }
    };
    const onLongPressChange = () => {
      const isMinus = actionType === "minus";
      const diff = isMinus ? -props.step : +props.step;
      const val = add(+inputValueRef.current, diff);
      setInputValue(`${format2(val)}`);
    };
    const onInput = (event) => {
      const { value: inputValue2 } = event.target;
      setInputValue(inputValue2);
      const value2 = convertTextToValue(inputValue2);
      if (value2 === null) {
        if (props.allowEmpty) {
          setValue2(null);
        } else {
          setValue2(defaultValue);
        }
      } else {
        setValueWithCheck(value2);
      }
    };
    const onFocus = (event) => {
      var _a;
      setHasFocus(true);
      if (props.disableInput && inputRef.current) {
        inputRef.current.blur();
      } else {
        (_a = props.onFocus) == null ? void 0 : _a.call(props, event);
      }
    };
    const onBlur = (event) => {
      var _a;
      setHasFocus(false);
      (_a = props.onBlur) == null ? void 0 : _a.call(props, event);
      resetScroll();
    };
    const isLongPress = React.useRef(false);
    const longPressTimer = React.useRef(null);
    const longPressStep = () => {
      longPressTimer.current = setTimeout(() => {
        onLongPressChange();
        longPressStep();
      }, LONG_PRESS_INTERVAL);
    };
    const onTouchStart = () => {
      if (props.longPress) {
        isLongPress.current = false;
        clearTimeout(longPressTimer.current);
        longPressTimer.current = setTimeout(() => {
          isLongPress.current = true;
          longPressStep();
        }, LONG_PRESS_START_TIME);
      }
    };
    const onTouchEnd = (event) => {
      if (props.longPress) {
        clearTimeout(longPressTimer.current);
        if (isLongPress.current) {
          preventDefault(event);
        }
      }
    };
    const onMousedown = (event) => {
      if (props.disableInput) {
        event.preventDefault();
      }
    };
    const createListeners = (type2) => ({
      onClick: (event) => {
        event.preventDefault();
        actionType = type2;
        onChange(event);
      },
      onTouchStart: () => {
        actionType = type2;
        onTouchStart();
      },
      onTouchEnd,
      onTouchCancel: onTouchEnd
    });
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, bem$n([props.theme])),
      style: props.style
    }, props.showMinus && /* @__PURE__ */ React__default["default"].createElement("button", __spreadValues({
      type: "button",
      "aria-label": "minus",
      style: buttonStyle,
      className: clsx(bem$n("minus", { disabled: minusDisabled }))
    }, createListeners("minus"))), props.showInput && /* @__PURE__ */ React__default["default"].createElement("input", {
      ref: inputRef,
      type: props.integer ? "tel" : "text",
      role: "spinbutton",
      className: clsx(bem$n("input")),
      value: inputValue,
      style: inputStyle,
      disabled: props.disabled,
      readOnly: props.disableInput,
      inputMode: props.integer ? "numeric" : "decimal",
      placeholder: props.placeholder,
      "aria-valuemax": +props.max,
      "aria-valuemin": +props.min,
      "aria-valuenow": +inputValue,
      onChange: onInput,
      onBlur,
      onFocus,
      onMouseDown: onMousedown,
      onClick: props.onClick
    }), props.showPlus && /* @__PURE__ */ React__default["default"].createElement("button", __spreadValues({
      type: "button",
      "aria-label": "add",
      style: buttonStyle,
      className: clsx(bem$n("plus", { disabled: plusDisabled }))
    }, createListeners("plus"))));
  }
  function convertValueToText(value, digits) {
    if (value === null || value === void 0)
      return "";
    if (digits !== void 0) {
      return value.toFixed(digits);
    } else {
      return value.toString();
    }
  }
  function convertTextToValue(text) {
    if (text === "")
      return null;
    return parseFloat(text);
  }
  Stepper.defaultProps = {
    theme: "default",
    max: Number.MAX_VALUE,
    step: 1,
    showPlus: true,
    showMinus: true,
    showInput: true,
    longPress: true
  };
  const [bem$m] = createNamespace("switch");
  const Swtich = (props) => {
    const { loading, disabled, size, activeColor, inactiveColor } = props;
    const [checked, setChecked] = useMergedState({
      value: props.checked,
      defaultValue: props.defaultChecked
    });
    const isChecked = React.useMemo(() => checked === props.activeValue, [checked, props.activeValue]);
    const style = __spreadValues({
      fontSize: addUnit$1(size),
      backgroundColor: isChecked ? activeColor : inactiveColor
    }, props.style);
    const onClick = (e2) => {
      var _a, _b;
      if (!props.disabled) {
        (_a = props.onClick) == null ? void 0 : _a.call(props, e2);
      }
      if (!props.disabled && !props.loading) {
        const newValue = isChecked ? props.inactiveValue : props.activeValue;
        setChecked(newValue);
        (_b = props.onChange) == null ? void 0 : _b.call(props, newValue);
      }
    };
    const renderLoading = () => {
      if (props.loading) {
        const color = isChecked ? props.activeColor : props.inactiveColor;
        return /* @__PURE__ */ React__default["default"].createElement(Loading, {
          className: clsx(bem$m("loading")),
          color
        });
      }
      return null;
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      role: "switch",
      tabIndex: 0,
      className: clsx(props.className, bem$m({
        on: isChecked,
        loading,
        disabled
      })),
      style,
      "aria-checked": isChecked,
      onClick
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$m("node"))
    }, renderLoading()));
  };
  Swtich.defaultProps = {
    activeValue: true,
    inactiveValue: false
  };
  var index$e = "";
  var index$d = "";
  function toArray$2(item) {
    if (Array.isArray(item)) {
      return item;
    }
    return [item];
  }
  function readFileContent(file, resultType) {
    return new Promise((resolve) => {
      if (resultType === "file") {
        resolve();
        return;
      }
      if (isImageFile(file)) {
        resolve(URL.createObjectURL(file));
        return;
      }
      const reader = new FileReader();
      reader.onload = (event) => {
        resolve(event.target.result);
      };
      if (resultType === "dataUrl") {
        reader.readAsDataURL(file);
      } else if (resultType === "text") {
        reader.readAsText(file);
      }
    });
  }
  function isOversize(files, maxSize) {
    return toArray$2(files).some((file) => {
      if (file) {
        if (isFunction(maxSize)) {
          return maxSize(file);
        }
        return file.size > maxSize;
      }
      return false;
    });
  }
  function filterFiles(items, maxSize) {
    const valid = [];
    const invalid = [];
    items.forEach((item) => {
      if (isOversize([item], maxSize)) {
        invalid.push(item);
      } else {
        valid.push(item);
      }
    });
    return { valid, invalid };
  }
  const IMAGE_REGEXP = /\.(jpeg|jpg|gif|png|svg|webp|jfif|bmp|dpg)/i;
  function isImageUrl(url) {
    return IMAGE_REGEXP.test(url);
  }
  function isImageFile(item, isImage) {
    if (isImage) {
      return true;
    }
    if (item.file && item.file.type) {
      return item.file.type.indexOf("image") === 0;
    }
    if (item.url) {
      return isImageUrl(item.url);
    }
    if (item.thumbnail) {
      return isImageUrl(item.thumbnail);
    }
    return false;
  }
  const [bem$l] = createNamespace("uploader");
  const UploaderPreviewItem = (props) => {
    const { onPreview, statusTextRender, status, file, url } = props;
    const isImage = React.useMemo(() => props.isImage || isImageFile({ file, url }), [file, url, props.isImage]);
    const imageSrc = React.useMemo(() => {
      if (isImage) {
        if (url)
          return url;
        if (file) {
          return URL.createObjectURL(file);
        }
      }
      return "";
    }, [isImage, file, url]);
    const renderMask = () => {
      if (status === "failed" || status === "pending") {
        const MaskIcon = status === "failed" ? /* @__PURE__ */ React__default["default"].createElement(SvgClose, {
          className: clsx(bem$l("mask-icon"))
        }) : /* @__PURE__ */ React__default["default"].createElement(Loading, {
          className: clsx(bem$l("loading"))
        });
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$l("mask"))
        }, MaskIcon, statusTextRender && /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$l("mask-message"))
        }, statusTextRender(status)));
      }
      return null;
    };
    const renderDeleteIcon = () => {
      if (props.deletable) {
        return props.deleteRender ? props.deleteRender(props.onDelete) : /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$l("preview-delete")),
          onClick: props.onDelete
        }, /* @__PURE__ */ React__default["default"].createElement(SvgCross, {
          className: clsx(bem$l("preview-delete-icon"))
        }));
      }
      return null;
    };
    const renderCover = () => {
      var _a;
      return (_a = props.previewCoverRender) == null ? void 0 : _a.call(props);
    };
    const renderPreview = () => {
      if (isImage) {
        return /* @__PURE__ */ React__default["default"].createElement(ImageNamespace, {
          fit: props.imageFit,
          src: imageSrc,
          className: clsx(bem$l("preview-image")),
          width: props.previewSize,
          height: props.previewSize,
          onClick: onPreview
        }, renderCover());
      }
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$l("file")),
        style: getSizeStyle(props.previewSize)
      }, /* @__PURE__ */ React__default["default"].createElement(SvgDescription, {
        className: clsx(bem$l("file-icon"))
      }), /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$l("file-name"), "rv-ellipsis")
      }, file ? file.name : url), renderCover());
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$l("preview")),
      onClick: props.onClick
    }, renderPreview(), renderMask(), renderDeleteIcon());
  };
  const [bem$k] = createNamespace("uploader");
  const Uploader = React.forwardRef((props, ref) => {
    var _a;
    const [value, setValue2] = usePropsValue(__spreadProps(__spreadValues({}, props), {
      defaultValue: (_a = props.defaultValue) != null ? _a : []
    }));
    const imagePreview = React.useRef(null);
    const inputRef = React.useRef();
    const [tasks, setTasks] = React.useState([]);
    const idCountRef = React.useRef(0);
    useIsomorphicLayoutEffect(() => {
      if (!Array.isArray(value))
        return;
      setTasks((prev2) => prev2.filter((task) => {
        if (task.url === void 0)
          return true;
        return !value.some((fileItem) => fileItem.url === task.url);
      }));
    }, [value]);
    const { maxCount, maxSize, resultType, beforeRead: beforeRead2 } = props;
    async function processFile(file, fileList) {
      let transformedFile = file;
      transformedFile = await (beforeRead2 == null ? void 0 : beforeRead2(file, fileList));
      return transformedFile;
    }
    const onChange = async (event) => {
      var _a2;
      event.persist();
      const { files: rawFiles } = event.target;
      if (!rawFiles)
        return;
      let files = [].slice.call(rawFiles);
      event.target.value = "";
      if (props.disabled) {
        return;
      }
      if (props.beforeRead) {
        const postFiles = files.map((file) => {
          return processFile(file, files);
        });
        await Promise.all(postFiles).then((filesList) => {
          files = filesList.filter(Boolean);
        });
      }
      if (files.length === 0) {
        return;
      }
      if (maxCount > 0) {
        const exceed = value.length + files.length - maxCount;
        if (exceed > 0) {
          files = files.slice(0, files.length - exceed);
        }
        if (isOversize(files, maxSize)) {
          const result = filterFiles(files, maxSize);
          (_a2 = props.onOversize) == null ? void 0 : _a2.call(props, result.invalid);
          return;
        }
      }
      const newTasks = files.map((file) => ({
        id: idCountRef.current++,
        status: "pending",
        file
      }));
      setTasks((prev2) => [...prev2, ...newTasks]);
      await Promise.all(newTasks.map(async (currentTask) => {
        try {
          let result = {};
          if (props.upload) {
            result = await props.upload(currentTask.file);
          } else {
            const dataUrl = await readFileContent(currentTask.file, resultType);
            result.url = dataUrl;
            result.file = currentTask.file;
            result.key = currentTask.id;
          }
          setTasks((prev2) => {
            return prev2.map((task) => {
              if (task.id === currentTask.id) {
                return __spreadProps(__spreadValues({}, task), {
                  url: result.url
                });
              }
              return task;
            });
          });
          setValue2((prev2) => {
            const newVal = __spreadProps(__spreadValues({}, result), { file: currentTask.file });
            return [...prev2, newVal];
          });
        } catch (e2) {
          setTasks((prev2) => {
            return prev2.map((task) => {
              if (task.id === currentTask.id) {
                return __spreadProps(__spreadValues({}, task), {
                  status: "failed"
                });
              }
              return task;
            });
          });
          throw e2;
        }
      })).catch((error) => console.error(error));
    };
    const previewImage = (item) => {
      if (props.previewFullImage) {
        const imageFiles = value.filter((v2) => {
          var _a2;
          return isImageFile(v2, (_a2 = props.isImageUrl) == null ? void 0 : _a2.call(props, v2));
        });
        const images = imageFiles.map((image) => image.url || image.thumbnail).filter(Boolean);
        imagePreview.current = ImagePreview.open(extend({
          images,
          startPosition: imageFiles.indexOf(item),
          onClose: props.onClosePreview
        }, props.previewOptions));
      }
    };
    const closeImagePreview = () => {
      if (imagePreview.current) {
        imagePreview.current.close();
      }
    };
    const renderPreviewItem = (item, index2) => {
      var _a2, _b, _c;
      return /* @__PURE__ */ React__default["default"].createElement(UploaderPreviewItem, {
        file: item.file,
        key: (_a2 = item.key) != null ? _a2 : `-${index2}`,
        name: props.name,
        isImage: (_b = props.isImageUrl) == null ? void 0 : _b.call(props, item),
        url: (_c = item.thumbnail) != null ? _c : item.url,
        imageFit: props.imageFit,
        deletable: props.deletable,
        previewSize: props.previewSize,
        deleteRender: props.deleteRender,
        previewCoverRender: () => {
          var _a3;
          return (_a3 = props.previewCoverRender) == null ? void 0 : _a3.call(props, item);
        },
        onClick: () => {
          var _a3;
          return (_a3 = props.onClickPreview) == null ? void 0 : _a3.call(props, item, index2);
        },
        onDelete: async () => {
          var _a3;
          const canDelete = await ((_a3 = props.onDelete) == null ? void 0 : _a3.call(props, item));
          if (canDelete === false)
            return;
          setValue2(value.filter((_, i) => i !== index2));
        },
        onPreview: () => previewImage(item)
      });
    };
    const renderPreviewList = () => {
      if (props.previewImage) {
        return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, value.map(renderPreviewItem), tasks.map((task) => {
          if (task.status === "failed")
            return null;
          return /* @__PURE__ */ React__default["default"].createElement(UploaderPreviewItem, {
            key: task.id,
            file: task.file,
            status: task.status,
            statusTextRender: props.statusTextRender,
            deletable: task.status !== "pending",
            deleteRender: props.deleteRender,
            imageFit: props.imageFit,
            onDelete: () => {
              setTasks(tasks.filter((x2) => x2.id !== task.id));
            }
          });
        }));
      }
      return null;
    };
    const renderUploadIcon = () => {
      if (props.uploadIcon) {
        return React__default["default"].cloneElement(props.uploadIcon, {
          className: clsx(bem$k("upload-icon"))
        });
      }
      return null;
    };
    const renderUpload = () => {
      if (props.showUpload && (maxCount === 0 || value.length + tasks.length < maxCount)) {
        const Input2 = props.readOnly ? null : /* @__PURE__ */ React__default["default"].createElement("input", {
          ref: inputRef,
          type: "file",
          className: clsx(bem$k("input")),
          accept: props.accept,
          capture: props.capture,
          multiple: props.multiple,
          disabled: props.disabled,
          onChange
        });
        if (props.children) {
          return /* @__PURE__ */ React__default["default"].createElement("div", {
            className: clsx(bem$k("input-wrapper")),
            onClick: props.onClickUpload
          }, props.children, Input2);
        }
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$k("upload", { readOnly: props.readOnly })),
          style: getSizeStyle(props.previewSize),
          onClick: props.onClickUpload
        }, renderUploadIcon(), props.uploadText && /* @__PURE__ */ React__default["default"].createElement("span", {
          className: clsx(bem$k("upload-text"))
        }, props.uploadText), Input2);
      }
      return null;
    };
    const chooseFile = () => {
      if (inputRef.current && !props.disabled) {
        inputRef.current.click();
      }
    };
    React.useImperativeHandle(ref, () => ({
      chooseFile,
      closeImagePreview
    }));
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$k())
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$k("wrapper", { disabled: props.disabled }))
    }, renderPreviewList(), renderUpload()));
  });
  Uploader.defaultProps = {
    maxSize: Number.MAX_VALUE,
    maxCount: Number.MAX_VALUE,
    deletable: true,
    showUpload: true,
    previewImage: true,
    previewFullImage: true,
    name: "",
    accept: "image/*",
    imageFit: "cover",
    resultType: "dataUrl",
    uploadIcon: /* @__PURE__ */ React__default["default"].createElement(SvgPhotograph, null)
  };
  var index$c = "";
  const [bem$j] = createNamespace("progress");
  const Progress = (props) => {
    const background = React.useMemo(() => props.inactive ? "#cacaca" : props.color, [props.inactive, props.color]);
    const renderPivot = () => {
      const { textColor, pivotText, pivotColor, percentage: percentage2 } = props;
      const text = pivotText != null ? pivotText : `${percentage2}%`;
      if (props.showPivot && text) {
        const style = {
          color: textColor,
          left: `${+percentage2}%`,
          transform: `translate(-${+percentage2}%,-50%)`,
          background: pivotColor || background
        };
        return /* @__PURE__ */ React__default["default"].createElement("span", {
          style,
          className: clsx(bem$j("pivot"))
        }, text);
      }
      return null;
    };
    const { trackColor, percentage, strokeWidth } = props;
    const rootStyle = __spreadProps(__spreadValues({}, props.style), {
      background: trackColor,
      height: addUnit$1(strokeWidth)
    });
    const portionStyle = {
      background,
      transform: `scaleX(${+percentage / 100})`
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$j(), props.className),
      style: rootStyle
    }, /* @__PURE__ */ React__default["default"].createElement("span", {
      className: clsx(bem$j("portion")),
      style: portionStyle
    }), renderPivot());
  };
  Progress.defaultProps = {
    showPivot: true,
    percentage: 0
  };
  var index$b = "";
  let uid = 0;
  function format$1(rate) {
    return Math.min(Math.max(+rate, 0), 100);
  }
  function getPath(clockwise, viewBoxSize) {
    const sweepFlag = clockwise ? 1 : 0;
    return `M ${viewBoxSize / 2} ${viewBoxSize / 2} m 0, -500 a 500, 500 0 1, ${sweepFlag} 0, 1000 a 500, 500 0 1, ${sweepFlag} 0, -1000`;
  }
  const ROTATE_ANGLE_MAP = {
    top: 0,
    right: 90,
    bottom: 180,
    left: 270
  };
  const [bem$i] = createNamespace("circle");
  const Circle = (props) => {
    const id = `van-circle-${uid++}`;
    const [currentRate, setCurrentRate] = React.useState(() => props.defaultRate || 0);
    const [current] = useMergedState({
      defaultValue: props.defaultRate,
      value: props.rate
    });
    const viewBoxSize = React.useMemo(() => +props.strokeWidth + 1e3, [props.strokeWidth]);
    const path = React.useMemo(() => getPath(props.clockwise, viewBoxSize), [props.clockwise, viewBoxSize]);
    const svgStyle = React.useMemo(() => {
      const angleValue = ROTATE_ANGLE_MAP[props.startPosition];
      if (angleValue) {
        return {
          transform: `rotate(${angleValue}deg)`
        };
      }
      return void 0;
    }, [props.startPosition]);
    React.useEffect(() => {
      let rafId2;
      const startTime = Date.now();
      const startRate = currentRate;
      const endRate = format$1(current);
      const duration = Math.abs((startRate - endRate) * 1e3 / +props.speed);
      const animate = () => {
        var _a;
        const now = Date.now();
        const progress = Math.min((now - startTime) / duration, 1);
        const rate = progress * (endRate - startRate) + startRate;
        const crate = format$1(parseFloat(rate.toFixed(1)));
        setCurrentRate(crate);
        if (endRate > startRate ? rate < endRate : rate > endRate) {
          rafId2 = raf$1(animate);
        } else {
          (_a = props.onChange) == null ? void 0 : _a.call(props, crate);
        }
      };
      if (props.speed) {
        if (rafId2) {
          cancelRaf(rafId2);
        }
        rafId2 = raf$1(animate);
      } else {
        setCurrentRate(endRate);
      }
    }, [current]);
    const renderHover = () => {
      const PERIMETER = 3140;
      const { strokeWidth } = props;
      const offset2 = PERIMETER * currentRate / 100;
      const color = isObject$1(props.color) ? `url(#${id})` : props.color;
      const style = {
        stroke: color,
        strokeWidth: `${+strokeWidth + 1}px`,
        strokeLinecap: props.strokeLinecap,
        strokeDasharray: `${offset2}px ${PERIMETER}px`
      };
      return /* @__PURE__ */ React__default["default"].createElement("path", {
        d: path,
        style,
        className: clsx(bem$i("hover")),
        stroke: color
      });
    };
    const renderLayer = () => {
      const style = {
        fill: props.fill,
        stroke: props.layerColor,
        strokeWidth: `${props.strokeWidth}px`
      };
      return /* @__PURE__ */ React__default["default"].createElement("path", {
        className: clsx(bem$i("layer")),
        style,
        d: path
      });
    };
    const renderGradient = () => {
      const { color } = props;
      if (!isObject$1(color)) {
        return null;
      }
      const Stops = Object.keys(color).sort((a, b2) => parseFloat(a) - parseFloat(b2)).map((key, index2) => /* @__PURE__ */ React__default["default"].createElement("stop", {
        key: index2,
        offset: key,
        stopColor: color[key]
      }));
      return /* @__PURE__ */ React__default["default"].createElement("defs", null, /* @__PURE__ */ React__default["default"].createElement("linearGradient", {
        id,
        x1: "100%",
        y1: "0%",
        x2: "0%",
        y2: "0%"
      }, Stops));
    };
    const renderText = () => {
      if (props.text) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$i("text"))
        }, props.text);
      }
      return props.children;
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$i(), props.className),
      style: __spreadValues(__spreadValues({}, props.style), getSizeStyle(props.size))
    }, /* @__PURE__ */ React__default["default"].createElement("svg", {
      viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}`,
      style: svgStyle
    }, renderGradient(), renderLayer(), renderHover()), renderText());
  };
  Circle.defaultProps = {
    clockwise: true,
    speed: 100,
    fill: "none",
    strokeWidth: 40,
    startPosition: "top"
  };
  var index$a = "";
  function makePage(number2, text, active) {
    return { number: number2, text, active };
  }
  const [bem$h] = createNamespace("pagination");
  const Pagination = (props) => {
    const { locale } = React.useContext(ConfigProvider$1);
    const count = React.useMemo(() => {
      const { pageCount, totalItems, itemsPerPage } = props;
      const innerCount = +pageCount || Math.ceil(+totalItems / +itemsPerPage);
      return Math.max(1, innerCount);
    }, [props.pageCount, props.totalItems, props.itemsPerPage]);
    const pages = React.useMemo(() => {
      const items = [];
      const pageCount = count;
      const showPageSize = +props.showPageSize;
      const { value: value2, forceEllipses } = props;
      if (props.mode !== "multi") {
        return items;
      }
      let startPage = 1;
      let endPage = pageCount;
      const isMaxSized = showPageSize < pageCount;
      if (isMaxSized) {
        startPage = Math.max(value2 - Math.floor(showPageSize / 2), 1);
        endPage = startPage + showPageSize - 1;
        if (endPage > pageCount) {
          endPage = pageCount;
          startPage = endPage - showPageSize + 1;
        }
      }
      for (let number2 = startPage; number2 <= endPage; number2++) {
        const page = makePage(number2, number2, number2 === value2);
        items.push(page);
      }
      if (isMaxSized && showPageSize > 0 && forceEllipses) {
        if (startPage > 1) {
          const prevPages = makePage(startPage - 1, "...");
          items.unshift(prevPages);
        }
        if (endPage < pageCount) {
          const nextPages = makePage(endPage + 1, "...");
          items.push(nextPages);
        }
      }
      return items;
    }, [props.showPageSize, props.forceEllipses, props.value, count]);
    const select = (page, emitChange) => {
      var _a;
      page = Math.min(count, Math.max(1, page));
      if (props.value !== page) {
        if (emitChange) {
          (_a = props.onChange) == null ? void 0 : _a.call(props, page);
        }
      }
    };
    React.useEffect(() => {
      select(props.value);
    }, [props.value]);
    const renderDesc = () => {
      if (props.mode !== "multi") {
        return /* @__PURE__ */ React__default["default"].createElement("li", {
          className: clsx(bem$h("page-desc"))
        }, props.pageDesc ? props.pageDesc : `${props.value}/${count}`);
      }
      return null;
    };
    const simple = props.mode !== "multi";
    const onSelect = (value2) => () => select(value2, true);
    const { value } = props;
    return /* @__PURE__ */ React__default["default"].createElement("ul", {
      className: clsx(bem$h({ simple }))
    }, /* @__PURE__ */ React__default["default"].createElement("li", {
      className: clsx(bem$h("item", { disabled: value === 1 }), bem$h("prev"), BORDER),
      onClick: onSelect(value - 1)
    }, props.prevText || locale.vanPagination.prev), pages.map((page, index2) => /* @__PURE__ */ React__default["default"].createElement("li", {
      key: index2,
      className: clsx(bem$h("item", { active: page.active }), bem$h("page"), BORDER),
      onClick: onSelect(page.number)
    }, props.pageRender ? props.pageRender(page) : page.text)), renderDesc(), /* @__PURE__ */ React__default["default"].createElement("li", {
      className: clsx(bem$h("item", { disabled: value === count }), bem$h("next"), BORDER),
      onClick: onSelect(value + 1)
    }, props.nextText || locale.vanPagination.next));
  };
  Pagination.defaultProps = {
    mode: "multi",
    pageCount: 0,
    totalItems: 0,
    itemsPerPage: 10,
    showPageSize: 5
  };
  var index$9 = "";
  const TabbarContext = React.createContext({});
  const [bem$g] = createNamespace("tabbar");
  const Tabbar$1 = (props) => {
    const [current, setCurrent] = useMergedState({
      value: props.value,
      defaultValue: props.defaultValue
    });
    const root2 = React.useRef();
    const height = useHeight(root2);
    const renderPlaceholder = (renderContent) => {
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$g("placeholder")),
        style: { height }
      }, renderContent());
    };
    const enableSafeArea = () => {
      var _a;
      return (_a = props.safeAreaInsetBottom) != null ? _a : props.fixed;
    };
    const setActive = (active) => {
      var _a;
      if (active !== props.value) {
        (_a = props.onChange) == null ? void 0 : _a.call(props, active);
        setCurrent(active);
      }
    };
    const renderTabbar = () => {
      const { fixed, zIndex, border } = props;
      return /* @__PURE__ */ React__default["default"].createElement(TabbarContext.Provider, {
        value: { parent: __spreadProps(__spreadValues({}, props), { value: current }) }
      }, /* @__PURE__ */ React__default["default"].createElement("div", {
        ref: root2,
        style: __spreadValues(__spreadValues({}, props.style), getZIndexStyle(zIndex)),
        className: clsx(props.className, bem$g({ fixed }), {
          [BORDER_TOP_BOTTOM]: border,
          "rv-safe-area-bottom": enableSafeArea()
        })
      }, React__default["default"].Children.toArray(props.children).filter(Boolean).map((child, index2) => React__default["default"].cloneElement(child, {
        setActive,
        index: index2
      }))));
    };
    if (props.fixed && props.placeholder) {
      return renderPlaceholder(renderTabbar);
    }
    return renderTabbar();
  };
  Tabbar$1.defaultProps = {
    fixed: true,
    border: true,
    defaultValue: 0
  };
  const [bem$f] = createNamespace("tabbar-item");
  const TabbarItem = (props) => {
    const { setActive, index: index2 } = props;
    const { parent } = React.useContext(TabbarContext);
    const { activeColor, inactiveColor } = parent;
    const active = React.useMemo(() => {
      return (props.name || index2) === parent.value;
    }, [props.name, index2, parent.value]);
    const onClick = (event) => {
      var _a, _b;
      setActive((_a = props.name) != null ? _a : index2);
      (_b = props.onClick) == null ? void 0 : _b.call(props, event);
    };
    const renderIcon = () => {
      if (typeof props.icon === "function") {
        return props.icon(active);
      }
      if (props.icon) {
        return props.icon;
      }
      return null;
    };
    const color = active ? activeColor : inactiveColor;
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, bem$f({ active })),
      style: __spreadProps(__spreadValues({}, props.style), { color }),
      onClick
    }, /* @__PURE__ */ React__default["default"].createElement(Badge, __spreadProps(__spreadValues({}, props.badge), {
      className: clsx(bem$f("icon"))
    }), renderIcon()), /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$f("text"))
    }, typeof props.children === "function" ? props.children(active) : props.children));
  };
  const Tabbar = Object.assign(Tabbar$1, { Item: TabbarItem });
  function mapThemeVarsToCSSVars(themeVars, prefix2) {
    const cssVars = {};
    Object.keys(themeVars).forEach((key) => {
      if (key.toString().startsWith(`--${prefix2}-`)) {
        cssVars[key] = themeVars[key];
      } else {
        cssVars[`--${prefix2}-${kebabCase$1(key)}`] = themeVars[key];
      }
    });
    return cssVars;
  }
  const ConfigProvider = (_I) => {
    var _J = _I, {
      className,
      style,
      themeVars,
      tag = "div",
      children
    } = _J, props = __objRest(_J, [
      "className",
      "style",
      "themeVars",
      "tag",
      "children"
    ]);
    const TagElement = tag;
    const varStyle = React.useMemo(() => {
      if (themeVars) {
        return __spreadValues(__spreadValues({}, style), mapThemeVarsToCSSVars(themeVars, "rv"));
      }
      return style;
    }, [style, themeVars]);
    return /* @__PURE__ */ React__default["default"].createElement(ConfigProvider$1.Provider, {
      value: __spreadValues(__spreadValues({}, INITIAL_STATE$1), props)
    }, /* @__PURE__ */ React__default["default"].createElement(TagElement, {
      className,
      style: varStyle
    }, children));
  };
  ConfigProvider.defaultProps = {
    themeVars: {}
  };
  var index$8 = "";
  function _objectWithoutProperties(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose$3(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function ownKeys(object2, enumerableOnly) {
    var keys = Object.keys(object2);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object2);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray(arr);
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
      return Array.from(iter);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o, minLen);
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass)
      _setPrototypeOf$1(subClass, superClass);
  }
  function _getPrototypeOf$1(o) {
    _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf$1(o);
  }
  function _isNativeReflectConstruct$1() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof(obj);
  }
  function _possibleConstructorReturn(self2, call2) {
    if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
      return call2;
    } else if (call2 !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self2);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf$1(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$1(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  var reactIs$1 = { exports: {} };
  var reactIs_production_min$1 = {};
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var b$1 = typeof Symbol === "function" && Symbol.for, c$1 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$1 = b$1 ? Symbol.for("react.fragment") : 60107, f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h$1 = b$1 ? Symbol.for("react.provider") : 60109, k$1 = b$1 ? Symbol.for("react.context") : 60110, l$1 = b$1 ? Symbol.for("react.async_mode") : 60111, m$1 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n$1 = b$1 ? Symbol.for("react.forward_ref") : 60112, p$1 = b$1 ? Symbol.for("react.suspense") : 60113, q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120, r = b$1 ? Symbol.for("react.memo") : 60115, t$1 = b$1 ? Symbol.for("react.lazy") : 60116, v$1 = b$1 ? Symbol.for("react.block") : 60121, w = b$1 ? Symbol.for("react.fundamental") : 60117, x = b$1 ? Symbol.for("react.responder") : 60118, y = b$1 ? Symbol.for("react.scope") : 60119;
  function z(a) {
    if (typeof a === "object" && a !== null) {
      var u2 = a.$$typeof;
      switch (u2) {
        case c$1:
          switch (a = a.type, a) {
            case l$1:
            case m$1:
            case e$1:
            case g$1:
            case f$1:
            case p$1:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k$1:
                case n$1:
                case t$1:
                case r:
                case h$1:
                  return a;
                default:
                  return u2;
              }
          }
        case d$1:
          return u2;
      }
    }
  }
  function A(a) {
    return z(a) === m$1;
  }
  reactIs_production_min$1.AsyncMode = l$1;
  reactIs_production_min$1.ConcurrentMode = m$1;
  reactIs_production_min$1.ContextConsumer = k$1;
  reactIs_production_min$1.ContextProvider = h$1;
  reactIs_production_min$1.Element = c$1;
  reactIs_production_min$1.ForwardRef = n$1;
  reactIs_production_min$1.Fragment = e$1;
  reactIs_production_min$1.Lazy = t$1;
  reactIs_production_min$1.Memo = r;
  reactIs_production_min$1.Portal = d$1;
  reactIs_production_min$1.Profiler = g$1;
  reactIs_production_min$1.StrictMode = f$1;
  reactIs_production_min$1.Suspense = p$1;
  reactIs_production_min$1.isAsyncMode = function(a) {
    return A(a) || z(a) === l$1;
  };
  reactIs_production_min$1.isConcurrentMode = A;
  reactIs_production_min$1.isContextConsumer = function(a) {
    return z(a) === k$1;
  };
  reactIs_production_min$1.isContextProvider = function(a) {
    return z(a) === h$1;
  };
  reactIs_production_min$1.isElement = function(a) {
    return typeof a === "object" && a !== null && a.$$typeof === c$1;
  };
  reactIs_production_min$1.isForwardRef = function(a) {
    return z(a) === n$1;
  };
  reactIs_production_min$1.isFragment = function(a) {
    return z(a) === e$1;
  };
  reactIs_production_min$1.isLazy = function(a) {
    return z(a) === t$1;
  };
  reactIs_production_min$1.isMemo = function(a) {
    return z(a) === r;
  };
  reactIs_production_min$1.isPortal = function(a) {
    return z(a) === d$1;
  };
  reactIs_production_min$1.isProfiler = function(a) {
    return z(a) === g$1;
  };
  reactIs_production_min$1.isStrictMode = function(a) {
    return z(a) === f$1;
  };
  reactIs_production_min$1.isSuspense = function(a) {
    return z(a) === p$1;
  };
  reactIs_production_min$1.isValidElementType = function(a) {
    return typeof a === "string" || typeof a === "function" || a === e$1 || a === m$1 || a === g$1 || a === f$1 || a === p$1 || a === q$1 || typeof a === "object" && a !== null && (a.$$typeof === t$1 || a.$$typeof === r || a.$$typeof === h$1 || a.$$typeof === k$1 || a.$$typeof === n$1 || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v$1);
  };
  reactIs_production_min$1.typeOf = z;
  {
    reactIs$1.exports = reactIs_production_min$1;
  }
  function toArray$1(children) {
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var ret = [];
    React__default["default"].Children.forEach(children, function(child) {
      if ((child === void 0 || child === null) && !option.keepEmpty) {
        return;
      }
      if (Array.isArray(child)) {
        ret = ret.concat(toArray$1(child));
      } else if (reactIs$1.exports.isFragment(child) && child.props) {
        ret = ret.concat(toArray$1(child.props.children, option));
      } else {
        ret.push(child);
      }
    });
    return ret;
  }
  var warned = {};
  function warning$1(valid, message) {
  }
  function call(method2, valid, message) {
    if (!valid && !warned[message]) {
      method2(false, message);
      warned[message] = true;
    }
  }
  function warningOnce(valid, message) {
    call(warning$1, valid, message);
  }
  var HOOK_MARK = "RC_FORM_INTERNAL_HOOKS";
  var warningFunc = function warningFunc2() {
    warningOnce(false, "Can not find FormContext. Please make sure you wrap Field under Form.");
  };
  var Context = /* @__PURE__ */ React__namespace.createContext({
    getFieldValue: warningFunc,
    getFieldsValue: warningFunc,
    getFieldError: warningFunc,
    getFieldWarning: warningFunc,
    getFieldsError: warningFunc,
    isFieldsTouched: warningFunc,
    isFieldTouched: warningFunc,
    isFieldValidating: warningFunc,
    isFieldsValidating: warningFunc,
    resetFields: warningFunc,
    setFields: warningFunc,
    setFieldsValue: warningFunc,
    validateFields: warningFunc,
    submit: warningFunc,
    getInternalHooks: function getInternalHooks() {
      warningFunc();
      return {
        dispatch: warningFunc,
        initEntityValue: warningFunc,
        registerField: warningFunc,
        useSubscribe: warningFunc,
        setInitialValues: warningFunc,
        destroyForm: warningFunc,
        setCallbacks: warningFunc,
        registerWatch: warningFunc,
        getFields: warningFunc,
        setValidateMessages: warningFunc,
        setPreserve: warningFunc,
        getInitialValue: warningFunc
      };
    }
  });
  function toArray(value) {
    if (value === void 0 || value === null) {
      return [];
    }
    return Array.isArray(value) ? value : [value];
  }
  function _regeneratorRuntime() {
    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
    _regeneratorRuntime = function _regeneratorRuntime2() {
      return exports3;
    };
    var exports3 = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = typeof Symbol == "function" ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define2(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      }), obj[key];
    }
    try {
      define2({}, "");
    } catch (err) {
      define2 = function define3(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self2, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context2(tryLocsList || []);
      return generator._invoke = function(innerFn2, self3, context2) {
        var state = "suspendedStart";
        return function(method2, arg) {
          if (state === "executing")
            throw new Error("Generator is already running");
          if (state === "completed") {
            if (method2 === "throw")
              throw arg;
            return doneResult();
          }
          for (context2.method = method2, context2.arg = arg; ; ) {
            var delegate = context2.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context2);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if (context2.method === "next")
              context2.sent = context2._sent = context2.arg;
            else if (context2.method === "throw") {
              if (state === "suspendedStart")
                throw state = "completed", context2.arg;
              context2.dispatchException(context2.arg);
            } else
              context2.method === "return" && context2.abrupt("return", context2.arg);
            state = "executing";
            var record = tryCatch(innerFn2, self3, context2);
            if (record.type === "normal") {
              if (state = context2.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
                continue;
              return {
                value: record.arg,
                done: context2.done
              };
            }
            record.type === "throw" && (state = "completed", context2.method = "throw", context2.arg = record.arg);
          }
        };
      }(innerFn, self2, context), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports3.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype = {};
    define2(IteratorPrototype, iteratorSymbol, function() {
      return this;
    });
    var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method2) {
        define2(prototype, method2, function(arg) {
          return this._invoke(method2, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method2, arg, resolve, reject) {
        var record = tryCatch(generator[method2], generator, arg);
        if (record.type !== "throw") {
          var result = record.arg, value = result.value;
          return value && _typeof(value) == "object" && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
            invoke("next", value2, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function(error) {
            return invoke("throw", error, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      this._invoke = function(method2, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method2, arg, resolve, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var method2 = delegate.iterator[context.method];
      if (method2 === void 0) {
        if (context.delegate = null, context.method === "throw") {
          if (delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), context.method === "throw"))
            return ContinueSentinel;
          context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }
        return ContinueSentinel;
      }
      var record = tryCatch(method2, delegate.iterator, context.arg);
      if (record.type === "throw")
        return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, context.method !== "return" && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context2(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod)
          return iteratorMethod.call(iterable);
        if (typeof iterable.next == "function")
          return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1, next = function next2() {
            for (; ++i < iterable.length; ) {
              if (hasOwn.call(iterable, i))
                return next2.value = iterable[i], next2.done = false, next2;
            }
            return next2.value = void 0, next2.done = true, next2;
          };
          return next.next = next;
        }
      }
      return {
        next: doneResult
      };
    }
    function doneResult() {
      return {
        value: void 0,
        done: true
      };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, define2(Gp, "constructor", GeneratorFunctionPrototype), define2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports3.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun == "function" && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction");
    }, exports3.mark = function(genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define2(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports3.awrap = function(arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
      return this;
    }), exports3.AsyncIterator = AsyncIterator, exports3.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
      PromiseImpl === void 0 && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
      return exports3.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define2(Gp, toStringTagSymbol, "Generator"), define2(Gp, iteratorSymbol, function() {
      return this;
    }), define2(Gp, "toString", function() {
      return "[object Generator]";
    }), exports3.keys = function(object2) {
      var keys = [];
      for (var key in object2) {
        keys.push(key);
      }
      return keys.reverse(), function next() {
        for (; keys.length; ) {
          var key2 = keys.pop();
          if (key2 in object2)
            return next.value = key2, next.done = false, next;
        }
        return next.done = true, next;
      };
    }, exports3.values = values, Context2.prototype = {
      constructor: Context2,
      reset: function reset(skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
          for (var name in this) {
            name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
          }
      },
      stop: function stop2() {
        this.done = true;
        var rootRecord = this.tryEntries[0].completion;
        if (rootRecord.type === "throw")
          throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done)
          throw exception;
        var context = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i], record = entry.completion;
          if (entry.tryLoc === "root")
            return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc)
                return handle(entry.catchLoc, true);
              if (this.prev < entry.finallyLoc)
                return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc)
                return handle(entry.catchLoc, true);
            } else {
              if (!hasFinally)
                throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc)
                return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(type2, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && (type2 === "break" || type2 === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type2, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if (record.type === "throw")
          throw record.arg;
        return record.type === "break" || record.type === "continue" ? this.next = record.arg : record.type === "return" ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : record.type === "normal" && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc)
            return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName,
          nextLoc
        }, this.method === "next" && (this.arg = void 0), ContinueSentinel;
      }
    }, exports3;
  }
  function asyncGeneratorStep(gen2, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen2[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen2 = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen2, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen2, resolve, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  function _extends() {
    _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p2) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p3) {
      o2.__proto__ = p3;
      return o2;
    };
    return _setPrototypeOf(o, p2);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct2(Parent2, args2, Class2) {
        var a = [null];
        a.push.apply(a, args2);
        var Constructor = Function.bind.apply(Parent2, a);
        var instance = new Constructor();
        if (Class2)
          _setPrototypeOf(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
    _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
      if (Class2 === null || !_isNativeFunction(Class2))
        return Class2;
      if (typeof Class2 !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class2))
          return _cache.get(Class2);
        _cache.set(Class2, Wrapper);
      }
      function Wrapper() {
        return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper.prototype = Object.create(Class2.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class2);
    };
    return _wrapNativeSuper(Class);
  }
  var formatRegExp = /%[sdj%]/g;
  var warning = function warning2() {
  };
  if (typeof process !== "undefined" && process.env && false) {
    warning = function warning2(type2, errors) {
      if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
        if (errors.every(function(e2) {
          return typeof e2 === "string";
        })) {
          console.warn(type2, errors);
        }
      }
    };
  }
  function convertFieldsError(errors) {
    if (!errors || !errors.length)
      return null;
    var fields = {};
    errors.forEach(function(error) {
      var field = error.field;
      fields[field] = fields[field] || [];
      fields[field].push(error);
    });
    return fields;
  }
  function format(template) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var i = 0;
    var len = args.length;
    if (typeof template === "function") {
      return template.apply(null, args);
    }
    if (typeof template === "string") {
      var str = template.replace(formatRegExp, function(x2) {
        if (x2 === "%%") {
          return "%";
        }
        if (i >= len) {
          return x2;
        }
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
            break;
          default:
            return x2;
        }
      });
      return str;
    }
    return template;
  }
  function isNativeStringType(type2) {
    return type2 === "string" || type2 === "url" || type2 === "hex" || type2 === "email" || type2 === "date" || type2 === "pattern";
  }
  function isEmptyValue(value, type2) {
    if (value === void 0 || value === null) {
      return true;
    }
    if (type2 === "array" && Array.isArray(value) && !value.length) {
      return true;
    }
    if (isNativeStringType(type2) && typeof value === "string" && !value) {
      return true;
    }
    return false;
  }
  function asyncParallelArray(arr, func, callback) {
    var results = [];
    var total = 0;
    var arrLength = arr.length;
    function count(errors) {
      results.push.apply(results, errors || []);
      total++;
      if (total === arrLength) {
        callback(results);
      }
    }
    arr.forEach(function(a) {
      func(a, count);
    });
  }
  function asyncSerialArray(arr, func, callback) {
    var index2 = 0;
    var arrLength = arr.length;
    function next(errors) {
      if (errors && errors.length) {
        callback(errors);
        return;
      }
      var original = index2;
      index2 = index2 + 1;
      if (original < arrLength) {
        func(arr[original], next);
      } else {
        callback([]);
      }
    }
    next([]);
  }
  function flattenObjArr(objArr) {
    var ret = [];
    Object.keys(objArr).forEach(function(k2) {
      ret.push.apply(ret, objArr[k2] || []);
    });
    return ret;
  }
  var AsyncValidationError = /* @__PURE__ */ function(_Error) {
    _inheritsLoose(AsyncValidationError2, _Error);
    function AsyncValidationError2(errors, fields) {
      var _this;
      _this = _Error.call(this, "Async Validation Error") || this;
      _this.errors = errors;
      _this.fields = fields;
      return _this;
    }
    return AsyncValidationError2;
  }(/* @__PURE__ */ _wrapNativeSuper(Error));
  function asyncMap(objArr, option, func, callback, source) {
    if (option.first) {
      var _pending = new Promise(function(resolve, reject) {
        var next = function next2(errors) {
          callback(errors);
          return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
        };
        var flattenArr = flattenObjArr(objArr);
        asyncSerialArray(flattenArr, func, next);
      });
      _pending["catch"](function(e2) {
        return e2;
      });
      return _pending;
    }
    var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
    var objArrKeys = Object.keys(objArr);
    var objArrLength = objArrKeys.length;
    var total = 0;
    var results = [];
    var pending = new Promise(function(resolve, reject) {
      var next = function next2(errors) {
        results.push.apply(results, errors);
        total++;
        if (total === objArrLength) {
          callback(results);
          return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
        }
      };
      if (!objArrKeys.length) {
        callback(results);
        resolve(source);
      }
      objArrKeys.forEach(function(key) {
        var arr = objArr[key];
        if (firstFields.indexOf(key) !== -1) {
          asyncSerialArray(arr, func, next);
        } else {
          asyncParallelArray(arr, func, next);
        }
      });
    });
    pending["catch"](function(e2) {
      return e2;
    });
    return pending;
  }
  function isErrorObj(obj) {
    return !!(obj && obj.message !== void 0);
  }
  function getValue$1(value, path) {
    var v2 = value;
    for (var i = 0; i < path.length; i++) {
      if (v2 == void 0) {
        return v2;
      }
      v2 = v2[path[i]];
    }
    return v2;
  }
  function complementError(rule, source) {
    return function(oe) {
      var fieldValue;
      if (rule.fullFields) {
        fieldValue = getValue$1(source, rule.fullFields);
      } else {
        fieldValue = source[oe.field || rule.fullField];
      }
      if (isErrorObj(oe)) {
        oe.field = oe.field || rule.fullField;
        oe.fieldValue = fieldValue;
        return oe;
      }
      return {
        message: typeof oe === "function" ? oe() : oe,
        fieldValue,
        field: oe.field || rule.fullField
      };
    };
  }
  function deepMerge(target, source) {
    if (source) {
      for (var s in source) {
        if (source.hasOwnProperty(s)) {
          var value = source[s];
          if (typeof value === "object" && typeof target[s] === "object") {
            target[s] = _extends({}, target[s], value);
          } else {
            target[s] = value;
          }
        }
      }
    }
    return target;
  }
  var required$1 = function required2(rule, value, source, errors, options, type2) {
    if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type2 || rule.type))) {
      errors.push(format(options.messages.required, rule.fullField));
    }
  };
  var whitespace = function whitespace2(rule, value, source, errors, options) {
    if (/^\s+$/.test(value) || value === "") {
      errors.push(format(options.messages.whitespace, rule.fullField));
    }
  };
  var pattern$2 = {
    email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
    url: new RegExp("^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$", "i"),
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
  };
  var types = {
    integer: function integer2(value) {
      return types.number(value) && parseInt(value, 10) === value;
    },
    "float": function float(value) {
      return types.number(value) && !types.integer(value);
    },
    array: function array2(value) {
      return Array.isArray(value);
    },
    regexp: function regexp2(value) {
      if (value instanceof RegExp) {
        return true;
      }
      try {
        return !!new RegExp(value);
      } catch (e2) {
        return false;
      }
    },
    date: function date2(value) {
      return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
    },
    number: function number2(value) {
      if (isNaN(value)) {
        return false;
      }
      return typeof value === "number";
    },
    object: function object2(value) {
      return typeof value === "object" && !types.array(value);
    },
    method: function method2(value) {
      return typeof value === "function";
    },
    email: function email(value) {
      return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
    },
    url: function url(value) {
      return typeof value === "string" && value.length <= 2048 && !!value.match(pattern$2.url);
    },
    hex: function hex(value) {
      return typeof value === "string" && !!value.match(pattern$2.hex);
    }
  };
  var type$1 = function type2(rule, value, source, errors, options) {
    if (rule.required && value === void 0) {
      required$1(rule, value, source, errors, options);
      return;
    }
    var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
    var ruleType = rule.type;
    if (custom.indexOf(ruleType) > -1) {
      if (!types[ruleType](value)) {
        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
      }
    } else if (ruleType && typeof value !== rule.type) {
      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  };
  var range = function range2(rule, value, source, errors, options) {
    var len = typeof rule.len === "number";
    var min = typeof rule.min === "number";
    var max = typeof rule.max === "number";
    var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var val = value;
    var key = null;
    var num = typeof value === "number";
    var str = typeof value === "string";
    var arr = Array.isArray(value);
    if (num) {
      key = "number";
    } else if (str) {
      key = "string";
    } else if (arr) {
      key = "array";
    }
    if (!key) {
      return false;
    }
    if (arr) {
      val = value.length;
    }
    if (str) {
      val = value.replace(spRegexp, "_").length;
    }
    if (len) {
      if (val !== rule.len) {
        errors.push(format(options.messages[key].len, rule.fullField, rule.len));
      }
    } else if (min && !max && val < rule.min) {
      errors.push(format(options.messages[key].min, rule.fullField, rule.min));
    } else if (max && !min && val > rule.max) {
      errors.push(format(options.messages[key].max, rule.fullField, rule.max));
    } else if (min && max && (val < rule.min || val > rule.max)) {
      errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
    }
  };
  var ENUM$1 = "enum";
  var enumerable$1 = function enumerable2(rule, value, source, errors, options) {
    rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
    if (rule[ENUM$1].indexOf(value) === -1) {
      errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
    }
  };
  var pattern$1 = function pattern2(rule, value, source, errors, options) {
    if (rule.pattern) {
      if (rule.pattern instanceof RegExp) {
        rule.pattern.lastIndex = 0;
        if (!rule.pattern.test(value)) {
          errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      } else if (typeof rule.pattern === "string") {
        var _pattern = new RegExp(rule.pattern);
        if (!_pattern.test(value)) {
          errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      }
    }
  };
  var rules = {
    required: required$1,
    whitespace,
    type: type$1,
    range,
    "enum": enumerable$1,
    pattern: pattern$1
  };
  var string = function string2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "string") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, "string");
      if (!isEmptyValue(value, "string")) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
        rules.pattern(rule, value, source, errors, options);
        if (rule.whitespace === true) {
          rules.whitespace(rule, value, source, errors, options);
        }
      }
    }
    callback(errors);
  };
  var method = function method2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var number = function number2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (value === "") {
        value = void 0;
      }
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var _boolean = function _boolean2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var regexp = function regexp2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var integer = function integer2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var floatFn = function floatFn2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var array = function array2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if ((value === void 0 || value === null) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, "array");
      if (value !== void 0 && value !== null) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var object = function object2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var ENUM = "enum";
  var enumerable = function enumerable2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules[ENUM](rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var pattern = function pattern2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "string") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value, "string")) {
        rules.pattern(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var date = function date2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "date") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value, "date")) {
        var dateObject;
        if (value instanceof Date) {
          dateObject = value;
        } else {
          dateObject = new Date(value);
        }
        rules.type(rule, dateObject, source, errors, options);
        if (dateObject) {
          rules.range(rule, dateObject.getTime(), source, errors, options);
        }
      }
    }
    callback(errors);
  };
  var required = function required2(rule, value, callback, source, options) {
    var errors = [];
    var type2 = Array.isArray(value) ? "array" : typeof value;
    rules.required(rule, value, source, errors, options, type2);
    callback(errors);
  };
  var type = function type2(rule, value, callback, source, options) {
    var ruleType = rule.type;
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, ruleType) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, ruleType);
      if (!isEmptyValue(value, ruleType)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var any = function any2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
    }
    callback(errors);
  };
  var validators = {
    string,
    method,
    number,
    "boolean": _boolean,
    regexp,
    integer,
    "float": floatFn,
    array,
    object,
    "enum": enumerable,
    pattern,
    date,
    url: type,
    hex: type,
    email: type,
    required,
    any
  };
  function newMessages() {
    return {
      "default": "Validation error on field %s",
      required: "%s is required",
      "enum": "%s must be one of %s",
      whitespace: "%s cannot be empty",
      date: {
        format: "%s date %s is invalid for format %s",
        parse: "%s date could not be parsed, %s is invalid ",
        invalid: "%s date %s is invalid"
      },
      types: {
        string: "%s is not a %s",
        method: "%s is not a %s (function)",
        array: "%s is not an %s",
        object: "%s is not an %s",
        number: "%s is not a %s",
        date: "%s is not a %s",
        "boolean": "%s is not a %s",
        integer: "%s is not an %s",
        "float": "%s is not a %s",
        regexp: "%s is not a valid %s",
        email: "%s is not a valid %s",
        url: "%s is not a valid %s",
        hex: "%s is not a valid %s"
      },
      string: {
        len: "%s must be exactly %s characters",
        min: "%s must be at least %s characters",
        max: "%s cannot be longer than %s characters",
        range: "%s must be between %s and %s characters"
      },
      number: {
        len: "%s must equal %s",
        min: "%s cannot be less than %s",
        max: "%s cannot be greater than %s",
        range: "%s must be between %s and %s"
      },
      array: {
        len: "%s must be exactly %s in length",
        min: "%s cannot be less than %s in length",
        max: "%s cannot be greater than %s in length",
        range: "%s must be between %s and %s in length"
      },
      pattern: {
        mismatch: "%s value %s does not match pattern %s"
      },
      clone: function clone() {
        var cloned = JSON.parse(JSON.stringify(this));
        cloned.clone = this.clone;
        return cloned;
      }
    };
  }
  var messages = newMessages();
  var Schema = /* @__PURE__ */ function() {
    function Schema2(descriptor) {
      this.rules = null;
      this._messages = messages;
      this.define(descriptor);
    }
    var _proto = Schema2.prototype;
    _proto.define = function define2(rules2) {
      var _this = this;
      if (!rules2) {
        throw new Error("Cannot configure a schema with no rules");
      }
      if (typeof rules2 !== "object" || Array.isArray(rules2)) {
        throw new Error("Rules must be an object");
      }
      this.rules = {};
      Object.keys(rules2).forEach(function(name) {
        var item = rules2[name];
        _this.rules[name] = Array.isArray(item) ? item : [item];
      });
    };
    _proto.messages = function messages2(_messages) {
      if (_messages) {
        this._messages = deepMerge(newMessages(), _messages);
      }
      return this._messages;
    };
    _proto.validate = function validate(source_, o, oc) {
      var _this2 = this;
      if (o === void 0) {
        o = {};
      }
      if (oc === void 0) {
        oc = function oc2() {
        };
      }
      var source = source_;
      var options = o;
      var callback = oc;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (!this.rules || Object.keys(this.rules).length === 0) {
        if (callback) {
          callback(null, source);
        }
        return Promise.resolve(source);
      }
      function complete(results) {
        var errors = [];
        var fields = {};
        function add2(e2) {
          if (Array.isArray(e2)) {
            var _errors;
            errors = (_errors = errors).concat.apply(_errors, e2);
          } else {
            errors.push(e2);
          }
        }
        for (var i = 0; i < results.length; i++) {
          add2(results[i]);
        }
        if (!errors.length) {
          callback(null, source);
        } else {
          fields = convertFieldsError(errors);
          callback(errors, fields);
        }
      }
      if (options.messages) {
        var messages$1 = this.messages();
        if (messages$1 === messages) {
          messages$1 = newMessages();
        }
        deepMerge(messages$1, options.messages);
        options.messages = messages$1;
      } else {
        options.messages = this.messages();
      }
      var series = {};
      var keys = options.keys || Object.keys(this.rules);
      keys.forEach(function(z2) {
        var arr = _this2.rules[z2];
        var value = source[z2];
        arr.forEach(function(r2) {
          var rule = r2;
          if (typeof rule.transform === "function") {
            if (source === source_) {
              source = _extends({}, source);
            }
            value = source[z2] = rule.transform(value);
          }
          if (typeof rule === "function") {
            rule = {
              validator: rule
            };
          } else {
            rule = _extends({}, rule);
          }
          rule.validator = _this2.getValidationMethod(rule);
          if (!rule.validator) {
            return;
          }
          rule.field = z2;
          rule.fullField = rule.fullField || z2;
          rule.type = _this2.getType(rule);
          series[z2] = series[z2] || [];
          series[z2].push({
            rule,
            value,
            source,
            field: z2
          });
        });
      });
      var errorFields = {};
      return asyncMap(series, options, function(data, doIt) {
        var rule = data.rule;
        var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
        deep = deep && (rule.required || !rule.required && data.value);
        rule.field = data.field;
        function addFullField(key, schema) {
          return _extends({}, schema, {
            fullField: rule.fullField + "." + key,
            fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
          });
        }
        function cb(e2) {
          if (e2 === void 0) {
            e2 = [];
          }
          var errorList = Array.isArray(e2) ? e2 : [e2];
          if (!options.suppressWarning && errorList.length) {
            Schema2.warning("async-validator:", errorList);
          }
          if (errorList.length && rule.message !== void 0) {
            errorList = [].concat(rule.message);
          }
          var filledErrors = errorList.map(complementError(rule, source));
          if (options.first && filledErrors.length) {
            errorFields[rule.field] = 1;
            return doIt(filledErrors);
          }
          if (!deep) {
            doIt(filledErrors);
          } else {
            if (rule.required && !data.value) {
              if (rule.message !== void 0) {
                filledErrors = [].concat(rule.message).map(complementError(rule, source));
              } else if (options.error) {
                filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
              }
              return doIt(filledErrors);
            }
            var fieldsSchema = {};
            if (rule.defaultField) {
              Object.keys(data.value).map(function(key) {
                fieldsSchema[key] = rule.defaultField;
              });
            }
            fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
            var paredFieldsSchema = {};
            Object.keys(fieldsSchema).forEach(function(field) {
              var fieldSchema = fieldsSchema[field];
              var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
              paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
            });
            var schema = new Schema2(paredFieldsSchema);
            schema.messages(options.messages);
            if (data.rule.options) {
              data.rule.options.messages = options.messages;
              data.rule.options.error = options.error;
            }
            schema.validate(data.value, data.rule.options || options, function(errs) {
              var finalErrors = [];
              if (filledErrors && filledErrors.length) {
                finalErrors.push.apply(finalErrors, filledErrors);
              }
              if (errs && errs.length) {
                finalErrors.push.apply(finalErrors, errs);
              }
              doIt(finalErrors.length ? finalErrors : null);
            });
          }
        }
        var res;
        if (rule.asyncValidator) {
          res = rule.asyncValidator(rule, data.value, cb, data.source, options);
        } else if (rule.validator) {
          try {
            res = rule.validator(rule, data.value, cb, data.source, options);
          } catch (error) {
            console.error == null ? void 0 : console.error(error);
            setTimeout(function() {
              throw error;
            }, 0);
            cb(error.message);
          }
          if (res === true) {
            cb();
          } else if (res === false) {
            cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
          } else if (res instanceof Array) {
            cb(res);
          } else if (res instanceof Error) {
            cb(res.message);
          }
        }
        if (res && res.then) {
          res.then(function() {
            return cb();
          }, function(e2) {
            return cb(e2);
          });
        }
      }, function(results) {
        complete(results);
      }, source);
    };
    _proto.getType = function getType(rule) {
      if (rule.type === void 0 && rule.pattern instanceof RegExp) {
        rule.type = "pattern";
      }
      if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
        throw new Error(format("Unknown rule type %s", rule.type));
      }
      return rule.type || "string";
    };
    _proto.getValidationMethod = function getValidationMethod(rule) {
      if (typeof rule.validator === "function") {
        return rule.validator;
      }
      var keys = Object.keys(rule);
      var messageIndex = keys.indexOf("message");
      if (messageIndex !== -1) {
        keys.splice(messageIndex, 1);
      }
      if (keys.length === 1 && keys[0] === "required") {
        return validators.required;
      }
      return validators[this.getType(rule)] || void 0;
    };
    return Schema2;
  }();
  Schema.register = function register(type2, validator) {
    if (typeof validator !== "function") {
      throw new Error("Cannot register a validator by type, validator is not a function");
    }
    validators[type2] = validator;
  };
  Schema.warning = warning;
  Schema.messages = messages;
  Schema.validators = validators;
  var typeTemplate = "'${name}' is not a valid ${type}";
  var defaultValidateMessages = {
    default: "Validation error on field '${name}'",
    required: "'${name}' is required",
    enum: "'${name}' must be one of [${enum}]",
    whitespace: "'${name}' cannot be empty",
    date: {
      format: "'${name}' is invalid for format date",
      parse: "'${name}' could not be parsed as date",
      invalid: "'${name}' is invalid date"
    },
    types: {
      string: typeTemplate,
      method: typeTemplate,
      array: typeTemplate,
      object: typeTemplate,
      number: typeTemplate,
      date: typeTemplate,
      boolean: typeTemplate,
      integer: typeTemplate,
      float: typeTemplate,
      regexp: typeTemplate,
      email: typeTemplate,
      url: typeTemplate,
      hex: typeTemplate
    },
    string: {
      len: "'${name}' must be exactly ${len} characters",
      min: "'${name}' must be at least ${min} characters",
      max: "'${name}' cannot be longer than ${max} characters",
      range: "'${name}' must be between ${min} and ${max} characters"
    },
    number: {
      len: "'${name}' must equal ${len}",
      min: "'${name}' cannot be less than ${min}",
      max: "'${name}' cannot be greater than ${max}",
      range: "'${name}' must be between ${min} and ${max}"
    },
    array: {
      len: "'${name}' must be exactly ${len} in length",
      min: "'${name}' cannot be less than ${min} in length",
      max: "'${name}' cannot be greater than ${max} in length",
      range: "'${name}' must be between ${min} and ${max} in length"
    },
    pattern: {
      mismatch: "'${name}' does not match pattern ${pattern}"
    }
  };
  function get(entity, path) {
    var current = entity;
    for (var i = 0; i < path.length; i += 1) {
      if (current === null || current === void 0) {
        return void 0;
      }
      current = current[path[i]];
    }
    return current;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toArray(arr) {
    return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
  }
  function internalSet(entity, paths, value, removeIfUndefined) {
    if (!paths.length) {
      return value;
    }
    var _paths = _toArray(paths), path = _paths[0], restPath = _paths.slice(1);
    var clone;
    if (!entity && typeof path === "number") {
      clone = [];
    } else if (Array.isArray(entity)) {
      clone = _toConsumableArray(entity);
    } else {
      clone = _objectSpread2({}, entity);
    }
    if (removeIfUndefined && value === void 0 && restPath.length === 1) {
      delete clone[path][restPath[0]];
    } else {
      clone[path] = internalSet(clone[path], restPath, value, removeIfUndefined);
    }
    return clone;
  }
  function set(entity, paths, value) {
    var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (paths.length && removeIfUndefined && value === void 0 && !get(entity, paths.slice(0, -1))) {
      return entity;
    }
    return internalSet(entity, paths, value, removeIfUndefined);
  }
  function cloneDeep(val) {
    if (Array.isArray(val)) {
      return cloneArrayDeep(val);
    } else if (_typeof(val) === "object" && val !== null) {
      return cloneObjectDeep(val);
    }
    return val;
  }
  function cloneObjectDeep(val) {
    if (Object.getPrototypeOf(val) === Object.prototype) {
      var res = {};
      for (var key in val) {
        res[key] = cloneDeep(val[key]);
      }
      return res;
    }
    return val;
  }
  function cloneArrayDeep(val) {
    return val.map(function(item) {
      return cloneDeep(item);
    });
  }
  function getNamePath(path) {
    return toArray(path);
  }
  function getValue(store, namePath) {
    var value = get(store, namePath);
    return value;
  }
  function setValue(store, namePath, value) {
    var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    var newStore = set(store, namePath, value, removeIfUndefined);
    return newStore;
  }
  function cloneByNamePathList(store, namePathList) {
    var newStore = {};
    namePathList.forEach(function(namePath) {
      var value = getValue(store, namePath);
      newStore = setValue(newStore, namePath, value);
    });
    return newStore;
  }
  function containsNamePath(namePathList, namePath) {
    return namePathList && namePathList.some(function(path) {
      return matchNamePath(path, namePath);
    });
  }
  function isObject(obj) {
    return _typeof(obj) === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
  }
  function internalSetValues(store, values) {
    var newStore = Array.isArray(store) ? _toConsumableArray(store) : _objectSpread2({}, store);
    if (!values) {
      return newStore;
    }
    Object.keys(values).forEach(function(key) {
      var prevValue = newStore[key];
      var value = values[key];
      var recursive = isObject(prevValue) && isObject(value);
      newStore[key] = recursive ? internalSetValues(prevValue, value || {}) : cloneDeep(value);
    });
    return newStore;
  }
  function setValues(store) {
    for (var _len = arguments.length, restValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      restValues[_key - 1] = arguments[_key];
    }
    return restValues.reduce(function(current, newStore) {
      return internalSetValues(current, newStore);
    }, store);
  }
  function matchNamePath(namePath, changedNamePath) {
    if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {
      return false;
    }
    return namePath.every(function(nameUnit, i) {
      return changedNamePath[i] === nameUnit;
    });
  }
  function isSimilar(source, target) {
    if (source === target) {
      return true;
    }
    if (!source && target || source && !target) {
      return false;
    }
    if (!source || !target || _typeof(source) !== "object" || _typeof(target) !== "object") {
      return false;
    }
    var sourceKeys = Object.keys(source);
    var targetKeys = Object.keys(target);
    var keys = new Set([].concat(_toConsumableArray(sourceKeys), _toConsumableArray(targetKeys)));
    return _toConsumableArray(keys).every(function(key) {
      var sourceValue = source[key];
      var targetValue = target[key];
      if (typeof sourceValue === "function" && typeof targetValue === "function") {
        return true;
      }
      return sourceValue === targetValue;
    });
  }
  function defaultGetValueFromEvent(valuePropName) {
    var event = arguments.length <= 1 ? void 0 : arguments[1];
    if (event && event.target && _typeof(event.target) === "object" && valuePropName in event.target) {
      return event.target[valuePropName];
    }
    return event;
  }
  function move(array2, moveIndex, toIndex) {
    var length = array2.length;
    if (moveIndex < 0 || moveIndex >= length || toIndex < 0 || toIndex >= length) {
      return array2;
    }
    var item = array2[moveIndex];
    var diff = moveIndex - toIndex;
    if (diff > 0) {
      return [].concat(_toConsumableArray(array2.slice(0, toIndex)), [item], _toConsumableArray(array2.slice(toIndex, moveIndex)), _toConsumableArray(array2.slice(moveIndex + 1, length)));
    }
    if (diff < 0) {
      return [].concat(_toConsumableArray(array2.slice(0, moveIndex)), _toConsumableArray(array2.slice(moveIndex + 1, toIndex + 1)), [item], _toConsumableArray(array2.slice(toIndex + 1, length)));
    }
    return array2;
  }
  var AsyncValidator = Schema;
  function replaceMessage(template, kv) {
    return template.replace(/\$\{\w+\}/g, function(str) {
      var key = str.slice(2, -1);
      return kv[key];
    });
  }
  var CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
  function validateRule(_x, _x2, _x3, _x4, _x5) {
    return _validateRule.apply(this, arguments);
  }
  function _validateRule() {
    _validateRule = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(name, value, rule, options, messageVariables) {
      var cloneRule, originValidator, subRuleField, validator, messages2, result, subResults, kv, fillVariableResult;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              cloneRule = _objectSpread2({}, rule);
              delete cloneRule.ruleIndex;
              if (cloneRule.validator) {
                originValidator = cloneRule.validator;
                cloneRule.validator = function() {
                  try {
                    return originValidator.apply(void 0, arguments);
                  } catch (error) {
                    console.error(error);
                    return Promise.reject(CODE_LOGIC_ERROR);
                  }
                };
              }
              subRuleField = null;
              if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
                subRuleField = cloneRule.defaultField;
                delete cloneRule.defaultField;
              }
              validator = new AsyncValidator(_defineProperty({}, name, [cloneRule]));
              messages2 = setValues({}, defaultValidateMessages, options.validateMessages);
              validator.messages(messages2);
              result = [];
              _context2.prev = 9;
              _context2.next = 12;
              return Promise.resolve(validator.validate(_defineProperty({}, name, value), _objectSpread2({}, options)));
            case 12:
              _context2.next = 17;
              break;
            case 14:
              _context2.prev = 14;
              _context2.t0 = _context2["catch"](9);
              if (_context2.t0.errors) {
                result = _context2.t0.errors.map(function(_ref4, index2) {
                  var message = _ref4.message;
                  var mergedMessage = message === CODE_LOGIC_ERROR ? messages2.default : message;
                  return /* @__PURE__ */ React__namespace.isValidElement(mergedMessage) ? /* @__PURE__ */ React__namespace.cloneElement(mergedMessage, {
                    key: "error_".concat(index2)
                  }) : mergedMessage;
                });
              }
            case 17:
              if (!(!result.length && subRuleField)) {
                _context2.next = 22;
                break;
              }
              _context2.next = 20;
              return Promise.all(value.map(function(subValue, i) {
                return validateRule("".concat(name, ".").concat(i), subValue, subRuleField, options, messageVariables);
              }));
            case 20:
              subResults = _context2.sent;
              return _context2.abrupt("return", subResults.reduce(function(prev2, errors) {
                return [].concat(_toConsumableArray(prev2), _toConsumableArray(errors));
              }, []));
            case 22:
              kv = _objectSpread2(_objectSpread2({}, rule), {}, {
                name,
                enum: (rule.enum || []).join(", ")
              }, messageVariables);
              fillVariableResult = result.map(function(error) {
                if (typeof error === "string") {
                  return replaceMessage(error, kv);
                }
                return error;
              });
              return _context2.abrupt("return", fillVariableResult);
            case 25:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[9, 14]]);
    }));
    return _validateRule.apply(this, arguments);
  }
  function validateRules(namePath, value, rules2, options, validateFirst, messageVariables) {
    var name = namePath.join(".");
    var filledRules = rules2.map(function(currentRule, ruleIndex) {
      var originValidatorFunc = currentRule.validator;
      var cloneRule = _objectSpread2(_objectSpread2({}, currentRule), {}, {
        ruleIndex
      });
      if (originValidatorFunc) {
        cloneRule.validator = function(rule, val, callback) {
          var hasPromise = false;
          var wrappedCallback = function wrappedCallback2() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            Promise.resolve().then(function() {
              warningOnce(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored.");
              if (!hasPromise) {
                callback.apply(void 0, args);
              }
            });
          };
          var promise = originValidatorFunc(rule, val, wrappedCallback);
          hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
          warningOnce(hasPromise, "`callback` is deprecated. Please return a promise instead.");
          if (hasPromise) {
            promise.then(function() {
              callback();
            }).catch(function(err) {
              callback(err || " ");
            });
          }
        };
      }
      return cloneRule;
    }).sort(function(_ref, _ref2) {
      var w1 = _ref.warningOnly, i1 = _ref.ruleIndex;
      var w2 = _ref2.warningOnly, i2 = _ref2.ruleIndex;
      if (!!w1 === !!w2) {
        return i1 - i2;
      }
      if (w1) {
        return 1;
      }
      return -1;
    });
    var summaryPromise;
    if (validateFirst === true) {
      summaryPromise = new Promise(/* @__PURE__ */ function() {
        var _ref3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(resolve, reject) {
          var i, rule, errors;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  i = 0;
                case 1:
                  if (!(i < filledRules.length)) {
                    _context.next = 12;
                    break;
                  }
                  rule = filledRules[i];
                  _context.next = 5;
                  return validateRule(name, value, rule, options, messageVariables);
                case 5:
                  errors = _context.sent;
                  if (!errors.length) {
                    _context.next = 9;
                    break;
                  }
                  reject([{
                    errors,
                    rule
                  }]);
                  return _context.abrupt("return");
                case 9:
                  i += 1;
                  _context.next = 1;
                  break;
                case 12:
                  resolve([]);
                case 13:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        return function(_x6, _x7) {
          return _ref3.apply(this, arguments);
        };
      }());
    } else {
      var rulePromises = filledRules.map(function(rule) {
        return validateRule(name, value, rule, options, messageVariables).then(function(errors) {
          return {
            errors,
            rule
          };
        });
      });
      summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function(errors) {
        return Promise.reject(errors);
      });
    }
    summaryPromise.catch(function(e2) {
      return e2;
    });
    return summaryPromise;
  }
  function finishOnAllFailed(_x8) {
    return _finishOnAllFailed.apply(this, arguments);
  }
  function _finishOnAllFailed() {
    _finishOnAllFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(rulePromises) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", Promise.all(rulePromises).then(function(errorsList) {
                var _ref5;
                var errors = (_ref5 = []).concat.apply(_ref5, _toConsumableArray(errorsList));
                return errors;
              }));
            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _finishOnAllFailed.apply(this, arguments);
  }
  function finishOnFirstFailed(_x9) {
    return _finishOnFirstFailed.apply(this, arguments);
  }
  function _finishOnFirstFailed() {
    _finishOnFirstFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(rulePromises) {
      var count;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              count = 0;
              return _context4.abrupt("return", new Promise(function(resolve) {
                rulePromises.forEach(function(promise) {
                  promise.then(function(ruleError) {
                    if (ruleError.errors.length) {
                      resolve([ruleError]);
                    }
                    count += 1;
                    if (count === rulePromises.length) {
                      resolve([]);
                    }
                  });
                });
              }));
            case 2:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _finishOnFirstFailed.apply(this, arguments);
  }
  var _excluded$2 = ["name"];
  var EMPTY_ERRORS = [];
  function requireUpdate(shouldUpdate, prev2, next, prevValue, nextValue, info) {
    if (typeof shouldUpdate === "function") {
      return shouldUpdate(prev2, next, "source" in info ? {
        source: info.source
      } : {});
    }
    return prevValue !== nextValue;
  }
  var Field = /* @__PURE__ */ function(_React$Component) {
    _inherits(Field2, _React$Component);
    var _super = _createSuper(Field2);
    function Field2(props) {
      var _this;
      _classCallCheck(this, Field2);
      _this = _super.call(this, props);
      _this.state = {
        resetCount: 0
      };
      _this.cancelRegisterFunc = null;
      _this.mounted = false;
      _this.touched = false;
      _this.dirty = false;
      _this.validatePromise = null;
      _this.prevValidating = void 0;
      _this.errors = EMPTY_ERRORS;
      _this.warnings = EMPTY_ERRORS;
      _this.cancelRegister = function() {
        var _this$props = _this.props, preserve = _this$props.preserve, isListField = _this$props.isListField, name = _this$props.name;
        if (_this.cancelRegisterFunc) {
          _this.cancelRegisterFunc(isListField, preserve, getNamePath(name));
        }
        _this.cancelRegisterFunc = null;
      };
      _this.getNamePath = function() {
        var _this$props2 = _this.props, name = _this$props2.name, fieldContext = _this$props2.fieldContext;
        var _fieldContext$prefixN = fieldContext.prefixName, prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;
        return name !== void 0 ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name)) : [];
      };
      _this.getRules = function() {
        var _this$props3 = _this.props, _this$props3$rules = _this$props3.rules, rules2 = _this$props3$rules === void 0 ? [] : _this$props3$rules, fieldContext = _this$props3.fieldContext;
        return rules2.map(function(rule) {
          if (typeof rule === "function") {
            return rule(fieldContext);
          }
          return rule;
        });
      };
      _this.refresh = function() {
        if (!_this.mounted)
          return;
        _this.setState(function(_ref) {
          var resetCount = _ref.resetCount;
          return {
            resetCount: resetCount + 1
          };
        });
      };
      _this.triggerMetaEvent = function(destroy) {
        var onMetaChange = _this.props.onMetaChange;
        onMetaChange === null || onMetaChange === void 0 ? void 0 : onMetaChange(_objectSpread2(_objectSpread2({}, _this.getMeta()), {}, {
          destroy
        }));
      };
      _this.onStoreChange = function(prevStore, namePathList, info) {
        var _this$props4 = _this.props, shouldUpdate = _this$props4.shouldUpdate, _this$props4$dependen = _this$props4.dependencies, dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen, onReset = _this$props4.onReset;
        var store = info.store;
        var namePath = _this.getNamePath();
        var prevValue = _this.getValue(prevStore);
        var curValue = _this.getValue(store);
        var namePathMatch = namePathList && containsNamePath(namePathList, namePath);
        if (info.type === "valueUpdate" && info.source === "external" && prevValue !== curValue) {
          _this.touched = true;
          _this.dirty = true;
          _this.validatePromise = null;
          _this.errors = EMPTY_ERRORS;
          _this.warnings = EMPTY_ERRORS;
          _this.triggerMetaEvent();
        }
        switch (info.type) {
          case "reset":
            if (!namePathList || namePathMatch) {
              _this.touched = false;
              _this.dirty = false;
              _this.validatePromise = null;
              _this.errors = EMPTY_ERRORS;
              _this.warnings = EMPTY_ERRORS;
              _this.triggerMetaEvent();
              onReset === null || onReset === void 0 ? void 0 : onReset();
              _this.refresh();
              return;
            }
            break;
          case "remove": {
            if (shouldUpdate) {
              _this.reRender();
              return;
            }
            break;
          }
          case "setField": {
            if (namePathMatch) {
              var data = info.data;
              if ("touched" in data) {
                _this.touched = data.touched;
              }
              if ("validating" in data && !("originRCField" in data)) {
                _this.validatePromise = data.validating ? Promise.resolve([]) : null;
              }
              if ("errors" in data) {
                _this.errors = data.errors || EMPTY_ERRORS;
              }
              if ("warnings" in data) {
                _this.warnings = data.warnings || EMPTY_ERRORS;
              }
              _this.dirty = true;
              _this.triggerMetaEvent();
              _this.reRender();
              return;
            }
            if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
              _this.reRender();
              return;
            }
            break;
          }
          case "dependenciesUpdate": {
            var dependencyList = dependencies.map(getNamePath);
            if (dependencyList.some(function(dependency) {
              return containsNamePath(info.relatedFields, dependency);
            })) {
              _this.reRender();
              return;
            }
            break;
          }
          default:
            if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
              _this.reRender();
              return;
            }
            break;
        }
        if (shouldUpdate === true) {
          _this.reRender();
        }
      };
      _this.validateRules = function(options) {
        var namePath = _this.getNamePath();
        var currentValue = _this.getValue();
        var rootPromise = Promise.resolve().then(function() {
          if (!_this.mounted) {
            return [];
          }
          var _this$props5 = _this.props, _this$props5$validate = _this$props5.validateFirst, validateFirst = _this$props5$validate === void 0 ? false : _this$props5$validate, messageVariables = _this$props5.messageVariables;
          var _ref2 = options || {}, triggerName = _ref2.triggerName;
          var filteredRules = _this.getRules();
          if (triggerName) {
            filteredRules = filteredRules.filter(function(rule) {
              var validateTrigger = rule.validateTrigger;
              if (!validateTrigger) {
                return true;
              }
              var triggerList = toArray(validateTrigger);
              return triggerList.includes(triggerName);
            });
          }
          var promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);
          promise.catch(function(e2) {
            return e2;
          }).then(function() {
            var ruleErrors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : EMPTY_ERRORS;
            if (_this.validatePromise === rootPromise) {
              _this.validatePromise = null;
              var nextErrors = [];
              var nextWarnings = [];
              ruleErrors.forEach(function(_ref3) {
                var warningOnly = _ref3.rule.warningOnly, _ref3$errors = _ref3.errors, errors = _ref3$errors === void 0 ? EMPTY_ERRORS : _ref3$errors;
                if (warningOnly) {
                  nextWarnings.push.apply(nextWarnings, _toConsumableArray(errors));
                } else {
                  nextErrors.push.apply(nextErrors, _toConsumableArray(errors));
                }
              });
              _this.errors = nextErrors;
              _this.warnings = nextWarnings;
              _this.triggerMetaEvent();
              _this.reRender();
            }
          });
          return promise;
        });
        _this.validatePromise = rootPromise;
        _this.dirty = true;
        _this.errors = EMPTY_ERRORS;
        _this.warnings = EMPTY_ERRORS;
        _this.triggerMetaEvent();
        _this.reRender();
        return rootPromise;
      };
      _this.isFieldValidating = function() {
        return !!_this.validatePromise;
      };
      _this.isFieldTouched = function() {
        return _this.touched;
      };
      _this.isFieldDirty = function() {
        if (_this.dirty || _this.props.initialValue !== void 0) {
          return true;
        }
        var fieldContext = _this.props.fieldContext;
        var _fieldContext$getInte = fieldContext.getInternalHooks(HOOK_MARK), getInitialValue = _fieldContext$getInte.getInitialValue;
        if (getInitialValue(_this.getNamePath()) !== void 0) {
          return true;
        }
        return false;
      };
      _this.getErrors = function() {
        return _this.errors;
      };
      _this.getWarnings = function() {
        return _this.warnings;
      };
      _this.isListField = function() {
        return _this.props.isListField;
      };
      _this.isList = function() {
        return _this.props.isList;
      };
      _this.isPreserve = function() {
        return _this.props.preserve;
      };
      _this.getMeta = function() {
        _this.prevValidating = _this.isFieldValidating();
        var meta = {
          touched: _this.isFieldTouched(),
          validating: _this.prevValidating,
          errors: _this.errors,
          warnings: _this.warnings,
          name: _this.getNamePath()
        };
        return meta;
      };
      _this.getOnlyChild = function(children) {
        if (typeof children === "function") {
          var meta = _this.getMeta();
          return _objectSpread2(_objectSpread2({}, _this.getOnlyChild(children(_this.getControlled(), meta, _this.props.fieldContext))), {}, {
            isFunction: true
          });
        }
        var childList = toArray$1(children);
        if (childList.length !== 1 || !/* @__PURE__ */ React__namespace.isValidElement(childList[0])) {
          return {
            child: childList,
            isFunction: false
          };
        }
        return {
          child: childList[0],
          isFunction: false
        };
      };
      _this.getValue = function(store) {
        var getFieldsValue = _this.props.fieldContext.getFieldsValue;
        var namePath = _this.getNamePath();
        return getValue(store || getFieldsValue(true), namePath);
      };
      _this.getControlled = function() {
        var childProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var _this$props6 = _this.props, trigger = _this$props6.trigger, validateTrigger = _this$props6.validateTrigger, getValueFromEvent = _this$props6.getValueFromEvent, normalize2 = _this$props6.normalize, valuePropName = _this$props6.valuePropName, getValueProps = _this$props6.getValueProps, fieldContext = _this$props6.fieldContext;
        var mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;
        var namePath = _this.getNamePath();
        var getInternalHooks2 = fieldContext.getInternalHooks, getFieldsValue = fieldContext.getFieldsValue;
        var _getInternalHooks = getInternalHooks2(HOOK_MARK), dispatch = _getInternalHooks.dispatch;
        var value = _this.getValue();
        var mergedGetValueProps = getValueProps || function(val) {
          return _defineProperty({}, valuePropName, val);
        };
        var originTriggerFunc = childProps[trigger];
        var control = _objectSpread2(_objectSpread2({}, childProps), mergedGetValueProps(value));
        control[trigger] = function() {
          _this.touched = true;
          _this.dirty = true;
          _this.triggerMetaEvent();
          var newValue;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (getValueFromEvent) {
            newValue = getValueFromEvent.apply(void 0, args);
          } else {
            newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args));
          }
          if (normalize2) {
            newValue = normalize2(newValue, value, getFieldsValue(true));
          }
          dispatch({
            type: "updateValue",
            namePath,
            value: newValue
          });
          if (originTriggerFunc) {
            originTriggerFunc.apply(void 0, args);
          }
        };
        var validateTriggerList = toArray(mergedValidateTrigger || []);
        validateTriggerList.forEach(function(triggerName) {
          var originTrigger = control[triggerName];
          control[triggerName] = function() {
            if (originTrigger) {
              originTrigger.apply(void 0, arguments);
            }
            var rules2 = _this.props.rules;
            if (rules2 && rules2.length) {
              dispatch({
                type: "validateField",
                namePath,
                triggerName
              });
            }
          };
        });
        return control;
      };
      if (props.fieldContext) {
        var getInternalHooks = props.fieldContext.getInternalHooks;
        var _getInternalHooks2 = getInternalHooks(HOOK_MARK), initEntityValue = _getInternalHooks2.initEntityValue;
        initEntityValue(_assertThisInitialized(_this));
      }
      return _this;
    }
    _createClass(Field2, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this$props7 = this.props, shouldUpdate = _this$props7.shouldUpdate, fieldContext = _this$props7.fieldContext;
        this.mounted = true;
        if (fieldContext) {
          var getInternalHooks = fieldContext.getInternalHooks;
          var _getInternalHooks3 = getInternalHooks(HOOK_MARK), registerField = _getInternalHooks3.registerField;
          this.cancelRegisterFunc = registerField(this);
        }
        if (shouldUpdate === true) {
          this.reRender();
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.cancelRegister();
        this.triggerMetaEvent(true);
        this.mounted = false;
      }
    }, {
      key: "reRender",
      value: function reRender() {
        if (!this.mounted)
          return;
        this.forceUpdate();
      }
    }, {
      key: "render",
      value: function render2() {
        var resetCount = this.state.resetCount;
        var children = this.props.children;
        var _this$getOnlyChild = this.getOnlyChild(children), child = _this$getOnlyChild.child, isFunction2 = _this$getOnlyChild.isFunction;
        var returnChildNode;
        if (isFunction2) {
          returnChildNode = child;
        } else if (/* @__PURE__ */ React__namespace.isValidElement(child)) {
          returnChildNode = /* @__PURE__ */ React__namespace.cloneElement(child, this.getControlled(child.props));
        } else {
          warningOnce(!child, "`children` of Field is not validate ReactElement.");
          returnChildNode = child;
        }
        return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, {
          key: resetCount
        }, returnChildNode);
      }
    }]);
    return Field2;
  }(React__namespace.Component);
  Field.contextType = Context;
  Field.defaultProps = {
    trigger: "onChange",
    valuePropName: "value"
  };
  function WrapperField(_ref5) {
    var name = _ref5.name, restProps = _objectWithoutProperties(_ref5, _excluded$2);
    var fieldContext = React__namespace.useContext(Context);
    var namePath = name !== void 0 ? getNamePath(name) : void 0;
    var key = "keep";
    if (!restProps.isListField) {
      key = "_".concat((namePath || []).join("_"));
    }
    return /* @__PURE__ */ React__namespace.createElement(Field, _extends$4({
      key,
      name: namePath
    }, restProps, {
      fieldContext
    }));
  }
  var ListContext = /* @__PURE__ */ React__namespace.createContext(null);
  var List = function List2(_ref) {
    var name = _ref.name, initialValue = _ref.initialValue, children = _ref.children, rules2 = _ref.rules, validateTrigger = _ref.validateTrigger;
    var context = React__namespace.useContext(Context);
    var keyRef = React__namespace.useRef({
      keys: [],
      id: 0
    });
    var keyManager = keyRef.current;
    var prefixName = React__namespace.useMemo(function() {
      var parentPrefixName = getNamePath(context.prefixName) || [];
      return [].concat(_toConsumableArray(parentPrefixName), _toConsumableArray(getNamePath(name)));
    }, [context.prefixName, name]);
    var fieldContext = React__namespace.useMemo(function() {
      return _objectSpread2(_objectSpread2({}, context), {}, {
        prefixName
      });
    }, [context, prefixName]);
    var listContext = React__namespace.useMemo(function() {
      return {
        getKey: function getKey(namePath) {
          var len = prefixName.length;
          var pathName = namePath[len];
          return [keyManager.keys[pathName], namePath.slice(len + 1)];
        }
      };
    }, [prefixName]);
    if (typeof children !== "function") {
      warningOnce(false, "Form.List only accepts function as children.");
      return null;
    }
    var shouldUpdate = function shouldUpdate2(prevValue, nextValue, _ref2) {
      var source = _ref2.source;
      if (source === "internal") {
        return false;
      }
      return prevValue !== nextValue;
    };
    return /* @__PURE__ */ React__namespace.createElement(ListContext.Provider, {
      value: listContext
    }, /* @__PURE__ */ React__namespace.createElement(Context.Provider, {
      value: fieldContext
    }, /* @__PURE__ */ React__namespace.createElement(WrapperField, {
      name: [],
      shouldUpdate,
      rules: rules2,
      validateTrigger,
      initialValue,
      isList: true
    }, function(_ref3, meta) {
      var _ref3$value = _ref3.value, value = _ref3$value === void 0 ? [] : _ref3$value, onChange = _ref3.onChange;
      var getFieldValue = context.getFieldValue;
      var getNewValue = function getNewValue2() {
        var values = getFieldValue(prefixName || []);
        return values || [];
      };
      var operations = {
        add: function add2(defaultValue, index2) {
          var newValue = getNewValue();
          if (index2 >= 0 && index2 <= newValue.length) {
            keyManager.keys = [].concat(_toConsumableArray(keyManager.keys.slice(0, index2)), [keyManager.id], _toConsumableArray(keyManager.keys.slice(index2)));
            onChange([].concat(_toConsumableArray(newValue.slice(0, index2)), [defaultValue], _toConsumableArray(newValue.slice(index2))));
          } else {
            keyManager.keys = [].concat(_toConsumableArray(keyManager.keys), [keyManager.id]);
            onChange([].concat(_toConsumableArray(newValue), [defaultValue]));
          }
          keyManager.id += 1;
        },
        remove: function remove(index2) {
          var newValue = getNewValue();
          var indexSet = new Set(Array.isArray(index2) ? index2 : [index2]);
          if (indexSet.size <= 0) {
            return;
          }
          keyManager.keys = keyManager.keys.filter(function(_, keysIndex) {
            return !indexSet.has(keysIndex);
          });
          onChange(newValue.filter(function(_, valueIndex) {
            return !indexSet.has(valueIndex);
          }));
        },
        move: function move$1(from, to2) {
          if (from === to2) {
            return;
          }
          var newValue = getNewValue();
          if (from < 0 || from >= newValue.length || to2 < 0 || to2 >= newValue.length) {
            return;
          }
          keyManager.keys = move(keyManager.keys, from, to2);
          onChange(move(newValue, from, to2));
        }
      };
      var listValue = value || [];
      if (!Array.isArray(listValue)) {
        listValue = [];
      }
      return children(listValue.map(function(__, index2) {
        var key = keyManager.keys[index2];
        if (key === void 0) {
          keyManager.keys[index2] = keyManager.id;
          key = keyManager.keys[index2];
          keyManager.id += 1;
        }
        return {
          name: index2,
          key,
          isListField: true
        };
      }), operations, meta);
    })));
  };
  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null)
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function allPromiseFinish(promiseList) {
    var hasError = false;
    var count = promiseList.length;
    var results = [];
    if (!promiseList.length) {
      return Promise.resolve([]);
    }
    return new Promise(function(resolve, reject) {
      promiseList.forEach(function(promise, index2) {
        promise.catch(function(e2) {
          hasError = true;
          return e2;
        }).then(function(result) {
          count -= 1;
          results[index2] = result;
          if (count > 0) {
            return;
          }
          if (hasError) {
            reject(results);
          }
          resolve(results);
        });
      });
    });
  }
  var SPLIT = "__@field_split__";
  function normalize(namePath) {
    return namePath.map(function(cell) {
      return "".concat(_typeof(cell), ":").concat(cell);
    }).join(SPLIT);
  }
  var NameMap = /* @__PURE__ */ function() {
    function NameMap2() {
      _classCallCheck(this, NameMap2);
      this.kvs = /* @__PURE__ */ new Map();
    }
    _createClass(NameMap2, [{
      key: "set",
      value: function set2(key, value) {
        this.kvs.set(normalize(key), value);
      }
    }, {
      key: "get",
      value: function get2(key) {
        return this.kvs.get(normalize(key));
      }
    }, {
      key: "update",
      value: function update2(key, updater) {
        var origin = this.get(key);
        var next = updater(origin);
        if (!next) {
          this.delete(key);
        } else {
          this.set(key, next);
        }
      }
    }, {
      key: "delete",
      value: function _delete(key) {
        this.kvs.delete(normalize(key));
      }
    }, {
      key: "map",
      value: function map(callback) {
        return _toConsumableArray(this.kvs.entries()).map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
          var cells = key.split(SPLIT);
          return callback({
            key: cells.map(function(cell) {
              var _cell$match = cell.match(/^([^:]*):(.*)$/), _cell$match2 = _slicedToArray(_cell$match, 3), type2 = _cell$match2[1], unit = _cell$match2[2];
              return type2 === "number" ? Number(unit) : unit;
            }),
            value
          });
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var json = {};
        this.map(function(_ref3) {
          var key = _ref3.key, value = _ref3.value;
          json[key.join(".")] = value;
          return null;
        });
        return json;
      }
    }]);
    return NameMap2;
  }();
  var _excluded$1 = ["name", "errors"];
  var FormStore = /* @__PURE__ */ _createClass(function FormStore2(forceRootUpdate) {
    var _this = this;
    _classCallCheck(this, FormStore2);
    this.formHooked = false;
    this.forceRootUpdate = void 0;
    this.subscribable = true;
    this.store = {};
    this.fieldEntities = [];
    this.initialValues = {};
    this.callbacks = {};
    this.validateMessages = null;
    this.preserve = null;
    this.lastValidatePromise = null;
    this.getForm = function() {
      return {
        getFieldValue: _this.getFieldValue,
        getFieldsValue: _this.getFieldsValue,
        getFieldError: _this.getFieldError,
        getFieldWarning: _this.getFieldWarning,
        getFieldsError: _this.getFieldsError,
        isFieldsTouched: _this.isFieldsTouched,
        isFieldTouched: _this.isFieldTouched,
        isFieldValidating: _this.isFieldValidating,
        isFieldsValidating: _this.isFieldsValidating,
        resetFields: _this.resetFields,
        setFields: _this.setFields,
        setFieldsValue: _this.setFieldsValue,
        validateFields: _this.validateFields,
        submit: _this.submit,
        _init: true,
        getInternalHooks: _this.getInternalHooks
      };
    };
    this.getInternalHooks = function(key) {
      if (key === HOOK_MARK) {
        _this.formHooked = true;
        return {
          dispatch: _this.dispatch,
          initEntityValue: _this.initEntityValue,
          registerField: _this.registerField,
          useSubscribe: _this.useSubscribe,
          setInitialValues: _this.setInitialValues,
          destroyForm: _this.destroyForm,
          setCallbacks: _this.setCallbacks,
          setValidateMessages: _this.setValidateMessages,
          getFields: _this.getFields,
          setPreserve: _this.setPreserve,
          getInitialValue: _this.getInitialValue,
          registerWatch: _this.registerWatch
        };
      }
      warningOnce(false, "`getInternalHooks` is internal usage. Should not call directly.");
      return null;
    };
    this.useSubscribe = function(subscribable) {
      _this.subscribable = subscribable;
    };
    this.prevWithoutPreserves = null;
    this.setInitialValues = function(initialValues, init) {
      _this.initialValues = initialValues || {};
      if (init) {
        var _this$prevWithoutPres;
        var nextStore = setValues({}, initialValues, _this.store);
        (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 ? void 0 : _this$prevWithoutPres.map(function(_ref) {
          var namePath = _ref.key;
          nextStore = setValue(nextStore, namePath, getValue(initialValues, namePath));
        });
        _this.prevWithoutPreserves = null;
        _this.updateStore(nextStore);
      }
    };
    this.destroyForm = function() {
      var prevWithoutPreserves = new NameMap();
      _this.getFieldEntities(true).forEach(function(entity) {
        if (!_this.isMergedPreserve(entity.isPreserve())) {
          prevWithoutPreserves.set(entity.getNamePath(), true);
        }
      });
      _this.prevWithoutPreserves = prevWithoutPreserves;
    };
    this.getInitialValue = function(namePath) {
      var initValue = getValue(_this.initialValues, namePath);
      return namePath.length ? cloneDeep(initValue) : initValue;
    };
    this.setCallbacks = function(callbacks) {
      _this.callbacks = callbacks;
    };
    this.setValidateMessages = function(validateMessages) {
      _this.validateMessages = validateMessages;
    };
    this.setPreserve = function(preserve) {
      _this.preserve = preserve;
    };
    this.watchList = [];
    this.registerWatch = function(callback) {
      _this.watchList.push(callback);
      return function() {
        _this.watchList = _this.watchList.filter(function(fn) {
          return fn !== callback;
        });
      };
    };
    this.notifyWatch = function() {
      var namePath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      if (_this.watchList.length) {
        var values = _this.getFieldsValue();
        _this.watchList.forEach(function(callback) {
          callback(values, namePath);
        });
      }
    };
    this.timeoutId = null;
    this.warningUnhooked = function() {
    };
    this.updateStore = function(nextStore) {
      _this.store = nextStore;
    };
    this.getFieldEntities = function() {
      var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (!pure) {
        return _this.fieldEntities;
      }
      return _this.fieldEntities.filter(function(field) {
        return field.getNamePath().length;
      });
    };
    this.getFieldsMap = function() {
      var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var cache = new NameMap();
      _this.getFieldEntities(pure).forEach(function(field) {
        var namePath = field.getNamePath();
        cache.set(namePath, field);
      });
      return cache;
    };
    this.getFieldEntitiesForNamePathList = function(nameList) {
      if (!nameList) {
        return _this.getFieldEntities(true);
      }
      var cache = _this.getFieldsMap(true);
      return nameList.map(function(name) {
        var namePath = getNamePath(name);
        return cache.get(namePath) || {
          INVALIDATE_NAME_PATH: getNamePath(name)
        };
      });
    };
    this.getFieldsValue = function(nameList, filterFunc) {
      _this.warningUnhooked();
      if (nameList === true && !filterFunc) {
        return _this.store;
      }
      var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(nameList) ? nameList : null);
      var filteredNameList = [];
      fieldEntities.forEach(function(entity) {
        var _entity$isListField;
        var namePath = "INVALIDATE_NAME_PATH" in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();
        if (!nameList && ((_entity$isListField = entity.isListField) === null || _entity$isListField === void 0 ? void 0 : _entity$isListField.call(entity))) {
          return;
        }
        if (!filterFunc) {
          filteredNameList.push(namePath);
        } else {
          var meta = "getMeta" in entity ? entity.getMeta() : null;
          if (filterFunc(meta)) {
            filteredNameList.push(namePath);
          }
        }
      });
      return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));
    };
    this.getFieldValue = function(name) {
      _this.warningUnhooked();
      var namePath = getNamePath(name);
      return getValue(_this.store, namePath);
    };
    this.getFieldsError = function(nameList) {
      _this.warningUnhooked();
      var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);
      return fieldEntities.map(function(entity, index2) {
        if (entity && !("INVALIDATE_NAME_PATH" in entity)) {
          return {
            name: entity.getNamePath(),
            errors: entity.getErrors(),
            warnings: entity.getWarnings()
          };
        }
        return {
          name: getNamePath(nameList[index2]),
          errors: [],
          warnings: []
        };
      });
    };
    this.getFieldError = function(name) {
      _this.warningUnhooked();
      var namePath = getNamePath(name);
      var fieldError = _this.getFieldsError([namePath])[0];
      return fieldError.errors;
    };
    this.getFieldWarning = function(name) {
      _this.warningUnhooked();
      var namePath = getNamePath(name);
      var fieldError = _this.getFieldsError([namePath])[0];
      return fieldError.warnings;
    };
    this.isFieldsTouched = function() {
      _this.warningUnhooked();
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var arg0 = args[0], arg1 = args[1];
      var namePathList;
      var isAllFieldsTouched = false;
      if (args.length === 0) {
        namePathList = null;
      } else if (args.length === 1) {
        if (Array.isArray(arg0)) {
          namePathList = arg0.map(getNamePath);
          isAllFieldsTouched = false;
        } else {
          namePathList = null;
          isAllFieldsTouched = arg0;
        }
      } else {
        namePathList = arg0.map(getNamePath);
        isAllFieldsTouched = arg1;
      }
      var fieldEntities = _this.getFieldEntities(true);
      var isFieldTouched = function isFieldTouched2(field) {
        return field.isFieldTouched();
      };
      if (!namePathList) {
        return isAllFieldsTouched ? fieldEntities.every(isFieldTouched) : fieldEntities.some(isFieldTouched);
      }
      var map = new NameMap();
      namePathList.forEach(function(shortNamePath) {
        map.set(shortNamePath, []);
      });
      fieldEntities.forEach(function(field) {
        var fieldNamePath = field.getNamePath();
        namePathList.forEach(function(shortNamePath) {
          if (shortNamePath.every(function(nameUnit, i) {
            return fieldNamePath[i] === nameUnit;
          })) {
            map.update(shortNamePath, function(list) {
              return [].concat(_toConsumableArray(list), [field]);
            });
          }
        });
      });
      var isNamePathListTouched = function isNamePathListTouched2(entities) {
        return entities.some(isFieldTouched);
      };
      var namePathListEntities = map.map(function(_ref2) {
        var value = _ref2.value;
        return value;
      });
      return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
    };
    this.isFieldTouched = function(name) {
      _this.warningUnhooked();
      return _this.isFieldsTouched([name]);
    };
    this.isFieldsValidating = function(nameList) {
      _this.warningUnhooked();
      var fieldEntities = _this.getFieldEntities();
      if (!nameList) {
        return fieldEntities.some(function(testField) {
          return testField.isFieldValidating();
        });
      }
      var namePathList = nameList.map(getNamePath);
      return fieldEntities.some(function(testField) {
        var fieldNamePath = testField.getNamePath();
        return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
      });
    };
    this.isFieldValidating = function(name) {
      _this.warningUnhooked();
      return _this.isFieldsValidating([name]);
    };
    this.resetWithFieldInitialValue = function() {
      var info = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var cache = new NameMap();
      var fieldEntities = _this.getFieldEntities(true);
      fieldEntities.forEach(function(field) {
        var initialValue = field.props.initialValue;
        var namePath = field.getNamePath();
        if (initialValue !== void 0) {
          var records = cache.get(namePath) || /* @__PURE__ */ new Set();
          records.add({
            entity: field,
            value: initialValue
          });
          cache.set(namePath, records);
        }
      });
      var resetWithFields = function resetWithFields2(entities) {
        entities.forEach(function(field) {
          var initialValue = field.props.initialValue;
          if (initialValue !== void 0) {
            var namePath = field.getNamePath();
            var formInitialValue = _this.getInitialValue(namePath);
            if (formInitialValue !== void 0) {
              warningOnce(false, "Form already set 'initialValues' with path '".concat(namePath.join("."), "'. Field can not overwrite it."));
            } else {
              var records = cache.get(namePath);
              if (records && records.size > 1) {
                warningOnce(false, "Multiple Field with path '".concat(namePath.join("."), "' set 'initialValue'. Can not decide which one to pick."));
              } else if (records) {
                var originValue = _this.getFieldValue(namePath);
                if (!info.skipExist || originValue === void 0) {
                  _this.updateStore(setValue(_this.store, namePath, _toConsumableArray(records)[0].value));
                }
              }
            }
          }
        });
      };
      var requiredFieldEntities;
      if (info.entities) {
        requiredFieldEntities = info.entities;
      } else if (info.namePathList) {
        requiredFieldEntities = [];
        info.namePathList.forEach(function(namePath) {
          var records = cache.get(namePath);
          if (records) {
            var _requiredFieldEntitie;
            (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function(r2) {
              return r2.entity;
            })));
          }
        });
      } else {
        requiredFieldEntities = fieldEntities;
      }
      resetWithFields(requiredFieldEntities);
    };
    this.resetFields = function(nameList) {
      _this.warningUnhooked();
      var prevStore = _this.store;
      if (!nameList) {
        _this.updateStore(setValues({}, _this.initialValues));
        _this.resetWithFieldInitialValue();
        _this.notifyObservers(prevStore, null, {
          type: "reset"
        });
        _this.notifyWatch();
        return;
      }
      var namePathList = nameList.map(getNamePath);
      namePathList.forEach(function(namePath) {
        var initialValue = _this.getInitialValue(namePath);
        _this.updateStore(setValue(_this.store, namePath, initialValue));
      });
      _this.resetWithFieldInitialValue({
        namePathList
      });
      _this.notifyObservers(prevStore, namePathList, {
        type: "reset"
      });
      _this.notifyWatch(namePathList);
    };
    this.setFields = function(fields) {
      _this.warningUnhooked();
      var prevStore = _this.store;
      var namePathList = [];
      fields.forEach(function(fieldData) {
        var name = fieldData.name;
        fieldData.errors;
        var data = _objectWithoutProperties(fieldData, _excluded$1);
        var namePath = getNamePath(name);
        namePathList.push(namePath);
        if ("value" in data) {
          _this.updateStore(setValue(_this.store, namePath, data.value));
        }
        _this.notifyObservers(prevStore, [namePath], {
          type: "setField",
          data: fieldData
        });
      });
      _this.notifyWatch(namePathList);
    };
    this.getFields = function() {
      var entities = _this.getFieldEntities(true);
      var fields = entities.map(function(field) {
        var namePath = field.getNamePath();
        var meta = field.getMeta();
        var fieldData = _objectSpread2(_objectSpread2({}, meta), {}, {
          name: namePath,
          value: _this.getFieldValue(namePath)
        });
        Object.defineProperty(fieldData, "originRCField", {
          value: true
        });
        return fieldData;
      });
      return fields;
    };
    this.initEntityValue = function(entity) {
      var initialValue = entity.props.initialValue;
      if (initialValue !== void 0) {
        var namePath = entity.getNamePath();
        var prevValue = getValue(_this.store, namePath);
        if (prevValue === void 0) {
          _this.updateStore(setValue(_this.store, namePath, initialValue));
        }
      }
    };
    this.isMergedPreserve = function(fieldPreserve) {
      var mergedPreserve = fieldPreserve !== void 0 ? fieldPreserve : _this.preserve;
      return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;
    };
    this.registerField = function(entity) {
      _this.fieldEntities.push(entity);
      var namePath = entity.getNamePath();
      _this.notifyWatch([namePath]);
      if (entity.props.initialValue !== void 0) {
        var prevStore = _this.store;
        _this.resetWithFieldInitialValue({
          entities: [entity],
          skipExist: true
        });
        _this.notifyObservers(prevStore, [entity.getNamePath()], {
          type: "valueUpdate",
          source: "internal"
        });
      }
      return function(isListField, preserve) {
        var subNamePath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
        _this.fieldEntities = _this.fieldEntities.filter(function(item) {
          return item !== entity;
        });
        if (!_this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {
          var defaultValue = isListField ? void 0 : _this.getInitialValue(namePath);
          if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function(field) {
            return !matchNamePath(field.getNamePath(), namePath);
          })) {
            var _prevStore = _this.store;
            _this.updateStore(setValue(_prevStore, namePath, defaultValue, true));
            _this.notifyObservers(_prevStore, [namePath], {
              type: "remove"
            });
            _this.triggerDependenciesUpdate(_prevStore, namePath);
          }
        }
        _this.notifyWatch([namePath]);
      };
    };
    this.dispatch = function(action) {
      switch (action.type) {
        case "updateValue": {
          var namePath = action.namePath, value = action.value;
          _this.updateValue(namePath, value);
          break;
        }
        case "validateField": {
          var _namePath = action.namePath, triggerName = action.triggerName;
          _this.validateFields([_namePath], {
            triggerName
          });
          break;
        }
      }
    };
    this.notifyObservers = function(prevStore, namePathList, info) {
      if (_this.subscribable) {
        var mergedInfo = _objectSpread2(_objectSpread2({}, info), {}, {
          store: _this.getFieldsValue(true)
        });
        _this.getFieldEntities().forEach(function(_ref3) {
          var onStoreChange = _ref3.onStoreChange;
          onStoreChange(prevStore, namePathList, mergedInfo);
        });
      } else {
        _this.forceRootUpdate();
      }
    };
    this.triggerDependenciesUpdate = function(prevStore, namePath) {
      var childrenFields = _this.getDependencyChildrenFields(namePath);
      if (childrenFields.length) {
        _this.validateFields(childrenFields);
      }
      _this.notifyObservers(prevStore, childrenFields, {
        type: "dependenciesUpdate",
        relatedFields: [namePath].concat(_toConsumableArray(childrenFields))
      });
      return childrenFields;
    };
    this.updateValue = function(name, value) {
      var namePath = getNamePath(name);
      var prevStore = _this.store;
      _this.updateStore(setValue(_this.store, namePath, value));
      _this.notifyObservers(prevStore, [namePath], {
        type: "valueUpdate",
        source: "internal"
      });
      _this.notifyWatch([namePath]);
      var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath);
      var onValuesChange = _this.callbacks.onValuesChange;
      if (onValuesChange) {
        var changedValues = cloneByNamePathList(_this.store, [namePath]);
        onValuesChange(changedValues, _this.getFieldsValue());
      }
      _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));
    };
    this.setFieldsValue = function(store) {
      _this.warningUnhooked();
      var prevStore = _this.store;
      if (store) {
        var nextStore = setValues(_this.store, store);
        _this.updateStore(nextStore);
      }
      _this.notifyObservers(prevStore, null, {
        type: "valueUpdate",
        source: "external"
      });
      _this.notifyWatch();
    };
    this.getDependencyChildrenFields = function(rootNamePath) {
      var children = /* @__PURE__ */ new Set();
      var childrenFields = [];
      var dependencies2fields = new NameMap();
      _this.getFieldEntities().forEach(function(field) {
        var dependencies = field.props.dependencies;
        (dependencies || []).forEach(function(dependency) {
          var dependencyNamePath = getNamePath(dependency);
          dependencies2fields.update(dependencyNamePath, function() {
            var fields = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();
            fields.add(field);
            return fields;
          });
        });
      });
      var fillChildren = function fillChildren2(namePath) {
        var fields = dependencies2fields.get(namePath) || /* @__PURE__ */ new Set();
        fields.forEach(function(field) {
          if (!children.has(field)) {
            children.add(field);
            var fieldNamePath = field.getNamePath();
            if (field.isFieldDirty() && fieldNamePath.length) {
              childrenFields.push(fieldNamePath);
              fillChildren2(fieldNamePath);
            }
          }
        });
      };
      fillChildren(rootNamePath);
      return childrenFields;
    };
    this.triggerOnFieldsChange = function(namePathList, filedErrors) {
      var onFieldsChange = _this.callbacks.onFieldsChange;
      if (onFieldsChange) {
        var fields = _this.getFields();
        if (filedErrors) {
          var cache = new NameMap();
          filedErrors.forEach(function(_ref4) {
            var name = _ref4.name, errors = _ref4.errors;
            cache.set(name, errors);
          });
          fields.forEach(function(field) {
            field.errors = cache.get(field.name) || field.errors;
          });
        }
        var changedFields = fields.filter(function(_ref5) {
          var fieldName = _ref5.name;
          return containsNamePath(namePathList, fieldName);
        });
        onFieldsChange(changedFields, fields);
      }
    };
    this.validateFields = function(nameList, options) {
      _this.warningUnhooked();
      var provideNameList = !!nameList;
      var namePathList = provideNameList ? nameList.map(getNamePath) : [];
      var promiseList = [];
      _this.getFieldEntities(true).forEach(function(field) {
        if (!provideNameList) {
          namePathList.push(field.getNamePath());
        }
        if ((options === null || options === void 0 ? void 0 : options.recursive) && provideNameList) {
          var namePath = field.getNamePath();
          if (namePath.every(function(nameUnit, i) {
            return nameList[i] === nameUnit || nameList[i] === void 0;
          })) {
            namePathList.push(namePath);
          }
        }
        if (!field.props.rules || !field.props.rules.length) {
          return;
        }
        var fieldNamePath = field.getNamePath();
        if (!provideNameList || containsNamePath(namePathList, fieldNamePath)) {
          var promise = field.validateRules(_objectSpread2({
            validateMessages: _objectSpread2(_objectSpread2({}, defaultValidateMessages), _this.validateMessages)
          }, options));
          promiseList.push(promise.then(function() {
            return {
              name: fieldNamePath,
              errors: [],
              warnings: []
            };
          }).catch(function(ruleErrors) {
            var mergedErrors = [];
            var mergedWarnings = [];
            ruleErrors.forEach(function(_ref6) {
              var warningOnly = _ref6.rule.warningOnly, errors = _ref6.errors;
              if (warningOnly) {
                mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));
              } else {
                mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));
              }
            });
            if (mergedErrors.length) {
              return Promise.reject({
                name: fieldNamePath,
                errors: mergedErrors,
                warnings: mergedWarnings
              });
            }
            return {
              name: fieldNamePath,
              errors: mergedErrors,
              warnings: mergedWarnings
            };
          }));
        }
      });
      var summaryPromise = allPromiseFinish(promiseList);
      _this.lastValidatePromise = summaryPromise;
      summaryPromise.catch(function(results) {
        return results;
      }).then(function(results) {
        var resultNamePathList = results.map(function(_ref7) {
          var name = _ref7.name;
          return name;
        });
        _this.notifyObservers(_this.store, resultNamePathList, {
          type: "validateFinish"
        });
        _this.triggerOnFieldsChange(resultNamePathList, results);
      });
      var returnPromise = summaryPromise.then(function() {
        if (_this.lastValidatePromise === summaryPromise) {
          return Promise.resolve(_this.getFieldsValue(namePathList));
        }
        return Promise.reject([]);
      }).catch(function(results) {
        var errorList = results.filter(function(result) {
          return result && result.errors.length;
        });
        return Promise.reject({
          values: _this.getFieldsValue(namePathList),
          errorFields: errorList,
          outOfDate: _this.lastValidatePromise !== summaryPromise
        });
      });
      returnPromise.catch(function(e2) {
        return e2;
      });
      return returnPromise;
    };
    this.submit = function() {
      _this.warningUnhooked();
      _this.validateFields().then(function(values) {
        var onFinish = _this.callbacks.onFinish;
        if (onFinish) {
          try {
            onFinish(values);
          } catch (err) {
            console.error(err);
          }
        }
      }).catch(function(e2) {
        var onFinishFailed = _this.callbacks.onFinishFailed;
        if (onFinishFailed) {
          onFinishFailed(e2);
        }
      });
    };
    this.forceRootUpdate = forceRootUpdate;
  });
  function useForm(form) {
    var formRef = React__namespace.useRef();
    var _React$useState = React__namespace.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];
    if (!formRef.current) {
      if (form) {
        formRef.current = form;
      } else {
        var forceReRender = function forceReRender2() {
          forceUpdate({});
        };
        var formStore = new FormStore(forceReRender);
        formRef.current = formStore.getForm();
      }
    }
    return [formRef.current];
  }
  var FormContext$1 = /* @__PURE__ */ React__namespace.createContext({
    triggerFormChange: function triggerFormChange() {
    },
    triggerFormFinish: function triggerFormFinish() {
    },
    registerForm: function registerForm() {
    },
    unregisterForm: function unregisterForm() {
    }
  });
  var FormProvider = function FormProvider2(_ref) {
    var validateMessages = _ref.validateMessages, onFormChange = _ref.onFormChange, onFormFinish = _ref.onFormFinish, children = _ref.children;
    var formContext = React__namespace.useContext(FormContext$1);
    var formsRef = React__namespace.useRef({});
    return /* @__PURE__ */ React__namespace.createElement(FormContext$1.Provider, {
      value: _objectSpread2(_objectSpread2({}, formContext), {}, {
        validateMessages: _objectSpread2(_objectSpread2({}, formContext.validateMessages), validateMessages),
        triggerFormChange: function triggerFormChange(name, changedFields) {
          if (onFormChange) {
            onFormChange(name, {
              changedFields,
              forms: formsRef.current
            });
          }
          formContext.triggerFormChange(name, changedFields);
        },
        triggerFormFinish: function triggerFormFinish(name, values) {
          if (onFormFinish) {
            onFormFinish(name, {
              values,
              forms: formsRef.current
            });
          }
          formContext.triggerFormFinish(name, values);
        },
        registerForm: function registerForm(name, form) {
          if (name) {
            formsRef.current = _objectSpread2(_objectSpread2({}, formsRef.current), {}, _defineProperty({}, name, form));
          }
          formContext.registerForm(name, form);
        },
        unregisterForm: function unregisterForm(name) {
          var newForms = _objectSpread2({}, formsRef.current);
          delete newForms[name];
          formsRef.current = newForms;
          formContext.unregisterForm(name);
        }
      })
    }, children);
  };
  var _excluded = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed"];
  var Form$2 = function Form2(_ref, ref) {
    var name = _ref.name, initialValues = _ref.initialValues, fields = _ref.fields, form = _ref.form, preserve = _ref.preserve, children = _ref.children, _ref$component = _ref.component, Component = _ref$component === void 0 ? "form" : _ref$component, validateMessages = _ref.validateMessages, _ref$validateTrigger = _ref.validateTrigger, validateTrigger = _ref$validateTrigger === void 0 ? "onChange" : _ref$validateTrigger, onValuesChange = _ref.onValuesChange, _onFieldsChange = _ref.onFieldsChange, _onFinish = _ref.onFinish, onFinishFailed = _ref.onFinishFailed, restProps = _objectWithoutProperties(_ref, _excluded);
    var formContext = React__namespace.useContext(FormContext$1);
    var _useForm = useForm(form), _useForm2 = _slicedToArray(_useForm, 1), formInstance = _useForm2[0];
    var _formInstance$getInte = formInstance.getInternalHooks(HOOK_MARK), useSubscribe = _formInstance$getInte.useSubscribe, setInitialValues = _formInstance$getInte.setInitialValues, setCallbacks = _formInstance$getInte.setCallbacks, setValidateMessages = _formInstance$getInte.setValidateMessages, setPreserve = _formInstance$getInte.setPreserve, destroyForm = _formInstance$getInte.destroyForm;
    React__namespace.useImperativeHandle(ref, function() {
      return formInstance;
    });
    React__namespace.useEffect(function() {
      formContext.registerForm(name, formInstance);
      return function() {
        formContext.unregisterForm(name);
      };
    }, [formContext, formInstance, name]);
    setValidateMessages(_objectSpread2(_objectSpread2({}, formContext.validateMessages), validateMessages));
    setCallbacks({
      onValuesChange,
      onFieldsChange: function onFieldsChange(changedFields) {
        formContext.triggerFormChange(name, changedFields);
        if (_onFieldsChange) {
          for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            rest[_key - 1] = arguments[_key];
          }
          _onFieldsChange.apply(void 0, [changedFields].concat(rest));
        }
      },
      onFinish: function onFinish(values2) {
        formContext.triggerFormFinish(name, values2);
        if (_onFinish) {
          _onFinish(values2);
        }
      },
      onFinishFailed
    });
    setPreserve(preserve);
    var mountRef = React__namespace.useRef(null);
    setInitialValues(initialValues, !mountRef.current);
    if (!mountRef.current) {
      mountRef.current = true;
    }
    React__namespace.useEffect(function() {
      return destroyForm;
    }, []);
    var childrenNode;
    var childrenRenderProps = typeof children === "function";
    if (childrenRenderProps) {
      var values = formInstance.getFieldsValue(true);
      childrenNode = children(values, formInstance);
    } else {
      childrenNode = children;
    }
    useSubscribe(!childrenRenderProps);
    var prevFieldsRef = React__namespace.useRef();
    React__namespace.useEffect(function() {
      if (!isSimilar(prevFieldsRef.current || [], fields || [])) {
        formInstance.setFields(fields || []);
      }
      prevFieldsRef.current = fields;
    }, [fields, formInstance]);
    var formContextValue = React__namespace.useMemo(function() {
      return _objectSpread2(_objectSpread2({}, formInstance), {}, {
        validateTrigger
      });
    }, [formInstance, validateTrigger]);
    var wrapperNode = /* @__PURE__ */ React__namespace.createElement(Context.Provider, {
      value: formContextValue
    }, childrenNode);
    if (Component === false) {
      return wrapperNode;
    }
    return /* @__PURE__ */ React__namespace.createElement(Component, _extends$4({}, restProps, {
      onSubmit: function onSubmit(event) {
        event.preventDefault();
        event.stopPropagation();
        formInstance.submit();
      },
      onReset: function onReset(event) {
        var _restProps$onReset;
        event.preventDefault();
        formInstance.resetFields();
        (_restProps$onReset = restProps.onReset) === null || _restProps$onReset === void 0 ? void 0 : _restProps$onReset.call(restProps, event);
      }
    }), wrapperNode);
  };
  function stringify(value) {
    try {
      return JSON.stringify(value);
    } catch (err) {
      return Math.random();
    }
  }
  function useWatch() {
    var dependencies = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var form = arguments.length > 1 ? arguments[1] : void 0;
    var _useState = React.useState(), _useState2 = _slicedToArray(_useState, 2), value = _useState2[0], setValue2 = _useState2[1];
    var valueStr = React.useMemo(function() {
      return stringify(value);
    }, [value]);
    var valueStrRef = React.useRef(valueStr);
    valueStrRef.current = valueStr;
    var fieldContext = React.useContext(Context);
    var formInstance = form || fieldContext;
    var isValidForm = formInstance && formInstance._init;
    var namePath = getNamePath(dependencies);
    var namePathRef = React.useRef(namePath);
    namePathRef.current = namePath;
    React.useEffect(function() {
      if (!isValidForm) {
        return;
      }
      var getFieldsValue = formInstance.getFieldsValue, getInternalHooks = formInstance.getInternalHooks;
      var _getInternalHooks = getInternalHooks(HOOK_MARK), registerWatch = _getInternalHooks.registerWatch;
      var cancelRegister = registerWatch(function(store) {
        var newValue = getValue(store, namePathRef.current);
        var nextValueStr = stringify(newValue);
        if (valueStrRef.current !== nextValueStr) {
          setValue2(newValue);
        }
      });
      var initialValue = getValue(getFieldsValue(), namePathRef.current);
      setValue2(initialValue);
      return cancelRegister;
    }, []);
    return value;
  }
  var InternalForm = /* @__PURE__ */ React__namespace.forwardRef(Form$2);
  var RefForm = InternalForm;
  RefForm.FormProvider = FormProvider;
  RefForm.Field = WrapperField;
  RefForm.List = List;
  RefForm.useForm = useForm;
  RefForm.useWatch = useWatch;
  const FormSubscribe = (props) => {
    const update2 = useUpdate();
    const form = React.useContext(Context);
    return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, props.children(form.getFieldsValue(props.to), form), props.to.map((namePath) => /* @__PURE__ */ React__default["default"].createElement(Watcher, {
      key: namePath.toString(),
      form,
      namePath,
      onChange: update2
    })));
  };
  const Watcher = React.memo((props) => {
    const value = useWatch(props.namePath, props.form);
    useIsomorphicUpdateLayoutEffect(() => {
      props.onChange();
    }, [value]);
    return null;
  });
  const DEFAULT_FORM_CONTEXT = {
    colon: false,
    showValidateMessage: true,
    border: true,
    labelAlign: "left",
    controlAlign: "left"
  };
  const FormContext = React__default["default"].createContext(DEFAULT_FORM_CONTEXT);
  const [bem$e] = createNamespace("form");
  const Form$1 = React.forwardRef((props, ref) => {
    const _a = props, {
      className,
      style,
      layout,
      footer,
      children,
      colon,
      required: required2,
      border,
      labelAlign,
      controlAlign,
      showValidateMessage
    } = _a, formProps = __objRest(_a, [
      "className",
      "style",
      "layout",
      "footer",
      "children",
      "colon",
      "required",
      "border",
      "labelAlign",
      "controlAlign",
      "showValidateMessage"
    ]);
    return /* @__PURE__ */ React__default["default"].createElement(RefForm, __spreadValues({
      className: clsx(bem$e(), className),
      style,
      ref
    }, formProps), /* @__PURE__ */ React__default["default"].createElement(FormContext.Provider, {
      value: {
        layout,
        colon,
        border,
        required: required2,
        showValidateMessage,
        controlAlign,
        labelAlign
      }
    }, children), footer && /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$e("footer"))
    }, footer));
  });
  Form$1.defaultProps = {
    showValidateMessage: true
  };
  var reactIs = { exports: {} };
  var reactIs_production_min = {};
  /**
   * @license React
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u;
  u = Symbol.for("react.module.reference");
  function v(a) {
    if (typeof a === "object" && a !== null) {
      var r2 = a.$$typeof;
      switch (r2) {
        case b:
          switch (a = a.type, a) {
            case d:
            case f:
            case e:
            case m:
            case n:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k:
                case h:
                case l:
                case q:
                case p:
                case g:
                  return a;
                default:
                  return r2;
              }
          }
        case c:
          return r2;
      }
    }
  }
  reactIs_production_min.ContextConsumer = h;
  reactIs_production_min.ContextProvider = g;
  reactIs_production_min.Element = b;
  reactIs_production_min.ForwardRef = l;
  reactIs_production_min.Fragment = d;
  reactIs_production_min.Lazy = q;
  reactIs_production_min.Memo = p;
  reactIs_production_min.Portal = c;
  reactIs_production_min.Profiler = f;
  reactIs_production_min.StrictMode = e;
  reactIs_production_min.Suspense = m;
  reactIs_production_min.SuspenseList = n;
  reactIs_production_min.isAsyncMode = function() {
    return false;
  };
  reactIs_production_min.isConcurrentMode = function() {
    return false;
  };
  reactIs_production_min.isContextConsumer = function(a) {
    return v(a) === h;
  };
  reactIs_production_min.isContextProvider = function(a) {
    return v(a) === g;
  };
  reactIs_production_min.isElement = function(a) {
    return typeof a === "object" && a !== null && a.$$typeof === b;
  };
  reactIs_production_min.isForwardRef = function(a) {
    return v(a) === l;
  };
  reactIs_production_min.isFragment = function(a) {
    return v(a) === d;
  };
  reactIs_production_min.isLazy = function(a) {
    return v(a) === q;
  };
  reactIs_production_min.isMemo = function(a) {
    return v(a) === p;
  };
  reactIs_production_min.isPortal = function(a) {
    return v(a) === c;
  };
  reactIs_production_min.isProfiler = function(a) {
    return v(a) === f;
  };
  reactIs_production_min.isStrictMode = function(a) {
    return v(a) === e;
  };
  reactIs_production_min.isSuspense = function(a) {
    return v(a) === m;
  };
  reactIs_production_min.isSuspenseList = function(a) {
    return v(a) === n;
  };
  reactIs_production_min.isValidElementType = function(a) {
    return typeof a === "string" || typeof a === "function" || a === d || a === f || a === e || a === m || a === n || a === t || typeof a === "object" && a !== null && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === u || a.getModuleId !== void 0) ? true : false;
  };
  reactIs_production_min.typeOf = v;
  {
    reactIs.exports = reactIs_production_min;
  }
  function shouldConstruct(Component) {
    const prototype = Component.prototype;
    return !!(prototype && prototype.isReactComponent);
  }
  function isSimpleFunctionComponent(type2) {
    return typeof type2 === "function" && !shouldConstruct(type2) && type2.defaultProps === void 0;
  }
  function isSafeSetRefComponent(component) {
    if (!reactIs.exports.isForwardRef(component))
      return false;
    if (reactIs.exports.isFragment(component))
      return false;
    if (reactIs.exports.isMemo(component))
      return isSafeSetRefComponent(component.type);
    return !isSimpleFunctionComponent(component.type);
  }
  function undefinedFallback(...items) {
    let i;
    for (i = 0; i < items.length; i++) {
      if (items[i] !== void 0)
        break;
    }
    return items[i];
  }
  const MemoInput = React__default["default"].memo((_K) => {
    var _L = _K, { children } = _L, props = __objRest(_L, ["children"]);
    return React__default["default"].cloneElement(children, props);
  }, (prev2, next) => prev2.value === next.value && prev2.update === next.update);
  const [bem$d] = createNamespace("form-item");
  const FormItemLayout = (props) => {
    var _b, _c, _d, _e, _f, _g;
    const _a = props, { meta } = _a, fieldProps = __objRest(_a, ["meta"]);
    const context = React__default["default"].useContext(FormContext);
    const layout = (_b = props.layout) != null ? _b : context.layout;
    const border = (_c = props.border) != null ? _c : context.border;
    const colon = (_d = props.colon) != null ? _d : context.colon;
    const showValidateMessage = (_e = props.showValidateMessage) != null ? _e : context.showValidateMessage;
    const labelAlign = (_f = props.labelAlign) != null ? _f : context.labelAlign;
    const controlAlign = (_g = props.controlAlign) != null ? _g : context.controlAlign;
    const error = meta && meta.errors.length > 0;
    const errorMessage = showValidateMessage && error ? meta.errors[0] : null;
    const attrs = __spreadProps(__spreadValues({}, fieldProps), {
      className: clsx(bem$d({ vertical: layout === "vertical" }), props.className),
      colon,
      error: showValidateMessage ? false : error,
      errorMessage,
      labelAlign,
      controlAlign,
      border
    });
    return /* @__PURE__ */ React__default["default"].createElement(FieldNamespace, __spreadValues({}, attrs), props.children);
  };
  const FormItem = (props) => {
    const formContext = React__default["default"].useContext(FormContext);
    const _a = props, {
      name,
      noStyle,
      rules: rules2,
      trigger = "onChange",
      validateTrigger = trigger,
      shouldUpdate,
      dependencies,
      messageVariables,
      label,
      required: required2,
      disabled,
      children,
      onClick
    } = _a, rcFieldProps = __objRest(_a, [
      "name",
      "noStyle",
      "rules",
      "trigger",
      "validateTrigger",
      "shouldUpdate",
      "dependencies",
      "messageVariables",
      "label",
      "required",
      "disabled",
      "children",
      "onClick"
    ]);
    const fieldProps = pick(props, [
      "style",
      "className",
      "tooltip",
      "intro",
      "colon",
      "labelWidth",
      "labelAlign",
      "labelClass",
      "showValidateMessage",
      "controlAlign",
      "errorMessageAlign",
      "border",
      "layout",
      "isLink",
      "size",
      "arrowDirection",
      "leftIcon",
      "rightIcon",
      "prefix",
      "suffix"
    ]);
    const { validateTrigger: contextValidateTrigger } = React__default["default"].useContext(Context);
    const mergedValidateTrigger = undefinedFallback(validateTrigger, contextValidateTrigger, trigger);
    const widgetRef = React__default["default"].useRef(null);
    const updateRef2 = React__default["default"].useRef(0);
    updateRef2.current += 1;
    function renderLayout(baseChildren, fieldId, meta, isRequired) {
      if (noStyle) {
        return baseChildren;
      }
      return /* @__PURE__ */ React__default["default"].createElement(FormItemLayout, __spreadProps(__spreadValues({
        htmlFor: fieldId,
        meta
      }, fieldProps), {
        required: isRequired,
        label,
        disabled,
        onClick: (e2) => onClick == null ? void 0 : onClick(e2, widgetRef)
      }), baseChildren);
    }
    const isRenderProps = typeof children === "function";
    if (!name && !isRenderProps && !props.dependencies) {
      return renderLayout(children);
    }
    let variables = {};
    if (typeof label === "string") {
      variables.label = label;
    }
    if (messageVariables) {
      variables = __spreadValues(__spreadValues({}, variables), messageVariables);
    }
    return /* @__PURE__ */ React__default["default"].createElement(WrapperField, __spreadProps(__spreadValues({}, rcFieldProps), {
      name,
      shouldUpdate,
      dependencies,
      rules: rules2,
      trigger,
      validateTrigger: mergedValidateTrigger
    }), (control, meta, context) => {
      var _a2;
      let childNode = null;
      const isRequired = required2 !== void 0 ? required2 : (_a2 = formContext.required) != null ? _a2 : rules2 && rules2.some((rule) => !!(rule && typeof rule === "object" && rule.required));
      const fieldId = (toArray$2(name).length && meta ? meta.name : []).join("_");
      if (isRenderProps) {
        if ((shouldUpdate || dependencies) && !name) {
          childNode = children(context);
        }
      } else if (dependencies && !name)
        ;
      else if (React__default["default"].isValidElement(children)) {
        if (children.props.defaultValue)
          ;
        const childProps = __spreadValues(__spreadValues({}, children.props), control);
        if (isSafeSetRefComponent(children)) {
          childProps.ref = (instance) => {
            const originRef = children.ref;
            if (originRef) {
              if (typeof originRef === "function") {
                originRef(instance);
              }
              if ("current" in originRef) {
                originRef.current = instance;
              }
            }
            widgetRef.current = instance;
          };
        }
        if (!childProps.id) {
          childProps.id = fieldId;
        }
        if (disabled) {
          childProps.disabled = disabled;
        }
        const triggers = /* @__PURE__ */ new Set([
          ...toArray$2(trigger),
          ...toArray$2(mergedValidateTrigger)
        ]);
        triggers.forEach((eventName) => {
          childProps[eventName] = (...args) => {
            var _a3, _b, _c;
            (_a3 = control[eventName]) == null ? void 0 : _a3.call(control, ...args);
            (_c = (_b = children.props)[eventName]) == null ? void 0 : _c.call(_b, ...args);
          };
        });
        childNode = /* @__PURE__ */ React__default["default"].createElement(MemoInput, {
          value: control[props.valuePropName || "value"],
          update: updateRef2.current
        }, React__default["default"].cloneElement(children, childProps));
      } else {
        childNode = children;
      }
      return renderLayout(childNode, fieldId, meta, isRequired);
    });
  };
  const Form = Object.assign(Form$1, { Item: FormItem, useForm, List, Subscribe: FormSubscribe, useWatch });
  const INHERIT_PROPS = [
    "title",
    "visible",
    "popup",
    "value",
    "defaultValue",
    "loading",
    "readOnly",
    "itemHeight",
    "swipeDuration",
    "visibleItemCount",
    "cancelButtonText",
    "confirmButtonText",
    "toolbar",
    "columnsTop",
    "columnsBottom",
    "optionRender",
    "placeholder",
    "onChange",
    "onCancel",
    "onConfirm",
    "children"
  ];
  function parseVanAreaList(data, columnsNum) {
    const { province_list = {}, city_list = {}, county_list = {} } = data;
    const provinces = Object.entries(province_list).map(([value, text]) => ({
      value,
      text
    }));
    const citys = Object.entries(city_list).map(([value, text]) => ({
      value,
      text
    }));
    const countrys = Object.entries(county_list).map(([value, text]) => ({
      value,
      text
    }));
    if (columnsNum > 2) {
      citys.forEach((city) => {
        var _a;
        const value = (_a = city.value) == null ? void 0 : _a.slice(0, 4);
        const children = countrys.filter((country) => {
          var _a2;
          return ((_a2 = country.value) == null ? void 0 : _a2.slice(0, 4)) === value;
        });
        city.children = children;
      });
    }
    if (columnsNum > 1) {
      provinces.forEach((province) => {
        var _a;
        const provinceCode = (_a = province.value) == null ? void 0 : _a.slice(0, 2);
        const children = citys.filter((city) => {
          var _a2;
          return ((_a2 = city.value) == null ? void 0 : _a2.slice(0, 2)) === provinceCode;
        });
        province.children = children;
      });
    }
    return provinces;
  }
  const [bem$c] = createNamespace("area");
  const Area = React.forwardRef((props, ref) => {
    const columns = React.useMemo(() => {
      var _a;
      return (_a = props.columns) != null ? _a : parseVanAreaList(props.areaList, +props.columnsNum);
    }, [props.columnsNum, props.areaList, props.columns]);
    return /* @__PURE__ */ React__default["default"].createElement(Picker, __spreadValues({
      ref,
      style: props.style,
      className: clsx(bem$c(), props.className),
      columns
    }, pick(props, INHERIT_PROPS)));
  });
  Area.defaultProps = {
    areaList: {},
    columnsNum: 3
  };
  var index$7 = "";
  const CardHeader = (props) => {
    const [bem2] = createNamespace("card-header");
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, bem2(), { [BORDER_BOTTOM]: props.border }),
      style: props.style,
      onClick: props.onClick
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem2("content"))
    }, props.children), props.extra && /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem2("extra"))
    }, props.extra));
  };
  const CardBody = (props) => {
    const [bem2] = createNamespace("card-body");
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, bem2()),
      style: props.style,
      onClick: props.onClick
    }, props.children);
  };
  const CardFooter = (props) => {
    const [bem2] = createNamespace("card-footer");
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, bem2({ compact: props.compact }), {
        [BORDER_TOP]: props.border
      }),
      style: props.style,
      onClick: props.onClick
    }, props.children);
  };
  const CardCover = (props) => {
    const [bem2] = createNamespace("card-cover");
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, bem2()),
      style: props.style,
      onClick: props.onClick
    }, props.children);
  };
  const Card$1 = (props) => {
    const [bem2] = createNamespace("card");
    const { className, style, round: round2, border, children } = props;
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem2({ round: round2, border }), className),
      style,
      onClick: props.onClick
    }, children);
  };
  Card$1.defaultProps = {};
  const Card = Object.assign(Card$1, {
    Header: CardHeader,
    Body: CardBody,
    Footer: CardFooter,
    Cover: CardCover
  });
  var index$6 = "";
  function isStringOrNumber(target) {
    return typeof target === "string" || typeof target === "number";
  }
  const [bem$b] = createNamespace("product-card");
  const ProductCard = (props) => {
    const renderTitle = () => {
      if (props.title) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$b("title"), "rv-multi-ellipsis--l2")
        }, props.title);
      }
      return null;
    };
    const renderThumbTag = () => {
      if (props.tag) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$b("tag"))
        }, isStringOrNumber(props.tag) ? /* @__PURE__ */ React__default["default"].createElement(Tag, {
          mark: true,
          type: "danger"
        }, props.tag) : props.tag);
      }
      return null;
    };
    const renderThumbImage = () => {
      if (!props.thumb)
        return null;
      if (typeof props.thumb === "string") {
        return /* @__PURE__ */ React__default["default"].createElement(ImageNamespace, {
          src: props.thumb,
          fit: "cover",
          width: "100%",
          height: "100%",
          lazyload: props.lazyload
        });
      }
      return props.thumb;
    };
    const renderThumb = () => {
      if (props.thumb) {
        return /* @__PURE__ */ React__default["default"].createElement("a", {
          href: props.thumbLink,
          className: clsx(bem$b("thumb")),
          onClick: props.onClickThumb
        }, renderThumbImage(), renderThumbTag());
      }
      return null;
    };
    const renderDesc = () => {
      if (props.desc) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$b("desc"), "rv-ellipsis")
        }, props.desc);
      }
      return null;
    };
    const renderPriceText = () => {
      if (isStringOrNumber(props.price)) {
        const priceArr = props.price.toString().split(".");
        return /* @__PURE__ */ React__default["default"].createElement("div", null, /* @__PURE__ */ React__default["default"].createElement("span", {
          className: clsx(bem$b("price-currency"))
        }, props.currency), /* @__PURE__ */ React__default["default"].createElement("span", {
          className: clsx(bem$b("price-integer"))
        }, priceArr[0]), props.decimal && /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, ".", /* @__PURE__ */ React__default["default"].createElement("span", {
          className: clsx(bem$b("price-decimal"))
        }, priceArr[1] || "00")));
      }
      return props.price;
    };
    const renderOriginalPrice = () => {
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$b("origin-price"))
      }, isStringOrNumber(props.originPrice) ? `${props.currency} ${props.originPrice}` : props.originPrice);
    };
    const showNum = isDef(props.num);
    const showPrice = isDef(props.price);
    const showOriginPrice = isDef(props.originPrice);
    const showBottom = showNum || showPrice || showOriginPrice || props.bottom;
    const Price = showPrice && /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$b("price"))
    }, renderPriceText());
    const OriginPrice = showOriginPrice && renderOriginalPrice();
    const Num = showNum && /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$b("num"))
    }, isStringOrNumber(props.num) ? `x${props.num}` : props.num);
    const Footer = props.footer && /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$b("footer"))
    }, props.footer);
    const Bottom = showBottom && /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$b("bottom"))
    }, props.priceTop, Price, OriginPrice, Num, props.bottom);
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$b(), props.className),
      style: props.style,
      onClick: props.onClick
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$b("header"))
    }, renderThumb(), /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$b("content", { centered: props.centered }))
    }, /* @__PURE__ */ React__default["default"].createElement("div", null, renderTitle(), renderDesc(), props.tags), Bottom)), Footer);
  };
  ProductCard.defaultProps = {
    currency: "\xA5",
    decimal: true
  };
  var index$5 = "";
  const [bem$a] = createNamespace("submit-bar");
  const SubmitBar = (props) => {
    const { locale } = React.useContext(ConfigProvider$1);
    const renderText = () => {
      const { price, label, currency, textAlign, suffixLabel, decimalLength } = props;
      if (typeof +price === "number") {
        const pricePair = (+price / 100).toFixed(+decimalLength).split(".");
        const decimal = decimalLength ? `.${pricePair[1]}` : "";
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$a("text")),
          style: { textAlign }
        }, /* @__PURE__ */ React__default["default"].createElement("span", null, label || locale.vanSubmitBar.label), /* @__PURE__ */ React__default["default"].createElement("span", {
          className: clsx(bem$a("price"))
        }, currency, /* @__PURE__ */ React__default["default"].createElement("span", {
          className: clsx(bem$a("price-integer"))
        }, pricePair[0]), decimal), suffixLabel && /* @__PURE__ */ React__default["default"].createElement("span", {
          className: clsx(bem$a("suffix-label"))
        }, suffixLabel));
      }
      return null;
    };
    const renderTip = () => {
      const { tip, tipIcon } = props;
      if (tip) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$a("tip"))
        }, tipIcon && React__default["default"].cloneElement(tipIcon, {
          className: clsx(bem$a("tip-icon"))
        }), tip && /* @__PURE__ */ React__default["default"].createElement("span", {
          className: clsx(bem$a("tip-text"))
        }, tip));
      }
      return null;
    };
    const onClickButton = () => props == null ? void 0 : props.onSubmit();
    const renderButton = () => {
      if (props.button) {
        return props.button;
      }
      return /* @__PURE__ */ React__default["default"].createElement(Button, {
        round: true,
        type: props.buttonType,
        text: props.buttonText,
        className: clsx(bem$a("button", props.buttonType)),
        color: props.buttonColor,
        loading: props.loading,
        disabled: props.disabled,
        onClick: onClickButton
      });
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, bem$a(), {
        "rv-safe-area-bottom": props.safeAreaInsetBottom
      }),
      style: props.style
    }, props.top, renderTip(), /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$a("bar"))
    }, props.children, renderText(), renderButton()));
  };
  SubmitBar.defaultProps = {
    buttonType: "danger",
    decimalLength: 2,
    currency: "\xA5",
    safeAreaInsetBottom: true
  };
  var index$4 = "";
  function formatValue(coupons, chosenCoupon, currency, locale) {
    const coupon = coupons[+chosenCoupon];
    if (coupon) {
      let value = 0;
      if (isDef(coupon.value)) {
        ({ value } = coupon);
      } else if (isDef(coupon.denominations)) {
        value = coupon.denominations;
      }
      return `-${currency} ${(value / 100).toFixed(2)}`;
    }
    return coupons.length === 0 ? locale.noCoupon : locale.vanCouponCell.count(coupons.length);
  }
  const [bem$9] = createNamespace("coupon-cell");
  const CouponCell = (props) => {
    const { locale } = React.useContext(ConfigProvider$1);
    const selected = props.coupons[+props.chosenCoupon];
    const value = formatValue(props.coupons, props.chosenCoupon, props.currency, locale);
    return /* @__PURE__ */ React__default["default"].createElement(Cell, {
      style: props.style,
      className: clsx(bem$9(), props.className),
      value,
      title: props.title || locale.vanCouponCell.title,
      border: props.border,
      isLink: props.editable,
      valueClass: clsx(bem$9("value", { selected })),
      onClick: props.onClick
    });
  };
  CouponCell.defaultProps = {
    border: true,
    editable: true,
    coupons: [],
    currency: "\xA5",
    chosenCoupon: -1
  };
  var index$3 = "";
  function getDate(timeStamp) {
    const date2 = new Date(timeStamp * 1e3);
    return `${date2.getFullYear()}.${padZero(date2.getMonth() + 1)}.${padZero(date2.getDate())}`;
  }
  function formatDiscount(discount) {
    return (discount / 10).toFixed(discount % 10 === 0 ? 0 : 1);
  }
  function formatAmount(amount) {
    return (amount / 100).toFixed(amount % 100 === 0 ? 0 : amount % 10 === 0 ? 1 : 2);
  }
  const [bem$8] = createNamespace("coupon");
  const Coupon = (props) => {
    const { locale } = React.useContext(ConfigProvider$1);
    const validPeriod = React.useMemo(() => {
      const { startAt, endAt } = props.coupon;
      return `${getDate(startAt)} - ${getDate(endAt)}`;
    }, [props.coupon]);
    const faceAmount = React.useMemo(() => {
      const { coupon: coupon2, currency } = props;
      if (coupon2.valueDesc) {
        return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, coupon2.valueDesc, " ", /* @__PURE__ */ React__default["default"].createElement("span", null, coupon2.unitDesc || ""));
      }
      if (coupon2.denominations) {
        const denominations = formatAmount(coupon2.denominations);
        return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, /* @__PURE__ */ React__default["default"].createElement("span", null, currency), " $", denominations);
      }
      if (coupon2.discount) {
        return locale.vanCoupon.discount(+formatDiscount(coupon2.discount));
      }
      return "";
    }, [props.coupon, props.coupon]);
    const conditionMessage = React.useMemo(() => {
      const condition = formatAmount(props.coupon.originCondition || 0);
      return condition === "0" ? locale.vanCoupon.unlimited : locale.vanCoupon.condition(+condition);
    }, [props.coupon.originCondition]);
    const { chosen, coupon, disabled } = props;
    const description = disabled && coupon.reason || coupon.description;
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, bem$8({ disabled })),
      style: props.style,
      onClick: props.onClick
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$8("content"))
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$8("head"))
    }, /* @__PURE__ */ React__default["default"].createElement("h2", {
      className: clsx(bem$8("amount"))
    }, faceAmount), /* @__PURE__ */ React__default["default"].createElement("p", {
      className: clsx(bem$8("condition"))
    }, coupon.condition || conditionMessage)), /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$8("body"))
    }, /* @__PURE__ */ React__default["default"].createElement("p", {
      className: clsx(bem$8("name"))
    }, coupon.name), /* @__PURE__ */ React__default["default"].createElement("p", {
      className: clsx(bem$8("valid"))
    }, validPeriod), !disabled && /* @__PURE__ */ React__default["default"].createElement(Checkbox, {
      className: clsx(bem$8("corner")),
      checked: chosen
    }))), description && /* @__PURE__ */ React__default["default"].createElement("p", {
      className: clsx(bem$8("description"))
    }, description));
  };
  Coupon.defaultProps = {
    currency: "\xA5"
  };
  const [bem$7] = createNamespace("coupon-list");
  const CouponList = (props) => {
    var _a;
    const { locale } = React.useContext(ConfigProvider$1);
    const innerEffect = React.useRef(false);
    const [state, updateState] = useSetState({
      tab: 0,
      code: props.code
    });
    const buttonDisabled = React.useMemo(() => !props.exchangeButtonLoading && (props.exchangeButtonDisabled || !state.code || state.code.length < props.exchangeMinLength), [
      props.exchangeButtonLoading,
      props.exchangeButtonDisabled,
      state.code,
      props.exchangeMinLength
    ]);
    const innerChange = (code) => {
      updateState({ code });
      innerEffect.current = true;
    };
    const onExchange = () => {
      if (props.onExchange)
        props.onExchange(state.code);
      if (!props.code) {
        innerChange("");
      }
    };
    const renderEmpty = () => /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$7("empty"))
    }, /* @__PURE__ */ React__default["default"].createElement("img", {
      alt: "empty",
      src: props.emptyImage
    }), /* @__PURE__ */ React__default["default"].createElement("p", null, locale.noCoupon));
    const renderExchangeBar = () => {
      if (props.showExchangeBar) {
        return /* @__PURE__ */ React__default["default"].createElement("div", {
          className: clsx(bem$7("exchange-bar"))
        }, /* @__PURE__ */ React__default["default"].createElement(FieldNamespace, {
          value: state.code,
          onChange: innerChange,
          clearable: true,
          border: false,
          className: clsx(bem$7("field")),
          placeholder: props.inputPlaceholder || locale.vanCouponList.placeholder,
          maxLength: 20
        }), /* @__PURE__ */ React__default["default"].createElement(Button, {
          plain: true,
          type: "primary",
          className: clsx(bem$7("exchange")),
          text: props.exchangeButtonText || locale.vanCouponList.exchange,
          loading: props.exchangeButtonLoading,
          disabled: buttonDisabled,
          onClick: onExchange
        }));
      }
      return null;
    };
    const renderCouponTab = () => {
      const { coupons } = props;
      const count = props.showCount ? ` (${coupons.length})` : "";
      const title = (props.enabledTitle || locale.vanCouponList.enable) + count;
      return /* @__PURE__ */ React__default["default"].createElement(Tabs.TabPane, {
        title
      }, /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$7("list", {
          "with-bar": props.showExchangeBar,
          "with-bottom": props.showCloseButton
        }))
      }, coupons.map((coupon, index2) => /* @__PURE__ */ React__default["default"].createElement(Coupon, {
        key: coupon.id,
        coupon,
        chosen: index2 === props.chosenCoupon,
        currency: props.currency,
        onClick: () => props.onChange(index2)
      })), !coupons.length && renderEmpty(), props.listFooter));
    };
    const renderDisabledTab = () => {
      const { disabledCoupons } = props;
      const count = props.showCount ? ` (${disabledCoupons.length})` : "";
      const title = (props.disabledTitle || locale.vanCouponList.disabled) + count;
      return /* @__PURE__ */ React__default["default"].createElement(Tabs.TabPane, {
        title
      }, /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$7("list", {
          "with-bar": props.showExchangeBar,
          "with-bottom": props.showCloseButton
        }))
      }, disabledCoupons.map((coupon) => /* @__PURE__ */ React__default["default"].createElement(Coupon, {
        disabled: true,
        key: coupon.id,
        coupon,
        currency: props.currency
      })), !disabledCoupons.length && renderEmpty(), props.disabledListFooter));
    };
    React.useEffect(() => {
      if (innerEffect.current) {
        innerEffect.current = true;
        return;
      }
      updateState({ code: props.code });
    }, [props.code]);
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$7(), props.className),
      style: props.style
    }, renderExchangeBar(), /* @__PURE__ */ React__default["default"].createElement(Tabs, __spreadProps(__spreadValues({
      active: state.tab,
      border: false
    }, props.tabsProps), {
      className: clsx(bem$7("tab"), (_a = props.tabsProps) == null ? void 0 : _a.className)
    }), renderCouponTab(), renderDisabledTab()), /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$7("bottom"))
    }, /* @__PURE__ */ React__default["default"].createElement(Button, {
      "v-show": props.showCloseButton,
      round: true,
      block: true,
      type: "primary",
      className: clsx(bem$7("close")),
      text: props.closeButtonText || locale.vanCouponList.close,
      onClick: () => {
        var _a2;
        return (_a2 = props.onChange) == null ? void 0 : _a2.call(props, -1);
      }
    })));
  };
  const EMPTY_IMAGE = "https://img.yzcdn.cn/vant/coupon-empty.png";
  CouponList.defaultProps = {
    showCount: true,
    showExchangeBar: true,
    showCloseButton: true,
    code: "",
    exchangeMinLength: 1,
    chosenCoupon: -1,
    coupons: [],
    disabledCoupons: [],
    displayedCouponIndex: -1,
    currency: "\xA5",
    emptyImage: EMPTY_IMAGE
  };
  var index$2 = "";
  const LIMIT_TYPE = {
    QUOTA_LIMIT: 0,
    STOCK_LIMIT: 1
  };
  const UNSELECTED_SKU_VALUE_ID = "";
  function getSkuImgValue(sku, selectedSku) {
    let imgValue;
    sku.tree.some((item) => {
      const id = selectedSku[item.k_s];
      if (id && item.v) {
        const matchedSkuIdx = item.v.findIndex((skuValue) => skuValue.id === id);
        const matchedSku = item.v[matchedSkuIdx];
        const img = (matchedSku == null ? void 0 : matchedSku.previewImgUrl) || (matchedSku == null ? void 0 : matchedSku.imgUrl) || (matchedSku == null ? void 0 : matchedSku.img_url);
        if (img) {
          imgValue = __spreadProps(__spreadValues({}, matchedSku), {
            ks: item.k_s,
            imgUrl: img,
            position: matchedSkuIdx
          });
          return true;
        }
      }
      return false;
    });
    return imgValue;
  }
  const normalizeSkuTree = (skuTree) => {
    const normalizedTree = {};
    skuTree.forEach((treeItem) => {
      normalizedTree[treeItem.k_s] = treeItem.v;
    });
    return normalizedTree;
  };
  const normalizePropList = (propList) => {
    const normalizedProp = {};
    propList.forEach((item) => {
      const itemObj = {};
      item.v.forEach((it) => {
        itemObj[it.id] = it;
      });
      normalizedProp[item.k_id] = itemObj;
    });
    return normalizedProp;
  };
  const isAllSelected = (skuTree, selectedSku) => {
    const selected = Object.keys(selectedSku).filter((skuKeyStr) => selectedSku[skuKeyStr] !== UNSELECTED_SKU_VALUE_ID);
    return skuTree.length === selected.length;
  };
  const getSkuComb = (skuList, selectedSku) => {
    const skuComb = skuList.filter((item) => Object.keys(selectedSku).every((skuKeyStr) => String(item[skuKeyStr]) === String(selectedSku[skuKeyStr])));
    return skuComb[0];
  };
  const getSelectedSkuValues = (skuTree, selectedSku) => {
    const normalizedTree = normalizeSkuTree(skuTree);
    return Object.keys(selectedSku).reduce((selectedValues, skuKeyStr) => {
      const skuValues = normalizedTree[skuKeyStr];
      const skuValueId = selectedSku[skuKeyStr];
      if (skuValueId !== UNSELECTED_SKU_VALUE_ID) {
        const skuValue = skuValues.filter((value) => value.id === skuValueId)[0];
        skuValue && selectedValues.push(skuValue);
      }
      return selectedValues;
    }, []);
  };
  const isSkuChoosable = (skuList, selectedSku, skuToChoose) => {
    const { key, valueId } = skuToChoose;
    const matchedSku = __spreadProps(__spreadValues({}, selectedSku), {
      [key]: valueId
    });
    const skusToCheck = Object.keys(matchedSku).filter((skuKey) => matchedSku[skuKey] !== UNSELECTED_SKU_VALUE_ID);
    const filteredSku = skuList.filter((sku) => skusToCheck.every((skuKey) => String(matchedSku[skuKey]) === String(sku[skuKey])));
    const stock = filteredSku.reduce((total, sku) => {
      total += sku.stock_num;
      return total;
    }, 0);
    return stock > 0;
  };
  const getSelectedPropValues = (propList, selectedProp) => {
    const normalizeProp = normalizePropList(propList);
    return Object.keys(selectedProp).reduce((acc, cur) => {
      selectedProp[cur].forEach((it) => {
        acc.push(__spreadValues({}, normalizeProp[cur][it]));
      });
      return acc;
    }, []);
  };
  const getSelectedProperties = (propList, selectedProp) => {
    const list = [];
    (propList || []).forEach((prop) => {
      if (selectedProp[prop.k_id] && selectedProp[prop.k_id].length > 0) {
        const v2 = [];
        prop.v.forEach((it) => {
          if (selectedProp[prop.k_id].indexOf(it.id) > -1) {
            v2.push(__spreadValues({}, it));
          }
        });
        list.push(__spreadProps(__spreadValues({}, prop), {
          v: v2
        }));
      }
    });
    return list;
  };
  const [bem$6] = createNamespace("sku-row");
  const SkuRow = (props) => {
    const { skuRow } = props;
    const renderTitle = () => {
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$6("title"))
      }, skuRow.k, skuRow.is_multiple && /* @__PURE__ */ React__default["default"].createElement("span", {
        className: clsx(bem$6("title-multiple"))
      }, "\uFF08\u53EF\u591A\u9009\uFF09"));
    };
    const renderContent = () => {
      const { largeImageMode } = skuRow;
      return largeImageMode ? /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$6("scroller"))
      }, /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$6("row"))
      }, props.children)) : props.children;
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$6(), BORDER_BOTTOM)
    }, renderTitle(), renderContent());
  };
  const [bem$5] = createNamespace("sku-row");
  const SkuRowItem = (props) => {
    var _a, _b;
    const classPrefix = props.largeImageMode ? "image-item" : "item";
    const imgUrl = React.useMemo(() => {
      const url = props.skuValue.imgUrl || props.skuValue.img_url;
      return props.largeImageMode ? url || "https://img01.yzcdn.cn/upload_files/2020/06/24/FmKWDg0bN9rMcTp9ne8MXiQWGtLn.png" : url;
    }, [props.skuValue]);
    const choosable = React.useMemo(() => {
      if (!props.disableSoldoutSku) {
        return true;
      }
      return isSkuChoosable(props.skuList, props.selectedSku, {
        key: props.skuKeyStr,
        valueId: props.skuValue.id
      });
    }, [
      JSON.stringify(props.skuList),
      JSON.stringify(props.selectedSku),
      props.skuKeyStr
    ]);
    const imageRender = () => {
      if (imgUrl) {
        return /* @__PURE__ */ React__default["default"].createElement(ImageNamespace, {
          fit: "cover",
          src: imgUrl,
          lazyload: props.lazyload,
          className: clsx(bem$5(`${classPrefix}-img`))
        });
      }
      return null;
    };
    const onSelect = () => {
      if (choosable) {
        props.onSkuSelected(__spreadProps(__spreadValues({}, props.skuValue), { skuKeyStr: props.skuKeyStr }));
      }
    };
    const onPreviewImg = (event) => {
      event.stopPropagation();
      const { skuValue, skuKeyStr } = props;
      props.onSkuPreviewImage(__spreadProps(__spreadValues({}, skuValue), {
        ks: skuKeyStr,
        imgUrl: skuValue.imgUrl || skuValue.img_url
      }));
    };
    const choosed = props.skuValue.id === props.selectedSku[props.skuKeyStr];
    return /* @__PURE__ */ React__default["default"].createElement("span", {
      className: clsx(bem$5(classPrefix, {
        active: choosed,
        disabled: !choosable
      })),
      onClick: onSelect
    }, imageRender(), /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$5(`${classPrefix}-name`))
    }, props.largeImageMode ? /* @__PURE__ */ React__default["default"].createElement("span", {
      className: clsx("rv-multi-ellipsis--l2")
    }, (_a = props.skuValue) == null ? void 0 : _a.name) : (_b = props.skuValue) == null ? void 0 : _b.name), props.largeImageMode && (props.previewIcon || /* @__PURE__ */ React__default["default"].createElement(SvgExpandO, {
      className: clsx(bem$5(`${classPrefix}-img-icon`)),
      onClick: onPreviewImg
    })));
  };
  const [bem$4] = createNamespace("sku-row");
  const SkuRowPropItem = (props) => {
    var _a;
    const choosed = React.useMemo(() => {
      const { selectedProp, skuKeyStr, skuValue } = props;
      if (selectedProp && selectedProp[skuKeyStr]) {
        return selectedProp[skuKeyStr].indexOf(skuValue.id) > -1;
      }
      return false;
    }, [
      JSON.stringify(props.selectedProp),
      JSON.stringify(props.skuValue),
      props.skuKeyStr
    ]);
    const onSelect = () => {
      props.onSkuPropSelected(__spreadProps(__spreadValues({}, props.skuValue), {
        skuKeyStr: props.skuKeyStr,
        multiple: props.multiple
      }));
    };
    return /* @__PURE__ */ React__default["default"].createElement("span", {
      className: clsx(bem$4("item", {
        active: choosed
      })),
      onClick: onSelect
    }, /* @__PURE__ */ React__default["default"].createElement("span", {
      className: clsx(bem$4("item-name"))
    }, (_a = props.skuValue) == null ? void 0 : _a.name));
  };
  const { QUOTA_LIMIT: QUOTA_LIMIT$1, STOCK_LIMIT } = LIMIT_TYPE;
  const [bem$3] = createNamespace("sku");
  const SkuStepper = (props) => {
    const [limitType, setLimitType] = React.useState(STOCK_LIMIT);
    const stepperLimit = React.useMemo(() => {
      const quotaLimit = +props.quota - +props.quotaUsed;
      let limit;
      let currentLimitType;
      if (+props.quota > 0 && quotaLimit <= props.stock) {
        limit = quotaLimit < 0 ? 0 : quotaLimit;
        currentLimitType = QUOTA_LIMIT$1;
      } else {
        limit = props.stock;
        currentLimitType = STOCK_LIMIT;
      }
      setLimitType(currentLimitType);
      return limit;
    }, [props.quota, props.quotaUsed, props.stock]);
    const stepperMinLimit = React.useMemo(() => {
      return +props.startSaleNum < 1 ? 1 : +props.startSaleNum;
    }, [props.startSaleNum]);
    const quotaContent = React.useMemo(() => {
      const { quotaText, hideQuotaText } = props.customStepperConfig;
      if (hideQuotaText)
        return "";
      let text = "";
      if (quotaText) {
        text = quotaText;
      } else {
        const textArr = [];
        if (+props.startSaleNum > 1) {
          textArr.push(`${props.startSaleNum}\u4EF6\u8D77\u552E`);
        }
        if (+props.quota > 0) {
          textArr.push(`\u9650\u8D2D${+props.quota}\u4EF6`);
        }
        text = textArr.join(",");
      }
      return text;
    }, [
      JSON.stringify(props.customStepperConfig),
      props.startSaleNum,
      props.quota
    ]);
    const checkState = (min, max) => {
      if (props.currentNum < min || min > max) {
        props.onChange(min);
      } else if (props.currentNum > max) {
        props.onChange(max);
      }
      props.onSkuStepperState({
        valid: min <= max,
        min,
        max,
        limitType,
        quota: props.quota,
        quotaUsed: props.quotaUsed,
        startSaleNum: props.startSaleNum
      });
    };
    const setCurrentNum = (num) => {
      props.onChange(num);
      checkState(stepperMinLimit, stepperLimit);
    };
    const onChange = (currentValue) => {
      const intValue = parseInt(currentValue, 10);
      const { handleStepperChange } = props.customStepperConfig;
      if (handleStepperChange)
        handleStepperChange(intValue);
      setCurrentNum(currentValue);
    };
    const onOverLimit = (action) => {
      props.onSkuOverLimit({
        action,
        limitType,
        quota: props.quota,
        quotaUsed: props.quotaUsed,
        startSaleNum: props.startSaleNum
      });
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$3("stepper-stock"))
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$3("stepper-title"))
    }, props.stepperTitle), /* @__PURE__ */ React__default["default"].createElement(Stepper, {
      min: stepperMinLimit,
      max: stepperLimit,
      className: clsx(bem$3("stepper")),
      disableInput: props.disableStepperInput,
      value: props.currentNum,
      onChange,
      onOverlimit: onOverLimit
    }), !props.hideQuotaText && quotaContent && /* @__PURE__ */ React__default["default"].createElement("span", {
      className: clsx(bem$3("stepper-quota"))
    }, quotaContent));
  };
  SkuStepper.defaultProps = {
    quota: 0,
    quotaUsed: 0,
    startSaleNum: 1,
    customStepperConfig: {}
  };
  const { QUOTA_LIMIT } = LIMIT_TYPE;
  const [bem$2] = createNamespace("sku");
  const Sku = React.forwardRef((props, ref) => {
    var _a, _b;
    const stepperError = React.useRef(false);
    const [visible, setVisible] = React.useState(false);
    const [state, updateState] = useSetState({
      selectedSku: {},
      selectedProp: {},
      selectedNum: props.startSaleNum
    });
    const { sku, properties = [] } = props;
    const { tree = [] } = sku;
    const bodyStyle = React.useMemo(() => {
      const maxHeight = window.innerHeight - props.bodyOffsetTop;
      return {
        maxHeight: `${maxHeight}px`
      };
    }, [props.bodyOffsetTop]);
    const imageList = React.useMemo(() => {
      const { goods } = props;
      const rs = [goods == null ? void 0 : goods.picture];
      if (sku.tree.length > 0) {
        sku.tree.forEach((treeItem) => {
          if (!treeItem.v)
            return;
          treeItem.v.forEach((vItem) => {
            const img = vItem.previewImgUrl || vItem.imgUrl || vItem.img_url;
            if (img && rs.indexOf(img) === -1) {
              rs.push(img);
            }
          });
        });
      }
      return rs;
    }, [(_a = props.goods) == null ? void 0 : _a.picture, sku.tree]);
    const hasSku = React.useMemo(() => !sku.none_sku, [sku.none_sku]);
    const hasSkuOrAttr = React.useMemo(() => hasSku || properties.length > 0, [hasSku, properties]);
    const isSkuCombSelected = React.useMemo(() => {
      if (hasSku && !isAllSelected(tree, state.selectedSku)) {
        return false;
      }
      return !properties.filter((i) => i.is_necessary !== false).some((i) => (state.selectedProp[i.k_id] || []).length === 0);
    }, [hasSku, state]);
    const selectedSkuValues = React.useMemo(() => {
      return getSelectedSkuValues(tree, state.selectedSku);
    }, [tree, state.selectedSku]);
    const selectedPropValues = React.useMemo(() => {
      return getSelectedPropValues(properties, state.selectedProp);
    }, [properties, state.selectedProp]);
    const selectedSkuComb = React.useMemo(() => {
      let skuComb = null;
      if (isSkuCombSelected) {
        if (hasSku) {
          skuComb = getSkuComb(sku.list, state.selectedSku);
        } else {
          skuComb = {
            id: sku.collection_id,
            price: Math.round(+sku.price * 100),
            stock_num: sku.stock_num
          };
        }
        if (skuComb) {
          skuComb.properties = getSelectedProperties(properties, state.selectedProp);
          skuComb.property_price = selectedPropValues.reduce((acc, cur) => acc + (cur.price || 0), 0);
        }
      }
      return skuComb;
    }, [
      isSkuCombSelected,
      hasSku,
      JSON.stringify(sku),
      JSON.stringify(state),
      properties,
      selectedPropValues
    ]);
    const unselectedSku = React.useMemo(() => {
      return tree.filter((item) => !state.selectedSku[item.k_s]).map((item) => item.k);
    }, [tree, state.selectedSku]);
    const getUnselectedProp = React.useCallback((isNecessary) => {
      return properties.filter((item) => isNecessary ? item.is_necessary !== false : true).filter((item) => (state.selectedProp[item.k_id] || []).length < 1).map((item) => item.k);
    }, [properties, state.selectedProp]);
    const selectedText = React.useMemo(() => {
      if (selectedSkuComb) {
        const values = selectedSkuValues.concat(selectedPropValues);
        return `\u5DF2\u9009 ${values.map((item) => item.name).join(" ")}`;
      }
      return `\u8BF7\u9009\u62E9 ${unselectedSku.concat(getUnselectedProp()).join(" ")}`;
    }, [
      unselectedSku,
      getUnselectedProp,
      selectedSkuComb,
      selectedSkuValues,
      selectedPropValues
    ]);
    const price = React.useMemo(() => {
      if (selectedSkuComb) {
        return ((selectedSkuComb.price + selectedSkuComb.property_price) / 100).toFixed(2);
      }
      return sku.price;
    }, [JSON.stringify(selectedSkuComb), sku.price]);
    const stock = React.useMemo(() => {
      const { stockNum } = props.customStepperConfig;
      if (stockNum !== void 0) {
        return stockNum;
      }
      if (selectedSkuComb) {
        return selectedSkuComb.stock_num;
      }
      return sku.stock_num;
    }, [sku.stock_num, JSON.stringify(selectedSkuComb)]);
    const stockContent = React.useMemo(() => {
      if (props.stockRender) {
        return props.stockRender(stock);
      }
      return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, "\u5269\u4F59", /* @__PURE__ */ React__default["default"].createElement("span", {
        className: clsx(bem$2("stock-num", {
          highlight: stock < props.stockThreshold
        }))
      }, stock), "\u4EF6");
    }, [stock]);
    const onSelect = (skuValue) => {
      const selectedSku = state.selectedSku[skuValue.skuKeyStr] === skuValue.id ? __spreadProps(__spreadValues({}, state.selectedSku), {
        [skuValue.skuKeyStr]: UNSELECTED_SKU_VALUE_ID
      }) : __spreadProps(__spreadValues({}, state.selectedSku), { [skuValue.skuKeyStr]: skuValue.id });
      updateState({ selectedSku });
      if (props.onSkuSelected) {
        props.onSkuSelected({
          skuValue,
          selectedSku: state.selectedSku,
          selectedSkuComb
        });
      }
    };
    const onPropSelect = (propValue) => {
      const arr = state.selectedProp[propValue.skuKeyStr] || [];
      const pos = arr.indexOf(propValue.id);
      if (pos > -1) {
        arr.splice(pos, 1);
      } else if (propValue.multiple) {
        arr.push(propValue.id);
      } else {
        arr.splice(0, 1, propValue.id);
      }
      const selectedProp = __spreadProps(__spreadValues({}, state.selectedProp), {
        [propValue.skuKeyStr]: arr
      });
      updateState({ selectedProp });
      if (props.onSkuPropSelected) {
        props.onSkuPropSelected({
          propValue,
          selectedProp: state.selectedProp,
          selectedSkuComb
        });
      }
    };
    const onOverLimit = (data) => {
      const { action, limitType, quota, quotaUsed } = data;
      const { handleOverLimit } = props.customStepperConfig;
      if (handleOverLimit) {
        handleOverLimit(data);
        return;
      }
      if (action === "minus") {
        if (props.startSaleNum > 1) {
          Toast(`${props.startSaleNum}\u4EF6\u8D77\u552E`);
        } else {
          Toast("\u81F3\u5C11\u9009\u62E9\u4E00\u4EF6");
        }
      } else if (action === "plus") {
        if (limitType === QUOTA_LIMIT) {
          if (quotaUsed > 0) {
            Toast(`\u6BCF\u4EBA\u9650\u8D2D${quota}\u4EF6\uFF0C\u4F60\u5DF2\u8D2D\u4E70${quotaUsed}\u4EF6`);
          } else {
            Toast(`\u6BCF\u4EBA\u9650\u8D2D${quota}\u4EF6`);
          }
        } else {
          Toast("\u5E93\u5B58\u4E0D\u8DB3");
        }
      }
    };
    const onStepperState = (data) => {
      stepperError.current = data.valid ? null : __spreadProps(__spreadValues({}, data), {
        action: "plus"
      });
    };
    const validateSku = () => {
      if (state.selectedNum === 0) {
        return "\u5546\u54C1\u5DF2\u7ECF\u65E0\u6CD5\u8D2D\u4E70\u5566";
      }
      if (isSkuCombSelected) {
        return "";
      }
      return `\u8BF7\u9009\u62E9 ${unselectedSku.concat(getUnselectedProp(true)).join(" ")}`;
    };
    const getSkuData = () => {
      return {
        goodsId: props.goodsId,
        selectedNum: state.selectedNum,
        selectedSkuComb
      };
    };
    const onAddCart = (data) => {
      var _a2;
      (_a2 = props.onAddCart) == null ? void 0 : _a2.call(props, data);
    };
    const onBuyClicked = (data) => {
      var _a2;
      (_a2 = props.onBuyClicked) == null ? void 0 : _a2.call(props, data);
    };
    const onBuyOrAddCart = async (type2) => {
      if (stepperError.current) {
        onOverLimit(stepperError.current);
        return;
      }
      if (props.customSkuValidator) {
        if (!await props.customSkuValidator(type2, __spreadValues(__spreadValues({}, state.selectedSku), state.selectedProp))) {
          return;
        }
      } else {
        const error = validateSku();
        if (error) {
          Toast(error);
          return;
        }
      }
      const data = getSkuData();
      if (type2 === "add-cart") {
        onAddCart(data);
      } else {
        onBuyClicked(data);
      }
    };
    const show2 = (initialValue) => {
      setVisible(true);
      if (initialValue) {
        updateState(initialValue);
      }
    };
    const reset = () => {
      updateState({
        selectedSku: {},
        selectedProp: {},
        selectedNum: props.startSaleNum
      });
    };
    const onPopupClose = () => {
      setVisible(false);
      if (props.popupProps && props.popupProps.onClose)
        props.popupProps.onClose();
    };
    const onPopupClosed = () => {
      if (props.resetOnHide) {
        reset();
      }
      if (props.popupProps && props.popupProps.onClosed)
        props.popupProps.onClosed();
    };
    const onPreviewImage = (selectedValue) => {
      let index2 = 0;
      let indexImage = imageList[0];
      if (selectedValue && selectedValue.imgUrl) {
        imageList.some((image, pos) => {
          if (image === selectedValue.imgUrl) {
            index2 = pos;
            return true;
          }
          return false;
        });
        indexImage = selectedValue.imgUrl;
      }
      const params = __spreadProps(__spreadValues({}, selectedValue), {
        index: index2,
        imageList,
        indexImage
      });
      if (!props.previewOnClickImage)
        return;
      ImagePreview.open({
        images: imageList,
        startPosition: index2,
        onClose: () => {
          if (props.onClosePreview)
            props.onClosePreview(params);
        }
      });
      if (props.onOpenPreview) {
        props.onOpenPreview(params);
      }
    };
    const renderHeaderInfo = () => {
      var _a2;
      return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, ((_a2 = props.skuHeaderPriceRender) == null ? void 0 : _a2.call(props, price)) || /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$2("goods-price"))
      }, /* @__PURE__ */ React__default["default"].createElement("span", {
        className: clsx(bem$2("price-symbol"))
      }, "\uFFE5"), /* @__PURE__ */ React__default["default"].createElement("span", {
        className: clsx(bem$2("price-num"))
      }, price), props.priceTag && /* @__PURE__ */ React__default["default"].createElement("span", {
        className: clsx(bem$2("price-tag"))
      }, props.priceTag)), props.skuHeaderOriginPrice && /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$2("header-item"))
      }, props.skuHeaderOriginPrice), !props.hideStock && /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$2("header-item"))
      }, /* @__PURE__ */ React__default["default"].createElement("span", {
        className: clsx(bem$2("stock"))
      }, stockContent)), !props.hideSelectedText && /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$2("header-item"))
      }, selectedText));
    };
    const renderHeader = () => {
      if (props.skuHeader)
        return props.skuHeader;
      const selectedValue = getSkuImgValue(sku, state.selectedSku);
      const imgUrl = selectedValue ? selectedValue.imgUrl : props.goods.picture;
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$2("header"), BORDER_BOTTOM)
      }, props.showHeaderImage && /* @__PURE__ */ React__default["default"].createElement(ImageNamespace, {
        fit: "cover",
        src: imgUrl,
        className: clsx(bem$2("header__img-wrap")),
        onClick: () => onPreviewImage(selectedValue)
      }, props.skuHeaderImageExtra), /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$2("header__goods-info"))
      }, renderHeaderInfo(), props.skuHeaderExtra));
    };
    const renderGroup = () => {
      return props.skuGroup || hasSkuOrAttr && /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$2("group-container", {
          "hide-soldout": !props.showSoldoutSku
        }))
      }, tree.map((skuTreeItem, i) => /* @__PURE__ */ React__default["default"].createElement(SkuRow, {
        key: i,
        skuRow: skuTreeItem
      }, skuTreeItem.v.map((skuValue, idx) => /* @__PURE__ */ React__default["default"].createElement(SkuRowItem, {
        key: idx,
        skuList: sku.list,
        skuValue,
        skuKeyStr: `${skuTreeItem.k_s}`,
        selectedSku: state.selectedSku,
        disableSoldoutSku: props.disableSoldoutSku,
        largeImageMode: skuTreeItem.largeImageMode,
        previewIcon: props.previewIcon,
        onSkuSelected: onSelect,
        onSkuPreviewImage: (selectedValue) => onPreviewImage(selectedValue)
      })))), properties.map((skuTreeItem, i) => /* @__PURE__ */ React__default["default"].createElement(SkuRow, {
        key: i,
        skuRow: skuTreeItem
      }, skuTreeItem.v.map((skuValue, idx) => /* @__PURE__ */ React__default["default"].createElement(SkuRowPropItem, {
        key: idx,
        skuValue,
        skuKeyStr: `${skuTreeItem.k_id}`,
        selectedProp: state.selectedProp,
        multiple: skuTreeItem.is_multiple,
        onSkuPropSelected: onPropSelect
      })))));
    };
    const renderStepper = () => props.skuStepper || /* @__PURE__ */ React__default["default"].createElement(SkuStepper, {
      currentNum: state.selectedNum,
      onChange: (currentValue) => {
        updateState({ selectedNum: parseInt(`${currentValue}`, 10) });
        if (props.onStepperChange)
          props.onStepperChange(currentValue);
      },
      stock,
      quota: props.quota,
      quotaUsed: props.quotaUsed,
      startSaleNum: props.startSaleNum,
      disableStepperInput: props.disableStepperInput,
      customStepperConfig: props.customStepperConfig,
      stepperTitle: props.stepperTitle,
      hideQuotaText: props.hideQuotaText,
      onSkuStepperState: onStepperState,
      onSkuOverLimit: onOverLimit
    });
    const renderBody = () => {
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$2("body")),
        style: bodyStyle
      }, props.skuBodyTop, renderGroup(), props.skuGroupExtra, renderStepper());
    };
    const renderActions = () => {
      return props.skuActions || /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$2("actions"))
      }, /* @__PURE__ */ React__default["default"].createElement(ActionBar, null, props.showAddCartBtn && /* @__PURE__ */ React__default["default"].createElement(ActionBar.Button, {
        type: "warning",
        text: props.addCartText || "\u52A0\u5165\u8D2D\u7269\u8F66",
        onClick: () => onBuyOrAddCart("add-cart")
      }), /* @__PURE__ */ React__default["default"].createElement(ActionBar.Button, {
        type: "danger",
        text: props.buyText || "\u7ACB\u5373\u8D2D\u4E70",
        onClick: () => onBuyOrAddCart("buy-clicked")
      })));
    };
    React.useEffect(() => {
      if (props.initialSku) {
        updateState(props.initialSku);
      }
    }, [JSON.stringify(props.initialSku)]);
    React.useImperativeHandle(ref, () => ({
      reset,
      getSkuData,
      show: show2,
      update: updateState
    }));
    return /* @__PURE__ */ React__default["default"].createElement(Popup, __spreadProps(__spreadValues({
      round: true,
      closeable: true,
      position: "bottom"
    }, props.popupProps), {
      visible,
      onClose: onPopupClose,
      onClosed: onPopupClosed,
      className: clsx((_b = props.popupProps) == null ? void 0 : _b.className, bem$2("container"))
    }), renderHeader(), renderBody(), props.skuActionsTop, renderActions(), props.skuActionsBottom);
  });
  Sku.defaultProps = {
    stepperTitle: "\u8D2D\u4E70\u6570\u91CF",
    properties: [],
    showAddCartBtn: true,
    disableSoldoutSku: true,
    showHeaderImage: true,
    previewOnClickImage: true,
    showSoldoutSku: true,
    resetOnHide: true,
    safeAreaInsetBottom: true,
    quota: 0,
    quotaUsed: 0,
    startSaleNum: 1,
    stockThreshold: 50,
    bodyOffsetTop: 200,
    customStepperConfig: {}
  };
  var index$1 = "";
  const FloatingBallItem$1 = React.createContext({});
  var FloatingBallItem = (props) => {
    const parent = React__default["default"].useContext(FloatingBallItem$1);
    const handleItemClick = () => {
      parent == null ? void 0 : parent.close();
    };
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx("rv-floating-ball__menu__item"),
      onClick: handleItemClick
    }, props.children);
  };
  function getDirection(x2, y2) {
    if (x2 > y2) {
      return "horizontal";
    }
    if (y2 > x2) {
      return "vertical";
    }
    return "";
  }
  const INITIAL_STATE = {
    startX: 0,
    startY: 0,
    deltaX: 0,
    deltaY: 0,
    offsetX: 0,
    offsetY: 0,
    _pointX: 0,
    _pointY: 0,
    ready: false,
    direction: ""
  };
  const useFloatingTouch = (props) => {
    const { boundary = true } = props;
    const [state, update2] = useSetState(INITIAL_STATE);
    useIsomorphicLayoutEffect(() => {
      if (!props.target)
        return;
      const rect = props.target.getBoundingClientRect();
      const { width, height } = rect;
      const offset2 = Object.entries(props.offset).reduce((a, [k2, v2]) => {
        let px = unitToPx(v2);
        let axis = "deltaY";
        if (k2 === "left")
          px = window.innerWidth - px - width;
        if (k2 === "top")
          px = window.innerHeight - px - height;
        if (k2 === "left" || k2 === "right")
          axis = "deltaX";
        a[axis] = -px;
        return a;
      }, {});
      update2(__spreadValues({}, offset2));
      raf$1(() => {
        update2({ ready: true });
      });
    }, [props.target]);
    const getBound = React.useCallback(() => {
      if (!props.target)
        return {};
      return props.target.getBoundingClientRect();
    }, [props.target]);
    const isVertical = React.useCallback(() => state.direction === "vertical", [state.direction]);
    const isHorizontal = React.useCallback(() => state.direction === "horizontal", [state.direction]);
    const reset = () => {
      update2(INITIAL_STATE);
    };
    const start2 = (event) => {
      const rect = getBound();
      update2((v2) => ({
        startX: event.touches[0].clientX - v2.deltaX,
        startY: event.touches[0].clientY - v2.deltaY,
        _pointX: event.touches[0].clientX - rect.left,
        _pointY: event.touches[0].clientY - rect.top
      }));
    };
    const move2 = (event) => {
      const touch = event.touches[0];
      const rect = getBound();
      update2((value) => {
        const newState = __spreadValues({}, value);
        newState.deltaX = touch.clientX - newState.startX;
        if (boundary && touch.clientX - newState._pointX <= 0)
          newState.deltaX = -window.innerWidth + rect.width;
        if (boundary && touch.clientX - newState._pointX >= window.innerWidth - rect.width)
          newState.deltaX = 0;
        newState.deltaY = touch.clientY - newState.startY;
        if (boundary && touch.clientY - newState._pointY <= 0)
          newState.deltaY = -window.innerHeight + rect.height;
        if (boundary && touch.clientY - newState._pointY >= window.innerHeight - rect.height)
          newState.deltaY = 0;
        newState.offsetX = Math.abs(newState.deltaX);
        newState.offsetY = Math.abs(newState.deltaY);
        const LOCK_DIRECTION_DISTANCE = 10;
        if (!newState.direction || newState.offsetX < LOCK_DIRECTION_DISTANCE && newState.offsetY < LOCK_DIRECTION_DISTANCE) {
          newState.direction = getDirection(newState.offsetX, newState.offsetY);
        }
        return newState;
      });
    };
    return __spreadProps(__spreadValues({}, state), {
      update: update2,
      move: move2,
      start: start2,
      reset,
      isVertical,
      isHorizontal
    });
  };
  const TOUCH_DURATION = 0;
  const TRANSITION_DURATION = 300;
  const DEFAULT_ADSORB = { indent: 0.5, distance: 0 };
  const [bem$1] = createNamespace("floating-ball");
  const FloatingBall = React.forwardRef((props, ref) => {
    var _a, _b, _c, _d;
    const timer = React__default["default"].useRef(null);
    const [position, setPosition] = React.useState("bottom right");
    const [container, setContainer] = React__default["default"].useState();
    const touch = useFloatingTouch({
      target: container,
      offset: props.offset
    });
    const [active, updateActive] = useMergedState({
      value: (_a = props.menu) == null ? void 0 : _a.active,
      defaultValue: (_b = props.menu) == null ? void 0 : _b.defaultActive
    });
    const [state, updateState] = useSetState({
      indenting: false,
      duration: TOUCH_DURATION
    });
    const isIndenting = state.indenting;
    const isDraggable = (event) => props.draggable && event.touches.length === 1 && container && !props.disabled;
    const adsorb = React__default["default"].useMemo(() => {
      if (typeof props.adsorb === "boolean") {
        if (!props.adsorb)
          return false;
        return DEFAULT_ADSORB;
      }
      return __spreadValues(__spreadValues({}, DEFAULT_ADSORB), props.adsorb);
    }, [props.adsorb]);
    const validMenus = React__default["default"].useMemo(() => {
      var _a2, _b2;
      return (props == null ? void 0 : props.menu.items) && Array.isArray((_a2 = props.menu) == null ? void 0 : _a2.items) ? (_b2 = props.menu) == null ? void 0 : _b2.items.filter(Boolean).filter((_, i) => i < 5) : [];
    }, [(_c = props.menu) == null ? void 0 : _c.items]);
    const renderMenus = React__default["default"].useCallback(() => {
      var _a2, _b2;
      if (!validMenus.length)
        return null;
      const [position1, position2] = position.split(" ");
      return /* @__PURE__ */ React__default["default"].createElement("div", {
        className: clsx(bem$1("menu", {
          [(_a2 = props.menu) == null ? void 0 : _a2.direction]: !!((_b2 = props.menu) == null ? void 0 : _b2.direction),
          [position1]: !!position1,
          [position2]: !!position2
        }), `list-${Math.max(validMenus.length, 5)}`)
      }, validMenus.map((cld, i) => /* @__PURE__ */ React__default["default"].createElement(FloatingBallItem, {
        key: i
      }, cld)));
    }, [position, (_d = props.menu) == null ? void 0 : _d.direction, validMenus]);
    const checkMenuPosition = () => {
      if (container) {
        const {
          rect: { left: left2, top: top2, width, height }
        } = getSideWithRect();
        const windowW = window.innerWidth;
        const windowH = window.innerHeight;
        if (left2 + width / 2 < windowW / 2) {
          position.indexOf("right") >= 0 && setPosition((state2) => state2.replace("right", "left"));
        } else if (position.indexOf("left") >= 0) {
          setPosition((state2) => state2.replace("left", "right"));
        }
        if (top2 + height / 2 < windowH / 2) {
          position.indexOf("bottom") >= 0 && setPosition((state2) => state2.replace("bottom", "top"));
        } else if (position.indexOf("top") >= 0) {
          setPosition((state2) => state2.replace("top", "bottom"));
        }
      }
    };
    const innerChange = (value) => {
      var _a2, _b2;
      updateActive(value);
      (_b2 = (_a2 = props.menu) == null ? void 0 : _a2.onChange) == null ? void 0 : _b2.call(_a2, value);
    };
    const handleBaseClick = () => {
      if (props.disabled || !validMenus.length)
        return;
      innerChange(!active);
    };
    const getSideWithRect = () => {
      const rect = container.getBoundingClientRect();
      const side = rect.left + rect.width / 2 > window.innerWidth / 2 ? "right" : "left";
      return { rect, side };
    };
    const checkPosition = () => {
      const { side, rect } = getSideWithRect();
      if (adsorb) {
        const { distance } = adsorb;
        const isRightSide = side === "right";
        const x2 = isRightSide ? -distance : -(window.innerWidth - rect.width) + +distance;
        updateState({ duration: TRANSITION_DURATION });
        touch.update({ deltaX: x2 });
      }
    };
    const onTouchStart = (event) => {
      if (!isDraggable(event) || isIndenting)
        return;
      updateState({ duration: TOUCH_DURATION });
      touch.start(event);
    };
    const onTouchMove = (event) => {
      if (!isDraggable(event) || isIndenting)
        return;
      touch.move(event);
      if (typeof event.cancelable !== "boolean" || event.cancelable) {
        event.preventDefault();
      }
      if (active)
        innerChange(false);
    };
    const onTouchEnd = () => {
      if (isIndenting)
        return;
      checkPosition();
      checkMenuPosition();
    };
    useIsomorphicLayoutEffect(() => {
      if (!active || !touch.ready)
        return;
      checkMenuPosition();
    }, [touch.ready]);
    useEventListener("touchmove", onTouchMove, {
      target: container,
      depends: [
        container,
        touch.deltaX,
        touch.deltaY,
        props.disabled,
        props.draggable
      ]
    });
    useClickAway(container, () => {
      innerChange(false);
    });
    React.useImperativeHandle(ref, () => ({
      open: () => {
        if (!validMenus.length)
          return;
        raf$1(() => innerChange(true));
      },
      close: () => {
        if (!validMenus.length)
          return;
        raf$1(() => innerChange(false));
      }
    }));
    useIsomorphicLayoutEffect(() => {
      if (props.disabled || !adsorb || !touch.ready)
        return;
      const onScroll = () => {
        const { side, rect } = getSideWithRect();
        const { indent, distance } = adsorb;
        const isRightSide = side === "right";
        const indentPx = rect.width * (isRightSide ? +indent : 1 - +indent);
        const offsetX = isRightSide ? +indentPx : -(window.innerWidth - indentPx);
        updateState({
          indenting: true,
          duration: TRANSITION_DURATION
        });
        innerChange(false);
        touch.update({ deltaX: offsetX });
        if (timer.current)
          clearTimeout(timer.current);
        timer.current = setTimeout(() => {
          const x2 = isRightSide ? -distance : -(window.innerWidth - rect.width) + +distance;
          updateState({ indenting: false });
          touch.update({ deltaX: x2 });
        }, 600);
      };
      const handle = throttle(() => raf$1(onScroll), 300);
      window.addEventListener("scroll", handle);
      return () => window.removeEventListener("scroll", handle);
    }, [touch.ready, container, adsorb, props.disabled]);
    const indentClassName = React__default["default"].useMemo(() => {
      if (!adsorb)
        return "";
      if (state.indenting)
        return adsorb.indentClassName;
      return "";
    }, [adsorb, state.indenting]);
    const trackStyle = React__default["default"].useMemo(() => __spreadProps(__spreadValues({}, props.style), {
      transitionDuration: `${state.duration}ms`,
      transform: `translate3d(${touch.deltaX}px,${touch.deltaY}px, 0)`
    }), [props.style, state.duration, touch.deltaX, touch.deltaY]);
    return /* @__PURE__ */ React__default["default"].createElement(FloatingBallItem$1.Provider, {
      value: {
        close: () => {
          var _a2, _b2;
          const closeable = (_b2 = (_a2 = props.menu) == null ? void 0 : _a2.itemClickClose) != null ? _b2 : true;
          if (closeable)
            innerChange(false);
        }
      }
    }, /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(props.className, indentClassName, bem$1({ active })),
      style: trackStyle,
      ref: setContainer,
      onTouchStart,
      onTouchEnd,
      onTouchCancel: onTouchEnd
    }, renderMenus(), /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem$1("base", {
        [props.disabledClassName]: props.disabled
      })),
      onClick: handleBaseClick
    }, typeof props.children === "function" ? props.children({ active, indenting: state.indenting }) : props.children)));
  });
  FloatingBall.defaultProps = {
    adsorb: DEFAULT_ADSORB,
    draggable: true,
    menu: {},
    offset: {
      right: 0,
      bottom: "30vh"
    }
  };
  var index = "";
  const DEFAULT_FONT = {
    style: "normal",
    weight: "normal",
    color: "rgba(0,0,0,.15)",
    size: 14,
    family: "sans-serif"
  };
  const [bem] = createNamespace("water-mark");
  const WaterMark = (props) => {
    const { zIndex, gapX, gapY, width, height, rotate, image, content, font } = props;
    const [base64Url, setBase64Url] = React__default["default"].useState("");
    React__default["default"].useEffect(() => {
      const canvas = document.createElement("canvas");
      const ratio = window.devicePixelRatio;
      const ctx2 = canvas.getContext("2d");
      const canvasWidth = `${(gapX + width) * ratio}px`;
      const canvasHeight = `${(gapY + height) * ratio}px`;
      const markWidth = width * ratio;
      const markHeight = height * ratio;
      canvas.setAttribute("width", canvasWidth);
      canvas.setAttribute("height", canvasHeight);
      if (ctx2) {
        if (image) {
          const { width: width2, height: height2, src } = image;
          ctx2.translate(markWidth / 2, markHeight / 2);
          ctx2.rotate(Math.PI / 180 * Number(rotate));
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.referrerPolicy = "no-referrer";
          img.src = src;
          img.onload = () => {
            ctx2.drawImage(img, -width2 * ratio / 2, -height2 * ratio / 2, width2 * ratio, height2 * ratio);
            ctx2.restore();
            setBase64Url(canvas.toDataURL());
          };
        } else if (content) {
          const frontProps = __spreadValues(__spreadValues({}, font), DEFAULT_FONT);
          const { size, family, style, weight, color } = frontProps;
          ctx2.textBaseline = "middle";
          ctx2.textAlign = "center";
          ctx2.translate(markWidth / 2, markHeight / 2);
          ctx2.rotate(Math.PI / 180 * Number(rotate));
          const markSize = Number(size) * ratio;
          ctx2.font = `${style} normal ${weight} ${markSize}px/${markHeight}px ${family}`;
          ctx2.fillStyle = color;
          ctx2.fillText(content, 0, 0);
          ctx2.restore();
          setBase64Url(canvas.toDataURL());
        }
      } else {
        throw new Error("\u5F53\u524D\u73AF\u5883\u4E0D\u652F\u6301Canvas");
      }
    }, [gapX, gapY, rotate, width, height, image, content, font]);
    return /* @__PURE__ */ React__default["default"].createElement("div", {
      className: clsx(bem({
        full: props.fullPage
      })),
      style: {
        zIndex,
        backgroundSize: `${gapX + width}px`,
        backgroundImage: `url('${base64Url}')`
      }
    });
  };
  WaterMark.defaultProps = {
    zIndex: 2e3,
    gapX: 24,
    gapY: 48,
    width: 100,
    height: 64,
    rotate: -22,
    font: DEFAULT_FONT,
    fullPage: true
  };
  exports2.ActionBar = ActionBar;
  exports2.ActionSheet = ActionSheet;
  exports2.Area = Area;
  exports2.Badge = Badge;
  exports2.Button = Button;
  exports2.Calendar = Calendar;
  exports2.Card = Card;
  exports2.Cascader = CascaderPopup;
  exports2.Cell = Cell;
  exports2.CellGroup = CellGroup;
  exports2.Checkbox = Checkbox;
  exports2.CheckboxGroup = CheckBoxGroup;
  exports2.Circle = Circle;
  exports2.Collapse = Collapse;
  exports2.CollapseItem = CollapseItem;
  exports2.ConfigProvider = ConfigProvider;
  exports2.CountDown = CountDown;
  exports2.CouponCell = CouponCell;
  exports2.CouponList = CouponList;
  exports2.DatetimePicker = DateTimePicker;
  exports2.Dialog = Dialog;
  exports2.Divider = Divider;
  exports2.DropdownMenu = DropdownMenu;
  exports2.Empty = Empty;
  exports2.Field = FieldNamespace;
  exports2.Flex = Flex;
  exports2.FloatingBall = FloatingBall;
  exports2.Form = Form;
  exports2.Grid = GridNamespace;
  exports2.GridItem = GridItem;
  exports2.Image = ImageNamespace;
  exports2.ImagePreview = ImagePreview;
  exports2.IndexAnchor = IndexAnchor;
  exports2.IndexBar = IndexBar;
  exports2.Input = Input;
  exports2.Lazyload = Lazyload;
  exports2.List = List$1;
  exports2.Loading = Loading;
  exports2.NavBar = NavBar;
  exports2.NoticeBar = NoticeBar;
  exports2.Notify = exportNotifyNamespace;
  exports2.NumberKeyboard = NumberKeyboard;
  exports2.Overlay = Overlay;
  exports2.Pagination = Pagination;
  exports2.PasswordInput = PasswordInput;
  exports2.Picker = Picker;
  exports2.Popover = Popover;
  exports2.Popup = Popup;
  exports2.ProductCard = ProductCard;
  exports2.Progress = Progress;
  exports2.PullRefresh = PullRefresh;
  exports2.Radio = Radio;
  exports2.RadioGroup = RadioGroup;
  exports2.Rate = Rate;
  exports2.Search = Search;
  exports2.Selector = Selector;
  exports2.ShareSheet = ShareSheet;
  exports2.Sidebar = Sidebar;
  exports2.SidebarItem = SidebarItem;
  exports2.Skeleton = Skeleton;
  exports2.Sku = Sku;
  exports2.Slider = Slider;
  exports2.Space = Space;
  exports2.Stepper = Stepper;
  exports2.Steps = Steps;
  exports2.StepsItem = StepsItem;
  exports2.Sticky = Sticky;
  exports2.SubmitBar = SubmitBar;
  exports2.SwipeCell = SwipeCell;
  exports2.Swiper = Swiper;
  exports2.Switch = Swtich;
  exports2.Tabbar = Tabbar;
  exports2.TabbarItem = TabbarItem;
  exports2.Tabs = Tabs;
  exports2.Tag = Tag;
  exports2.Toast = Toast;
  exports2.Typography = TypographyNamespace;
  exports2.Uploader = Uploader;
  exports2.WaterMark = WaterMark;
  exports2.hooks = index$14;
  Object.defineProperties(exports2, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
});
